// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"../../../Users/Oluwanifemi/AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/process/browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}
(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  }
  // if setTimeout wasn't available but was latter defined
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  }
  // if clearTimeout wasn't available but was latter defined
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};

// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};
process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function (name) {
  return [];
};
process.binding = function (name) {
  throw new Error('process.binding is not supported');
};
process.cwd = function () {
  return '/';
};
process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};
process.umask = function () {
  return 0;
};
},{}],"node_modules/jquery/dist/jquery.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
var define;
/*!
 * jQuery JavaScript Library v3.6.4
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-03-08T15:28Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket trac-14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

		// Support: Chrome <=57, Firefox <=52
		// In some browsers, typeof returns "function" for HTML <object> elements
		// (i.e., `typeof document.createElement( "object" ) === "function"`).
		// We don't want to classify *any* DOM node as a function.
		// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
		// Plus for old WebKit, typeof returns "function" for HTML collections
		// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
		return typeof obj === "function" && typeof obj.nodeType !== "number" &&
			typeof obj.item !== "function";
	};


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.6.4",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
						[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.10
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2023-02-14
 */
( function( window ) {
var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ( {} ).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	pushNative = arr.push,
	push = arr.push,
	slice = arr.slice,

	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[ i ] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
		"ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5]
		// or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" +
		whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rleadingCombinator = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +
		"*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
			whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
			whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		return nonHex ?

			// Strip the backslash prefix from a non-hex escape sequence
			nonHex :

			// Replace a hexadecimal escape sequence with the encoded Unicode code point
			// Support: IE <=11+
			// For values outside the Basic Multilingual Plane (BMP), manually construct a
			// surrogate pair
			high < 0 ?
				String.fromCharCode( high + 0x10000 ) :
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" +
				ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android<4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;

			// Can't trust NodeList.length
			while ( ( target[ j++ ] = els[ i++ ] ) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&

				// Support: IE 8 only
				// Exclude object elements
				( nodeType !== 1 || context.nodeName.toLowerCase() !== "object" ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rleadingCombinator.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					if ( newContext !== context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split( "|" ),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[ i ] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( ( cur = cur.nextSibling ) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return ( name === "input" || name === "button" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
					inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem && elem.namespaceURI,
		docElem = elem && ( elem.ownerDocument || elem ).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
	// Safari 4 - 5 only, Opera <=11.6 - 12.x only
	// IE/Edge & older browsers don't support the :scope pseudo-class.
	// Support: Safari 6.0 only
	// Safari 6.0 supports :scope but it's an alias of :root there.
	support.scope = assert( function( el ) {
		docElem.appendChild( el ).appendChild( document.createElement( "div" ) );
		return typeof el.querySelectorAll !== "undefined" &&
			!el.querySelectorAll( ":scope fieldset div" ).length;
	} );

	// Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
	// Make sure the the `:has()` argument is parsed unforgivingly.
	// We include `*` in the test to detect buggy implementations that are
	// _selectively_ forgiving (specifically when the list includes at least
	// one valid selector).
	// Note that we treat complete lack of support for `:has()` as if it were
	// spec-compliant support, which is fine because use of `:has()` in such
	// environments will fail in the qSA path and fall back to jQuery traversal
	// anyway.
	support.cssHas = assert( function() {
		try {
			document.querySelector( ":has(*,:jqfake)" );
			return false;
		} catch ( e ) {
			return true;
		}
	} );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert( function( el ) {
		el.className = "i";
		return !el.getAttribute( "className" );
	} );

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert( function( el ) {
		el.appendChild( document.createComment( "" ) );
		return !el.getElementsByTagName( "*" ).length;
	} );

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter[ "ID" ] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter[ "ID" ] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find[ "TAG" ] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,

				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( ( elem = results[ i++ ] ) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find[ "CLASS" ] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {

		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert( function( el ) {

			var input;

			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll( "[msallowcapture^='']" ).length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll( "[selected]" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push( "~=" );
			}

			// Support: IE 11+, Edge 15 - 18+
			// IE 11/Edge don't find elements on a `[name='']` query in some cases.
			// Adding a temporary attribute to the document before the selection works
			// around the issue.
			// Interestingly, IE 10 & older don't seem to have the issue.
			input = document.createElement( "input" );
			input.setAttribute( "name", "" );
			el.appendChild( input );
			if ( !el.querySelectorAll( "[name='']" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
					whitespace + "*(?:''|\"\")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll( ":checked" ).length ) {
				rbuggyQSA.push( ":checked" );
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push( ".#.+[+~]" );
			}

			// Support: Firefox <=3.6 - 5 only
			// Old Firefox doesn't throw on a badly-escaped identifier.
			el.querySelectorAll( "\\\f" );
			rbuggyQSA.push( "[\\r\\n\\f]" );
		} );

		assert( function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement( "input" );
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll( "[name=d]" ).length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll( ":enabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: Opera 10 - 11 only
			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll( "*,:x" );
			rbuggyQSA.push( ",.*:" );
		} );
	}

	if ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector ) ) ) ) {

		assert( function( el ) {

			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		} );
	}

	if ( !support.cssHas ) {

		// Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
		// Our regular `try-catch` mechanism fails to detect natively-unsupported
		// pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
		// in browsers that parse the `:has()` argument as a forgiving selector list.
		// https://drafts.csswg.org/selectors/#relational now requires the argument
		// to be parsed unforgivingly, but browsers have not yet fully adjusted.
		rbuggyQSA.push( ":has" );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( "|" ) );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {

			// Support: IE <9 only
			// IE doesn't have `contains` on `document` so we need to check for
			// `documentElement` presence.
			// We need to fall back to `a` when `documentElement` is missing
			// as `ownerDocument` of elements within `<template/>` may have
			// a null one - a default behavior of all modern browsers.
			var adown = a.nodeType === 9 && a.documentElement || a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			) );
		} :
		function( a, b ) {
			if ( b ) {
				while ( ( b = b.parentNode ) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a == document || a.ownerDocument == preferredDoc &&
				contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b == document || b.ownerDocument == preferredDoc &&
				contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {

		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			return a == document ? -1 :
				b == document ? 1 :
				/* eslint-enable eqeqeq */
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( ( cur = cur.parentNode ) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( ( cur = cur.parentNode ) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[ i ] === bp[ i ] ) {
			i++;
		}

		return i ?

			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[ i ], bp[ i ] ) :

			// Otherwise nodes in our document sort first
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			ap[ i ] == preferredDoc ? -1 :
			bp[ i ] == preferredDoc ? 1 :
			/* eslint-enable eqeqeq */
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

				// As well, disconnected nodes are said to be in a document
				// fragment in IE 9
				elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			( val = elem.getAttributeNode( name ) ) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {

		// If no nodeType, this is expected to be an array
		while ( ( node = elem[ i++ ] ) ) {

			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {

		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {

			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}

	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] ||
				match[ 5 ] || "" ).replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					Sizzle.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" ) );
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

				// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				Sizzle.error( match[ 0 ] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr[ "CHILD" ].test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace +
					")" + className + "(" + whitespace + "|$)" ) ) && classCache(
						className, function( elem ) {
							return pattern.test(
								typeof elem.className === "string" && elem.className ||
								typeof elem.getAttribute !== "undefined" &&
									elem.getAttribute( "class" ) ||
								""
							);
				} );
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				/* eslint-disable max-len */

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
				/* eslint-enable max-len */

			};
		},

		"CHILD": function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || ( node[ expando ] = {} );

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								( outerCache[ node.uniqueID ] = {} );

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {

								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || ( node[ expando ] = {} );

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									( outerCache[ node.uniqueID ] = {} );

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												( outerCache[ node.uniqueID ] = {} );

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		"not": markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element (issue #299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		"has": markFunction( function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		} ),

		"contains": markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement &&
				( !document.hasFocus || document.hasFocus() ) &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return ( nodeName === "input" && !!elem.checked ) ||
				( nodeName === "option" && !!elem.selected );
		},

		"selected": function( elem ) {

			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {

			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos[ "empty" ]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE <10 only
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		"last": createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		"eq": createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		"even": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"odd": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"lt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"gt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos[ "nth" ] = Expr.pseudos[ "eq" ];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rleadingCombinator.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrim, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :

			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] ||
							( outerCache[ elem.uniqueID ] = {} );

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = uniqueCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts(
				selector || "*",
				context.nodeType ? [ context ] : context,
				[]
			),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?

				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

					// If the preceding token was a descendant combinator, insert an implicit any-element `*`
					tokens
						.slice( 0, i - 1 )
						.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find[ "TAG" ]( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache(
			selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers )
		);

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
			context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find[ "ID" ]( token.matches[ 0 ]
				.replace( runescape, funescape ), context ) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr[ "needsContext" ].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||
						context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert( function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute( "href" ) === "#";
} ) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	} );
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert( function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
} ) ) {
	addHandle( "value", function( elem, _name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	} );
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert( function( el ) {
	return el.getAttribute( "disabled" ) == null;
} ) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
				( val = elem.getAttributeNode( name ) ) && val.specified ?
					val.value :
					null;
		}
	} );
}

return Sizzle;

} )( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

	return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
	// Strict HTML recognition (trac-11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the primary Deferred
			primary = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						primary.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( primary.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return primary.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
		}

		return primary.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See trac-6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (trac-9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see trac-8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (trac-14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (trac-11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (trac-14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (trac-13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (trac-12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
				dataPriv.get( this, "events" ) || Object.create( null )
			)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (trac-13208)
				// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (trac-13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
						return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
						return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();

						// Support: Chrome 86+
						// In Chrome, if an element having a focusout handler is blurred by
						// clicking outside of it, it invokes the handler synchronously. If
						// that handler calls `.remove()` on the element, the data is cleared,
						// leaving `result` undefined. We need to guard against this.
						return result && result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (trac-504, trac-13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
	which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		// Suppress native focus or blur if we're currently inside
		// a leveraged native-event stack
		_default: function( event ) {
			return dataPriv.get( event.target, type );
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

	rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (trac-8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {

							// Unwrap a CDATA section containing script contents. This shouldn't be
							// needed as in XML documents they're already not visible when
							// inspecting element contents and in HTML documents they have no
							// meaning but we're preserving that logic for backwards compatibility.
							// This will be removed completely in 4.0. See gh-4904.
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var rcustomProp = /^--/;


var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );

var whitespace = "[\\x20\\t\\r\\n\\f]";


var rtrimCSS = new RegExp(
	"^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
	"g"
);




( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (trac-8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		//
		// Support: Firefox 70+
		// Only Firefox includes border widths
		// in computed dimensions. (gh-4529)
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
				tr.style.cssText = "border:1px solid";

				// Support: Chrome 86+
				// Height set through cssText does not get applied.
				// Computed height then comes back as 0.
				tr.style.height = "1px";
				trChild.style.height = "9px";

				// Support: Android 8 Chrome 86+
				// In our bodyBackground.html iframe,
				// display for all div elements is set to "inline",
				// which causes a problem only in Android 8 Chrome 86.
				// Ensuring the div is display: block
				// gets around this issue.
				trChild.style.display = "block";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
					parseInt( trStyle.borderTopWidth, 10 ) +
					parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		isCustomProp = rcustomProp.test( name ),

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, trac-12537)
	//   .css('--customProperty) (gh-3144)
	if ( computed ) {

		// Support: IE <=9 - 11+
		// IE only supports `"float"` in `getPropertyValue`; in computed styles
		// it's only available as `"cssFloat"`. We no longer modify properties
		// sent to `.css()` apart from camelCasing, so we need to check both.
		// Normally, this would create difference in behavior: if
		// `getPropertyValue` returns an empty string, the value returned
		// by `.css()` would be `undefined`. This is usually the case for
		// disconnected elements. However, in IE even disconnected elements
		// with no styles return `"none"` for `getPropertyValue( "float" )`
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( isCustomProp && ret ) {

			// Support: Firefox 105+, Chrome <=105+
			// Spec requires trimming whitespace for custom properties (gh-4926).
			// Firefox only trims leading whitespace. Chrome just collapses
			// both leading & trailing whitespace to a single space.
			//
			// Fall back to `undefined` if empty string returned.
			// This collapses a missing definition with property defined
			// and set to an empty string but there's no standard API
			// allowing us to differentiate them without a performance penalty
			// and returning `undefined` aligns with older jQuery.
			//
			// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
			// as whitespace while CSS does not, but this is not a problem
			// because CSS preprocessing replaces them with U+000A LINE FEED
			// (which *is* CSS whitespace)
			// https://www.w3.org/TR/css-syntax-3/#input-preprocessing
			ret = ret.replace( rtrimCSS, "$1" ) || undefined;
		}

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (trac-7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug trac-9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (trac-7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
					swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, dimension, extra );
					} ) :
					getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
			) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
				jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

				/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
					animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};

		doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// Use proper attribute retrieval (trac-12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];
						if ( cur.indexOf( " " + className + " " ) < 0 ) {
							cur += className + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );

				// This expression is here for better compressibility (see addClass)
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];

						// Remove *all* instances
						while ( cur.indexOf( " " + className + " " ) > -1 ) {
							cur = cur.replace( " " + className + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var classNames, className, i, self,
			type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		classNames = classesToArray( value );

		return this.each( function() {
			if ( isValidValue ) {

				// Toggle individual class names
				self = jQuery( this );

				for ( i = 0; i < classNames.length; i++ ) {
					className = classNames[ i ];

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (trac-14686, trac-14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (trac-2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (trac-9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (trac-6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {

				// Handle: regular nodes (via `this.ownerDocument`), window
				// (via `this.document`) & document (via `this`).
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, parserErrorElem;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {}

	parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
	if ( !xml || parserErrorElem ) {
		jQuery.error( "Invalid XML: " + (
			parserErrorElem ?
				jQuery.map( parserErrorElem.childNodes, function( el ) {
					return el.textContent;
				} ).join( "\n" ) :
				data
		) );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} ).filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} ).map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// trac-7653, trac-8125, trac-8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );

originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes trac-9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (trac-10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket trac-12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// trac-9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script but not if jsonp
			if ( !isSuccess &&
				jQuery.inArray( "script", s.dataTypes ) > -1 &&
				jQuery.inArray( "json", s.dataTypes ) < 0 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (trac-11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// trac-1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see trac-8605, trac-14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// trac-14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( {
		padding: "inner" + name,
		content: type,
		"": "outer" + name
	}, function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );

jQuery.each(
	( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	}
);




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
// Require that the "whitespace run" starts from a non-whitespace
// to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "$1" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (trac-13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );

},{"process":"../../../Users/Oluwanifemi/AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/process/browser.js"}],"node_modules/popper.js/dist/esm/popper.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';
var timeoutDuration = function () {
  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      return 1;
    }
  }
  return 0;
}();
function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}
function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}
var supportsMicroTasks = isBrowser && window.Promise;

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var window = element.ownerDocument.defaultView;
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }
  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;
    case '#document':
      return element.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
    overflow = _getStyleComputedProp.overflow,
    overflowX = _getStyleComputedProp.overflowX,
    overflowY = _getStyleComputedProp.overflowY;
  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }
  return getScrollParent(getParentNode(element));
}

/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */
function getReferenceNode(reference) {
  return reference && reference.referenceNode ? reference.referenceNode : reference;
}
var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE(version) {
  if (version === 11) {
    return isIE11;
  }
  if (version === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }
  var noOffsetParent = isIE(10) ? document.body : null;

  // NOTE: 1 DOM access here
  var offsetParent = element.offsetParent || null;
  // Skip hidden elements which don't have an offsetParent
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }
  var nodeName = offsetParent && offsetParent.nodeName;
  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }

  // .offsetParent will return the closest TH, TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }
  return offsetParent;
}
function isOffsetContainer(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }
  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }
    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }
  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';
  return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);
}
function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
}
function getWindowSizes(document) {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);
  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}
var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}
  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.width;
  var height = sizes.height || element.clientHeight || result.height;
  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');
    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }
  return getClientRect(result);
}
function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);
  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth);

  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop);
    var marginLeft = parseFloat(styles.marginLeft);
    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }
  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }
  return offsets;
}
function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);
  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;
  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };
  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  var parentNode = getParentNode(element);
  if (!parentNode) {
    return false;
  }
  return isFixed(parentNode);
}

/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */

function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }
  return el || document.documentElement;
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  // NOTE: 1 DOM access here

  var boundaries = {
    top: 0,
    left: 0
  };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }
    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
        height = _getWindowSizes.height,
        width = _getWindowSizes.width;
      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  padding = padding || 0;
  var isPaddingNumber = typeof padding === 'number';
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
  return boundaries;
}
function getArea(_ref) {
  var width = _ref.width,
    height = _ref.height;
  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
  if (placement.indexOf('auto') === -1) {
    return placement;
  }
  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };
  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });
  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
      height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });
  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
  var variation = placement.split('-')[1];
  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var window = element.ownerDocument.defaultView;
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
  };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';
  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }
  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));
  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);
      data = fn(data, modifier);
    }
  });
  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }
  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;
  data.positionFixed = this.options.positionFixed;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
      enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);
  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }
  this.disableEventListeners();

  // remove the popper if user explicitly asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}
function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, {
    passive: true
  });
  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, {
    passive: true
  });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;
  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }
  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, {
    position: options.positionFixed ? 'fixed' : 'absolute'
  });
  return options;
}

/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */
function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets,
    popper = _data$offsets.popper,
    reference = _data$offsets.reference;
  var round = Math.round,
    floor = Math.floor;
  var noRound = function noRound(v) {
    return v;
  };
  var referenceWidth = round(reference.width);
  var popperWidth = round(popper.width);
  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf('-') !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;
  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}
var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
    y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };
  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
    top = void 0;
  if (sideA === 'bottom') {
    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
    // and not the bottom of the html element
    if (offsetParent.nodeName === 'HTML') {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    if (offsetParent.nodeName === 'HTML') {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });
  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });
  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  var _data$offsets$arrow;

  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }
  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }
  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
    popper = _data$offsets.popper,
    reference = _data$offsets.reference;
  var isVertical = ['left', 'right'].indexOf(placement) !== -1;
  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjunction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);
  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}
var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }
  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }
  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';
  var flipOrder = [];
  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }
  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }
    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);
    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);
    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;

    // flips variation if reference element overflows boundaries
    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    // flips variation if popper content overflows boundaries
    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);
    var flippedVariation = flippedVariationByRef || flippedVariationByContent;
    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;
      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }
      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }
      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
    popper = _data$offsets.popper,
    reference = _data$offsets.reference;
  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';
  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }
  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }
  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }
    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));
  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
    _data$offsets = data.offsets,
    popper = _data$offsets.popper,
    reference = _data$offsets.reference;
  var basePlacement = placement.split('-')[0];
  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }
  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }
  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself
  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification
  var top = popperStyles.top,
    left = popperStyles.left,
    transform = popperStyles[transformProp];
  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';
  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

  // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed
  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;
  options.boundaries = boundaries;
  var order = options.priority;
  var popper = data.offsets.popper;
  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };
  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });
  data.offsets.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
      reference = _data$offsets.reference,
      popper = _data$offsets.popper;
    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';
    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };
    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }
  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;
  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }
    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }
    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
    popper = _data$offsets.popper,
    reference = _data$offsets.reference;
  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;
  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;
  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);
  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);
  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },
  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },
  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },
  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },
  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },
  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: 'viewport',
    /**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariations: false,
    /**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariationsByContent: false
  },
  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },
  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },
  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },
  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',
  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,
  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,
  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,
  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},
  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},
  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);
    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();
    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }
    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs

  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */

    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */
  }]);

  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */

Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;
var _default = Popper;
exports.default = _default;
},{}],"wp-content/cache/autoptimize/js/autoptimize_3d4b16c409af790573084eb2e2b80897.js":[function(require,module,exports) {
var define;
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e12) { throw _e12; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e13) { didErr = true; err = _e13; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
/*! jQuery Migrate v3.3.2 | (c) OpenJS Foundation and other contributors | jquery.org/license */
"undefined" == typeof jQuery.migrateMute && (jQuery.migrateMute = !0), function (t) {
  "use strict";

  "function" == typeof define && define.amd ? define(["jquery"], function (e) {
    return t(e, window);
  }) : "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) && module.exports ? module.exports = t(require("jquery"), window) : t(jQuery, window);
}(function (s, n) {
  "use strict";

  function e(e) {
    return 0 <= function (e, t) {
      for (var r = /^(\d+)\.(\d+)\.(\d+)/, n = r.exec(e) || [], o = r.exec(t) || [], i = 1; i <= 3; i++) {
        if (+o[i] < +n[i]) return 1;
        if (+n[i] < +o[i]) return -1;
      }
      return 0;
    }(s.fn.jquery, e);
  }
  s.migrateVersion = "3.3.2", n.console && n.console.log && (s && e("3.0.0") || n.console.log("JQMIGRATE: jQuery 3.0.0+ REQUIRED"), s.migrateWarnings && n.console.log("JQMIGRATE: Migrate plugin loaded multiple times"), n.console.log("JQMIGRATE: Migrate is installed" + (s.migrateMute ? "" : " with logging active") + ", version " + s.migrateVersion));
  var r = {};
  function u(e) {
    var t = n.console;
    s.migrateDeduplicateWarnings && r[e] || (r[e] = !0, s.migrateWarnings.push(e), t && t.warn && !s.migrateMute && (t.warn("JQMIGRATE: " + e), s.migrateTrace && t.trace && t.trace()));
  }
  function t(e, t, r, n) {
    Object.defineProperty(e, t, {
      configurable: !0,
      enumerable: !0,
      get: function get() {
        return u(n), r;
      },
      set: function set(e) {
        u(n), r = e;
      }
    });
  }
  function o(e, t, r, n) {
    e[t] = function () {
      return u(n), r.apply(this, arguments);
    };
  }
  s.migrateDeduplicateWarnings = !0, s.migrateWarnings = [], void 0 === s.migrateTrace && (s.migrateTrace = !0), s.migrateReset = function () {
    r = {}, s.migrateWarnings.length = 0;
  }, "BackCompat" === n.document.compatMode && u("jQuery is not compatible with Quirks Mode");
  var i,
    a,
    c,
    d = {},
    l = s.fn.init,
    p = s.find,
    f = /\[(\s*[-\w]+\s*)([~|^$*]?=)\s*([-\w#]*?#[-\w#]*)\s*\]/,
    y = /\[(\s*[-\w]+\s*)([~|^$*]?=)\s*([-\w#]*?#[-\w#]*)\s*\]/g,
    m = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
  for (i in s.fn.init = function (e) {
    var t = Array.prototype.slice.call(arguments);
    return "string" == typeof e && "#" === e && (u("jQuery( '#' ) is not a valid selector"), t[0] = []), l.apply(this, t);
  }, s.fn.init.prototype = s.fn, s.find = function (t) {
    var r = Array.prototype.slice.call(arguments);
    if ("string" == typeof t && f.test(t)) try {
      n.document.querySelector(t);
    } catch (e) {
      t = t.replace(y, function (e, t, r, n) {
        return "[" + t + r + '"' + n + '"]';
      });
      try {
        n.document.querySelector(t), u("Attribute selector with '#' must be quoted: " + r[0]), r[0] = t;
      } catch (e) {
        u("Attribute selector with '#' was not fixed: " + r[0]);
      }
    }
    return p.apply(this, r);
  }, p) Object.prototype.hasOwnProperty.call(p, i) && (s.find[i] = p[i]);
  o(s.fn, "size", function () {
    return this.length;
  }, "jQuery.fn.size() is deprecated and removed; use the .length property"), o(s, "parseJSON", function () {
    return JSON.parse.apply(null, arguments);
  }, "jQuery.parseJSON is deprecated; use JSON.parse"), o(s, "holdReady", s.holdReady, "jQuery.holdReady is deprecated"), o(s, "unique", s.uniqueSort, "jQuery.unique is deprecated; use jQuery.uniqueSort"), t(s.expr, "filters", s.expr.pseudos, "jQuery.expr.filters is deprecated; use jQuery.expr.pseudos"), t(s.expr, ":", s.expr.pseudos, "jQuery.expr[':'] is deprecated; use jQuery.expr.pseudos"), e("3.1.1") && o(s, "trim", function (e) {
    return null == e ? "" : (e + "").replace(m, "");
  }, "jQuery.trim is deprecated; use String.prototype.trim"), e("3.2.0") && (o(s, "nodeName", function (e, t) {
    return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase();
  }, "jQuery.nodeName is deprecated"), o(s, "isArray", Array.isArray, "jQuery.isArray is deprecated; use Array.isArray")), e("3.3.0") && (o(s, "isNumeric", function (e) {
    var t = _typeof(e);
    return ("number" == t || "string" == t) && !isNaN(e - parseFloat(e));
  }, "jQuery.isNumeric() is deprecated"), s.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (e, t) {
    d["[object " + t + "]"] = t.toLowerCase();
  }), o(s, "type", function (e) {
    return null == e ? e + "" : "object" == _typeof(e) || "function" == typeof e ? d[Object.prototype.toString.call(e)] || "object" : _typeof(e);
  }, "jQuery.type is deprecated"), o(s, "isFunction", function (e) {
    return "function" == typeof e;
  }, "jQuery.isFunction() is deprecated"), o(s, "isWindow", function (e) {
    return null != e && e === e.window;
  }, "jQuery.isWindow() is deprecated")), s.ajax && (a = s.ajax, c = /(=)\?(?=&|$)|\?\?/, s.ajax = function () {
    var e = a.apply(this, arguments);
    return e.promise && (o(e, "success", e.done, "jQXHR.success is deprecated and removed"), o(e, "error", e.fail, "jQXHR.error is deprecated and removed"), o(e, "complete", e.always, "jQXHR.complete is deprecated and removed")), e;
  }, e("4.0.0") || s.ajaxPrefilter("+json", function (e) {
    !1 !== e.jsonp && (c.test(e.url) || "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && c.test(e.data)) && u("JSON-to-JSONP auto-promotion is deprecated");
  }));
  var g = s.fn.removeAttr,
    h = s.fn.toggleClass,
    v = /\S+/g;
  function j(e) {
    return e.replace(/-([a-z])/g, function (e, t) {
      return t.toUpperCase();
    });
  }
  s.fn.removeAttr = function (e) {
    var r = this;
    return s.each(e.match(v), function (e, t) {
      s.expr.match.bool.test(t) && (u("jQuery.fn.removeAttr no longer sets boolean properties: " + t), r.prop(t, !1));
    }), g.apply(this, arguments);
  };
  var Q,
    b = !(s.fn.toggleClass = function (t) {
      return void 0 !== t && "boolean" != typeof t ? h.apply(this, arguments) : (u("jQuery.fn.toggleClass( boolean ) is deprecated"), this.each(function () {
        var e = this.getAttribute && this.getAttribute("class") || "";
        e && s.data(this, "__className__", e), this.setAttribute && this.setAttribute("class", !e && !1 !== t && s.data(this, "__className__") || "");
      }));
    }),
    w = /^[a-z]/,
    x = /^(?:Border(?:Top|Right|Bottom|Left)?(?:Width|)|(?:Margin|Padding)?(?:Top|Right|Bottom|Left)?|(?:Min|Max)?(?:Width|Height))$/;
  s.swap && s.each(["height", "width", "reliableMarginRight"], function (e, t) {
    var r = s.cssHooks[t] && s.cssHooks[t].get;
    r && (s.cssHooks[t].get = function () {
      var e;
      return b = !0, e = r.apply(this, arguments), b = !1, e;
    });
  }), s.swap = function (e, t, r, n) {
    var o,
      i,
      a = {};
    for (i in b || u("jQuery.swap() is undocumented and deprecated"), t) a[i] = e.style[i], e.style[i] = t[i];
    for (i in o = r.apply(e, n || []), t) e.style[i] = a[i];
    return o;
  }, e("3.4.0") && "undefined" != typeof Proxy && (s.cssProps = new Proxy(s.cssProps || {}, {
    set: function set() {
      return u("JQMIGRATE: jQuery.cssProps is deprecated"), Reflect.set.apply(this, arguments);
    }
  })), s.cssNumber || (s.cssNumber = {}), Q = s.fn.css, s.fn.css = function (e, t) {
    var r,
      n,
      o = this;
    return e && "object" == _typeof(e) && !Array.isArray(e) ? (s.each(e, function (e, t) {
      s.fn.css.call(o, e, t);
    }), this) : ("number" == typeof t && (r = j(e), n = r, w.test(n) && x.test(n[0].toUpperCase() + n.slice(1)) || s.cssNumber[r] || u('Number-typed values are deprecated for jQuery.fn.css( "' + e + '", value )')), Q.apply(this, arguments));
  };
  var A,
    k,
    S,
    M,
    N = s.data;
  s.data = function (e, t, r) {
    var n, o, i;
    if (t && "object" == _typeof(t) && 2 === arguments.length) {
      for (i in n = s.hasData(e) && N.call(this, e), o = {}, t) i !== j(i) ? (u("jQuery.data() always sets/gets camelCased names: " + i), n[i] = t[i]) : o[i] = t[i];
      return N.call(this, e, o), t;
    }
    return t && "string" == typeof t && t !== j(t) && (n = s.hasData(e) && N.call(this, e)) && t in n ? (u("jQuery.data() always sets/gets camelCased names: " + t), 2 < arguments.length && (n[t] = r), n[t]) : N.apply(this, arguments);
  }, s.fx && (S = s.Tween.prototype.run, M = function M(e) {
    return e;
  }, s.Tween.prototype.run = function () {
    1 < s.easing[this.easing].length && (u("'jQuery.easing." + this.easing.toString() + "' should use only one argument"), s.easing[this.easing] = M), S.apply(this, arguments);
  }, A = s.fx.interval || 13, k = "jQuery.fx.interval is deprecated", n.requestAnimationFrame && Object.defineProperty(s.fx, "interval", {
    configurable: !0,
    enumerable: !0,
    get: function get() {
      return n.document.hidden || u(k), A;
    },
    set: function set(e) {
      u(k), A = e;
    }
  }));
  var R = s.fn.load,
    H = s.event.add,
    C = s.event.fix;
  s.event.props = [], s.event.fixHooks = {}, t(s.event.props, "concat", s.event.props.concat, "jQuery.event.props.concat() is deprecated and removed"), s.event.fix = function (e) {
    var t,
      r = e.type,
      n = this.fixHooks[r],
      o = s.event.props;
    if (o.length) {
      u("jQuery.event.props are deprecated and removed: " + o.join());
      while (o.length) s.event.addProp(o.pop());
    }
    if (n && !n._migrated_ && (n._migrated_ = !0, u("jQuery.event.fixHooks are deprecated and removed: " + r), (o = n.props) && o.length)) while (o.length) s.event.addProp(o.pop());
    return t = C.call(this, e), n && n.filter ? n.filter(t, e) : t;
  }, s.event.add = function (e, t) {
    return e === n && "load" === t && "complete" === n.document.readyState && u("jQuery(window).on('load'...) called after load event occurred"), H.apply(this, arguments);
  }, s.each(["load", "unload", "error"], function (e, t) {
    s.fn[t] = function () {
      var e = Array.prototype.slice.call(arguments, 0);
      return "load" === t && "string" == typeof e[0] ? R.apply(this, e) : (u("jQuery.fn." + t + "() is deprecated"), e.splice(0, 0, t), arguments.length ? this.on.apply(this, e) : (this.triggerHandler.apply(this, e), this));
    };
  }), s.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function (e, r) {
    s.fn[r] = function (e, t) {
      return u("jQuery.fn." + r + "() event shorthand is deprecated"), 0 < arguments.length ? this.on(r, null, e, t) : this.trigger(r);
    };
  }), s(function () {
    s(n.document).triggerHandler("ready");
  }), s.event.special.ready = {
    setup: function setup() {
      this === n.document && u("'ready' event is deprecated");
    }
  }, s.fn.extend({
    bind: function bind(e, t, r) {
      return u("jQuery.fn.bind() is deprecated"), this.on(e, null, t, r);
    },
    unbind: function unbind(e, t) {
      return u("jQuery.fn.unbind() is deprecated"), this.off(e, null, t);
    },
    delegate: function delegate(e, t, r, n) {
      return u("jQuery.fn.delegate() is deprecated"), this.on(t, e, r, n);
    },
    undelegate: function undelegate(e, t, r) {
      return u("jQuery.fn.undelegate() is deprecated"), 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", r);
    },
    hover: function hover(e, t) {
      return u("jQuery.fn.hover() is deprecated"), this.on("mouseenter", e).on("mouseleave", t || e);
    }
  });
  function T(e) {
    var t = n.document.implementation.createHTMLDocument("");
    return t.body.innerHTML = e, t.body && t.body.innerHTML;
  }
  function P(e) {
    var t = e.replace(O, "<$1></$2>");
    t !== e && T(e) !== T(t) && u("HTML tags must be properly nested and closed: " + e);
  }
  var O = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
    q = s.htmlPrefilter;
  s.UNSAFE_restoreLegacyHtmlPrefilter = function () {
    s.htmlPrefilter = function (e) {
      return P(e), e.replace(O, "<$1></$2>");
    };
  }, s.htmlPrefilter = function (e) {
    return P(e), q(e);
  };
  var D,
    _ = s.fn.offset;
  s.fn.offset = function () {
    var e = this[0];
    return !e || e.nodeType && e.getBoundingClientRect ? _.apply(this, arguments) : (u("jQuery.fn.offset() requires a valid DOM element"), arguments.length ? this : void 0);
  }, s.ajax && (D = s.param, s.param = function (e, t) {
    var r = s.ajaxSettings && s.ajaxSettings.traditional;
    return void 0 === t && r && (u("jQuery.param() no longer uses jQuery.ajaxSettings.traditional"), t = r), D.call(this, e, t);
  });
  var E,
    F,
    J = s.fn.andSelf || s.fn.addBack;
  return s.fn.andSelf = function () {
    return u("jQuery.fn.andSelf() is deprecated and removed, use jQuery.fn.addBack()"), J.apply(this, arguments);
  }, s.Deferred && (E = s.Deferred, F = [["resolve", "done", s.Callbacks("once memory"), s.Callbacks("once memory"), "resolved"], ["reject", "fail", s.Callbacks("once memory"), s.Callbacks("once memory"), "rejected"], ["notify", "progress", s.Callbacks("memory"), s.Callbacks("memory")]], s.Deferred = function (e) {
    var i = E(),
      a = i.promise();
    return i.pipe = a.pipe = function () {
      var o = arguments;
      return u("deferred.pipe() is deprecated"), s.Deferred(function (n) {
        s.each(F, function (e, t) {
          var r = "function" == typeof o[e] && o[e];
          i[t[1]](function () {
            var e = r && r.apply(this, arguments);
            e && "function" == typeof e.promise ? e.promise().done(n.resolve).fail(n.reject).progress(n.notify) : n[t[0] + "With"](this === a ? n.promise() : this, r ? [e] : arguments);
          });
        }), o = null;
      }).promise();
    }, e && e.call(i, i), i;
  }, s.Deferred.exceptionHook = E.exceptionHook), s;
});
(function ($) {
  "use strict";
})(jQuery);
(function ($) {
  var WidgetCTIlineHandler = function WidgetCTIlineHandler($scope, $) {
    var _inline_css = "<style>";
    $scope.find('.ct-inline-css').each(function () {
      var _this = $(this);
      _inline_css += _this.attr("data-css") + " ";
      _this.remove();
    });
    _inline_css += "</style>";
    $('head').append(_inline_css);
  };
  $(window).on('elementor/frontend/init', function () {
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_text_editor.default', WidgetCTIlineHandler);
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_angle.default', WidgetCTIlineHandler);
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_fancy_box.default', WidgetCTIlineHandler);
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_fancy_box_grid.default', WidgetCTIlineHandler);
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_newsletter.default', WidgetCTIlineHandler);
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_mailchimp_form.default', WidgetCTIlineHandler);
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_service_grid.default', WidgetCTIlineHandler);
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_particle_animate.default', WidgetCTIlineHandler);
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_statistics.default', WidgetCTIlineHandler);
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_point.default', WidgetCTIlineHandler);
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_contact_info.default', WidgetCTIlineHandler);
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_counter.default', WidgetCTIlineHandler);
  });
})(jQuery);
var wpa_field_name, wpa_unique_id, wpa_add_test, wpa_hidden_field;
jQuery(document).ready(function () {
  jQuery.ajax({
    url: wpa_admin_ajax_url,
    data: {
      'action': 'wpa_field_info'
    },
    type: 'GET',
    success: function success(response) {
      returnData = JSON.parse(response);
      wpa_field_name = returnData.wpa_field_name;
      wpa_unique_id = returnData.wpa_field_value;
      wpa_add_test = returnData.wpa_add_test;
      wpa_hidden_field = "<span class='wpa_hidden_field' style='display:none;height:0;width:0;'><input type='text' name='" + wpa_field_name + "' value='" + wpa_unique_id + "' /></span>";
      wpa_add_honeypot_field();
      if (typeof wpae_add_honeypot_field == 'function') {
        wpae_add_honeypot_field();
      }
      if (wpa_add_test == 'yes') {
        wpa_add_test_block();
      }
    },
    error: function error(response) {
      if (console && console.error) {
        console.error('Unable to add WP Armour Anti Spam protection.');
      }
    }
  });
});
function wpa_act_as_spam() {
  actiontype = jQuery('span.wpa-button').data('actiontype');
  if (actiontype == 'remove') {
    wpa_remove_honeypot_field();
    jQuery('span.wpa-button').data('actiontype', 'add');
    jQuery('span.wpa-button').html('Acting as Spam Bot');
  } else {
    wpa_add_honeypot_field();
    jQuery('span.wpa-button').data('actiontype', 'remove');
    jQuery('span.wpa-button').html('Act as Spam Bot');
  }
}
function wpa_add_honeypot_field() {
  jQuery('.bbp-topic-form form').append(wpa_hidden_field);
  jQuery('.bbp-reply-form form').append(wpa_hidden_field);
  jQuery('form#commentform').append(wpa_hidden_field);
  jQuery('form.wpcf7-form').append(wpa_hidden_field);
  jQuery('form.wpforms-form').append(wpa_hidden_field);
  jQuery('.gform_wrapper form').append(wpa_hidden_field);
  jQuery('.frm_forms form').append(wpa_hidden_field);
  jQuery('.caldera-grid form').append(wpa_hidden_field);
  jQuery('.wp-block-toolset-cred-form form').append(wpa_hidden_field);
  jQuery('form.et_pb_contact_form').append(wpa_hidden_field);
  jQuery('form.elementor-form').append(wpa_hidden_field);
  jQuery('form.form-contribution').append(wpa_hidden_field);
  jQuery('form.frm-fluent-form').append(wpa_hidden_field);
  jQuery('.ff_conv_app').append(wpa_hidden_field);
  if (typeof fluent_forms_global_var_1 !== 'undefined') {
    fluent_forms_global_var_1.extra_inputs[wpa_field_name] = wpa_unique_id;
  }
  jQuery(wpa_hidden_field).insertAfter('input.wpa_initiator');
}
function wpa_add_test_block() {
  checkingTest = '<div class="wpa-test-msg"><strong>WP Armour ( Only visible to site administrators. Not visible to other users. )</strong><br />This form has a honeypot trap enabled. If you want to act as spam bot for testing purposes, please click the button below.<br/><span class="wpa-button" onclick="wpa_act_as_spam()" data-actiontype="remove">Act as Spam Bot</span></div>';
  jQuery('.wpa-test-msg').remove();
  jQuery('span.wpa_hidden_field').after(checkingTest);
}
function wpa_remove_honeypot_field() {
  jQuery('.wpa_hidden_field').remove();
  if (typeof fluent_forms_global_var_1 !== 'undefined') {
    delete fluent_forms_global_var_1.extra_inputs[wpa_field_name];
  }
}
;
!function (t) {
  var e = {};
  function n(r) {
    if (e[r]) return e[r].exports;
    var i = e[r] = {
      i: r,
      l: !1,
      exports: {}
    };
    return t[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports;
  }
  n.m = t, n.c = e, n.d = function (t, e, r) {
    n.o(t, e) || Object.defineProperty(t, e, {
      enumerable: !0,
      get: r
    });
  }, n.r = function (t) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(t, "__esModule", {
      value: !0
    });
  }, n.t = function (t, e) {
    if (1 & e && (t = n(t)), 8 & e) return t;
    if (4 & e && "object" == _typeof(t) && t && t.__esModule) return t;
    var r = Object.create(null);
    if (n.r(r), Object.defineProperty(r, "default", {
      enumerable: !0,
      value: t
    }), 2 & e && "string" != typeof t) for (var i in t) n.d(r, i, function (e) {
      return t[e];
    }.bind(null, i));
    return r;
  }, n.n = function (t) {
    var e = t && t.__esModule ? function () {
      return t.default;
    } : function () {
      return t;
    };
    return n.d(e, "a", e), e;
  }, n.o = function (t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }, n.p = "", n(n.s = 1);
}([function (t, e) {
  t.exports = jQuery;
}, function (t, e, n) {
  n(2), n(6), t.exports = n(4);
}, function (t, e, n) {
  var r, i, u, s;
  /*!
   * @fileOverview TouchSwipe - jQuery Plugin @version 1.6.18 / SANDBOXED VERSION FOR TP
   * @author Matt Bryson http://www.github.com/mattbryson
   * @see https://github.com/mattbryson/TouchSwipe-Jquery-Plugin
   * @see http://labs.rampinteractive.co.uk/touchSwipe/
   * @see http://plugins.jquery.com/project/touchSwipe
   * @license
   * Copyright (c) 2010-2015 Matt Bryson
   * Dual licensed under the MIT or GPL Version 2 licenses.
   *
   */
  s = function s(t) {
    "use strict";

    var e = "left",
      n = "right",
      r = "up",
      i = "down",
      u = "none",
      s = "doubletap",
      o = "longtap",
      a = "horizontal",
      l = "vertical",
      h = "all",
      f = "move",
      D = "end",
      p = "cancel",
      c = ("ontouchstart" in window),
      d = window.navigator.msPointerEnabled && !window.PointerEvent && !c,
      g = (window.PointerEvent || window.navigator.msPointerEnabled) && !c,
      _ = "TouchSwipe";
    function m(m, v) {
      v = t.extend({}, v);
      var y = c || g || !v.fallbackToMouseEvents,
        C = y ? g ? d ? "MSPointerDown" : "pointerdown" : "touchstart" : "mousedown",
        x = y ? g ? d ? "MSPointerMove" : "pointermove" : "touchmove" : "mousemove",
        F = y ? g ? d ? "MSPointerUp" : "pointerup" : "touchend" : "mouseup",
        w = y ? g ? "mouseleave" : null : "mouseleave",
        E = g ? d ? "MSPointerCancel" : "pointercancel" : "touchcancel",
        b = 0,
        T = null,
        A = null,
        M = 0,
        O = 0,
        S = 0,
        P = 1,
        B = 0,
        k = 0,
        L = null,
        N = t(m),
        R = "start",
        I = 0,
        z = {},
        Y = 0,
        X = 0,
        j = 0,
        V = 0,
        U = 0,
        W = null,
        q = null;
      try {
        N.on(C, G), N.on(E, K);
      } catch (m) {
        t.error("events not supported " + C + "," + E + " on jQuery.swipe");
      }
      function G(u) {
        if (!0 !== N.data(_ + "_intouch") && !(0 < t(u.target).closest(v.excludedElements, N).length)) {
          var s = u.originalEvent ? u.originalEvent : u;
          if (!s.pointerType || "mouse" != s.pointerType || 0 != v.fallbackToMouseEvents) {
            var o,
              a,
              l = s.touches,
              f = l ? l[0] : s;
            return R = "start", l ? I = l.length : !1 !== v.preventDefaultEvents && u.preventDefault(), k = A = T = null, P = 1, B = S = O = M = b = 0, (a = {})[e] = yt(e), a[n] = yt(n), a.up = yt(r), a[i] = yt(i), L = a, ct(), _t(0, f), !l || I === v.fingers || v.fingers === h || st() ? (Y = wt(), 2 == I && (_t(1, l[1]), O = S = xt(z[0].start, z[1].start)), (v.swipeStatus || v.pinchStatus) && (o = tt(s, R))) : o = !1, !1 === o ? (tt(s, R = p), o) : (v.hold && (q = setTimeout(t.proxy(function () {
              N.trigger("hold", [s.target]), v.hold && (o = v.hold.call(N, s, s.target));
            }, this), v.longTapThreshold)), gt(!0), null);
          }
        }
      }
      function H(s) {
        var o = s.originalEvent ? s.originalEvent : s;
        if (R !== D && R !== p && !dt()) {
          var c,
            d,
            g,
            _,
            m,
            y,
            C,
            x = o.touches,
            F = mt(x ? x[0] : o);
          if (X = wt(), x && (I = x.length), v.hold && clearTimeout(q), R = f, 2 == I && (0 == O ? (_t(1, x[1]), O = S = xt(z[0].start, z[1].start)) : (mt(x[1]), S = xt(z[0].end, z[1].end), z[0].end, z[1].end, k = P < 1 ? "out" : "in"), P = (S / O * 1).toFixed(2), B = Math.abs(O - S)), I === v.fingers || v.fingers === h || !x || st()) {
            if (T = Ft(F.start, F.end), function (t, s) {
              if (!1 !== v.preventDefaultEvents) if (v.allowPageScroll === u) t.preventDefault();else {
                var o = "auto" === v.allowPageScroll;
                switch (s) {
                  case e:
                    (v.swipeLeft && o || !o && v.allowPageScroll != a) && t.preventDefault();
                    break;
                  case n:
                    (v.swipeRight && o || !o && v.allowPageScroll != a) && t.preventDefault();
                    break;
                  case r:
                    (v.swipeUp && o || !o && v.allowPageScroll != l) && t.preventDefault();
                    break;
                  case i:
                    (v.swipeDown && o || !o && v.allowPageScroll != l) && t.preventDefault();
                }
              }
            }(s, A = Ft(F.last, F.end)), y = F.start, C = F.end, b = Math.round(Math.sqrt(Math.pow(C.x - y.x, 2) + Math.pow(C.y - y.y, 2))), M = Ct(), function (t, e) {
              t != u && (e = Math.max(e, vt(t)), L[t].distance = e);
            }(T, b), c = tt(o, R), !v.triggerOnTouchEnd || v.triggerOnTouchLeave) {
              var w = !0;
              v.triggerOnTouchLeave && (g = {
                left: (m = (_ = t(_ = this)).offset()).left,
                right: m.left + _.outerWidth(),
                top: m.top,
                bottom: m.top + _.outerHeight()
              }, w = (d = F.end).x > g.left && d.x < g.right && d.y > g.top && d.y < g.bottom), !v.triggerOnTouchEnd && w ? R = J(f) : v.triggerOnTouchLeave && !w && (R = J(D)), R != p && R != D || tt(o, R);
            }
          } else tt(o, R = p);
          !1 === c && tt(o, R = p);
        }
      }
      function Q(t) {
        var e,
          n = t.originalEvent ? t.originalEvent : t,
          r = n.touches;
        if (r) {
          if (r.length && !dt()) return e = n, j = wt(), V = e.touches.length + 1, !0;
          if (r.length && dt()) return !0;
        }
        return dt() && (I = V), X = wt(), M = Ct(), rt() || !nt() ? tt(n, R = p) : v.triggerOnTouchEnd || !1 === v.triggerOnTouchEnd && R === f ? (!1 !== v.preventDefaultEvents && !1 !== t.cancelable && t.preventDefault(), tt(n, R = D)) : !v.triggerOnTouchEnd && ft() ? et(n, R = D, "tap") : R === f && tt(n, R = p), gt(!1), null;
      }
      function K() {
        S = O = Y = X = I = 0, P = 1, ct(), gt(!1);
      }
      function Z(t) {
        var e = t.originalEvent ? t.originalEvent : t;
        v.triggerOnTouchLeave && tt(e, R = J(D));
      }
      function $() {
        N.off(C, G), N.off(E, K), N.off(x, H), N.off(F, Q), w && N.off(w, Z), gt(!1);
      }
      function J(t) {
        var e = t,
          n = it(),
          r = nt(),
          i = rt();
        return !n || i ? e = p : !r || t != f || v.triggerOnTouchEnd && !v.triggerOnTouchLeave ? !r && t == D && v.triggerOnTouchLeave && (e = p) : e = D, e;
      }
      function tt(t, e) {
        var n,
          r = t.touches;
        return (ot() && at() || at()) && (n = et(t, e, "swipe")), (ut() && st() || st()) && !1 !== n && (n = et(t, e, "pinch")), pt() && Dt() && !1 !== n ? n = et(t, e, s) : M > v.longTapThreshold && b < 10 && v.longTap && !1 !== n ? n = et(t, e, o) : 1 !== I && c || !(isNaN(b) || b < v.threshold) || !ft() || !1 === n || (n = et(t, e, "tap")), e === p && K(), e === D && (r && r.length || K()), n;
      }
      function et(u, a, l) {
        var h;
        if ("swipe" == l) {
          if (N.trigger("swipeStatus", [a, T || null, b || 0, M || 0, I, z, A]), v.swipeStatus && !1 === (h = v.swipeStatus.call(N, u, a, T || null, b || 0, M || 0, I, z, A))) return !1;
          if (a == D && ot()) {
            if (clearTimeout(W), clearTimeout(q), N.trigger("swipe", [T, b, M, I, z, A]), v.swipe && !1 === (h = v.swipe.call(N, u, T, b, M, I, z, A))) return !1;
            switch (T) {
              case e:
                N.trigger("swipeLeft", [T, b, M, I, z, A]), v.swipeLeft && (h = v.swipeLeft.call(N, u, T, b, M, I, z, A));
                break;
              case n:
                N.trigger("swipeRight", [T, b, M, I, z, A]), v.swipeRight && (h = v.swipeRight.call(N, u, T, b, M, I, z, A));
                break;
              case r:
                N.trigger("swipeUp", [T, b, M, I, z, A]), v.swipeUp && (h = v.swipeUp.call(N, u, T, b, M, I, z, A));
                break;
              case i:
                N.trigger("swipeDown", [T, b, M, I, z, A]), v.swipeDown && (h = v.swipeDown.call(N, u, T, b, M, I, z, A));
            }
          }
        }
        if ("pinch" == l) {
          if (N.trigger("pinchStatus", [a, k || null, B || 0, M || 0, I, P, z]), v.pinchStatus && !1 === (h = v.pinchStatus.call(N, u, a, k || null, B || 0, M || 0, I, P, z))) return !1;
          if (a == D && ut()) switch (k) {
            case "in":
              N.trigger("pinchIn", [k || null, B || 0, M || 0, I, P, z]), v.pinchIn && (h = v.pinchIn.call(N, u, k || null, B || 0, M || 0, I, P, z));
              break;
            case "out":
              N.trigger("pinchOut", [k || null, B || 0, M || 0, I, P, z]), v.pinchOut && (h = v.pinchOut.call(N, u, k || null, B || 0, M || 0, I, P, z));
          }
        }
        return "tap" == l ? a !== p && a !== D || (clearTimeout(W), clearTimeout(q), Dt() && !pt() ? (U = wt(), W = setTimeout(t.proxy(function () {
          U = null, N.trigger("tap", [u.target]), v.tap && (h = v.tap.call(N, u, u.target));
        }, this), v.doubleTapThreshold)) : (U = null, N.trigger("tap", [u.target]), v.tap && (h = v.tap.call(N, u, u.target)))) : l == s ? a !== p && a !== D || (clearTimeout(W), clearTimeout(q), U = null, N.trigger("doubletap", [u.target]), v.doubleTap && (h = v.doubleTap.call(N, u, u.target))) : l == o && (a !== p && a !== D || (clearTimeout(W), U = null, N.trigger("longtap", [u.target]), v.longTap && (h = v.longTap.call(N, u, u.target)))), h;
      }
      function nt() {
        var t = !0;
        return null !== v.threshold && (t = b >= v.threshold), t;
      }
      function rt() {
        var t = !1;
        return null !== v.cancelThreshold && null !== T && (t = vt(T) - b >= v.cancelThreshold), t;
      }
      function it() {
        return !(v.maxTimeThreshold && M >= v.maxTimeThreshold);
      }
      function ut() {
        var t = lt(),
          e = ht(),
          n = null === v.pinchThreshold || B >= v.pinchThreshold;
        return t && e && n;
      }
      function st() {
        return v.pinchStatus || v.pinchIn || v.pinchOut;
      }
      function ot() {
        var t = it(),
          e = nt(),
          n = lt(),
          r = ht();
        return !rt() && r && n && e && t;
      }
      function at() {
        return v.swipe || v.swipeStatus || v.swipeLeft || v.swipeRight || v.swipeUp || v.swipeDown;
      }
      function lt() {
        return I === v.fingers || v.fingers === h || !c;
      }
      function ht() {
        return 0 !== z[0].end.x;
      }
      function ft() {
        return v.tap;
      }
      function Dt() {
        return !!v.doubleTap;
      }
      function pt() {
        if (null == U) return !1;
        var t = wt();
        return Dt() && t - U <= v.doubleTapThreshold;
      }
      function ct() {
        V = j = 0;
      }
      function dt() {
        var t = !1;
        return j && wt() - j <= v.fingerReleaseThreshold && (t = !0), t;
      }
      function gt(t) {
        N && (!0 === t ? (N.on(x, H), N.on(F, Q), w && N.on(w, Z)) : (N.off(x, H, !1), N.off(F, Q, !1), w && N.off(w, Z, !1)), N.data(_ + "_intouch", !0 === t));
      }
      function _t(t, e) {
        var n = {
          start: {
            x: 0,
            y: 0
          },
          last: {
            x: 0,
            y: 0
          },
          end: {
            x: 0,
            y: 0
          }
        };
        return n.start.x = n.last.x = n.end.x = e.pageX || e.clientX, n.start.y = n.last.y = n.end.y = e.pageY || e.clientY, z[t] = n;
      }
      function mt(t) {
        var e = void 0 !== t.identifier ? t.identifier : 0,
          n = z[e] || null;
        return null === n && (n = _t(e, t)), n.last.x = n.end.x, n.last.y = n.end.y, n.end.x = t.pageX || t.clientX, n.end.y = t.pageY || t.clientY, n;
      }
      function vt(t) {
        if (L[t]) return L[t].distance;
      }
      function yt(t) {
        return {
          direction: t,
          distance: 0
        };
      }
      function Ct() {
        return X - Y;
      }
      function xt(t, e) {
        var n = Math.abs(t.x - e.x),
          r = Math.abs(t.y - e.y);
        return Math.round(Math.sqrt(n * n + r * r));
      }
      function Ft(t, s) {
        if (a = s, (o = t).x == a.x && o.y == a.y) return u;
        var o,
          a,
          l,
          h,
          f,
          D,
          p,
          c,
          d = (h = s, f = (l = t).x - h.x, D = h.y - l.y, p = Math.atan2(D, f), (c = Math.round(180 * p / Math.PI)) < 0 && (c = 360 - Math.abs(c)), c);
        return d <= 45 && 0 <= d || d <= 360 && 315 <= d ? e : 135 <= d && d <= 225 ? n : 45 < d && d < 135 ? i : r;
      }
      function wt() {
        return new Date().getTime();
      }
      this.enable = function () {
        return this.disable(), N.on(C, G), N.on(E, K), N;
      }, this.disable = function () {
        return $(), N;
      }, this.destroy = function () {
        $(), N.data(_, null), N = null;
      }, this.option = function (e, n) {
        if ("object" == _typeof(e)) v = t.extend(v, e);else if (void 0 !== v[e]) {
          if (void 0 === n) return v[e];
          v[e] = n;
        } else {
          if (!e) return v;
          t.error("Option " + e + " does not exist on jQuery.swipe.options");
        }
        return null;
      };
    }
    t.fn.rsswipe = function (e) {
      var n = t(this),
        r = n.data(_);
      if (r && "string" == typeof e) {
        if (r[e]) return r[e].apply(r, Array.prototype.slice.call(arguments, 1));
        t.error("Method " + e + " does not exist on jQuery.rsswipe");
      } else if (r && "object" == _typeof(e)) r.option.apply(r, arguments);else if (!(r || "object" != _typeof(e) && e)) return function (e) {
        return !e || void 0 !== e.allowPageScroll || void 0 === e.swipe && void 0 === e.swipeStatus || (e.allowPageScroll = u), void 0 !== e.click && void 0 === e.tap && (e.tap = e.click), e = e || {}, e = t.extend({}, t.fn.rsswipe.defaults, e), this.each(function () {
          var n = t(this),
            r = n.data(_);
          r || (r = new m(this, e), n.data(_, r));
        });
      }.apply(this, arguments);
      return n;
    }, t.fn.rsswipe.version = "1.6.18", t.fn.rsswipe.defaults = {
      fingers: 1,
      threshold: 75,
      cancelThreshold: null,
      pinchThreshold: 20,
      maxTimeThreshold: null,
      fingerReleaseThreshold: 250,
      longTapThreshold: 500,
      doubleTapThreshold: 200,
      swipe: null,
      swipeLeft: null,
      swipeRight: null,
      swipeUp: null,
      swipeDown: null,
      swipeStatus: null,
      pinchIn: null,
      pinchOut: null,
      pinchStatus: null,
      click: null,
      tap: null,
      doubleTap: null,
      longTap: null,
      hold: null,
      triggerOnTouchEnd: !0,
      triggerOnTouchLeave: !1,
      allowPageScroll: "auto",
      fallbackToMouseEvents: !0,
      excludedElements: ".noSwipe",
      preventDefaultEvents: !0
    }, t.fn.rsswipe.phases = {
      PHASE_START: "start",
      PHASE_MOVE: f,
      PHASE_END: D,
      PHASE_CANCEL: p
    }, t.fn.rsswipe.directions = {
      LEFT: e,
      RIGHT: n,
      UP: r,
      DOWN: i,
      IN: "in",
      OUT: "out"
    }, t.fn.rsswipe.pageScroll = {
      NONE: u,
      HORIZONTAL: a,
      VERTICAL: l,
      AUTO: "auto"
    }, t.fn.rsswipe.fingers = {
      ONE: 1,
      TWO: 2,
      THREE: 3,
      FOUR: 4,
      FIVE: 5,
      ALL: h
    };
  }, n(3).jQuery ? (i = [n(0)], void 0 === (u = "function" == typeof (r = s) ? r.apply(e, i) : r) || (t.exports = u)) : t.exports ? s(n(0)) : s(jQuery);
}, function (t, e) {
  (function (e) {
    t.exports = e;
  }).call(this, {});
}, function (t, e) {
  var n;
  (n = jQuery).waitForImages = {
    hasImageProperties: ["backgroundImage", "listStyleImage", "borderImage", "borderCornerImage"]
  }, n.expr.pseudos.uncached = function (t) {
    var e = document.createElement("img");
    return e.src = t.src, n(t).is('img[src!=""]') && !e.complete;
  }, n.fn.waitForImages = function (t, e, r) {
    if (n.isPlainObject(t) && (e = t.each, r = t.waitForAll, t = t.finished), t = t || n.noop, e = e || n.noop, r = !!r, !n.isFunction(t) || !n.isFunction(e)) throw new TypeError("An invalid callback was supplied.");
    return this.each(function () {
      var i = n(this),
        u = [];
      if (r) {
        var s = n.waitForImages.hasImageProperties || [],
          o = /url\((['"]?)(.*?)\1\)/g;
        i.find("*").each(function () {
          var t = n(this);
          t.is("img:uncached") && u.push({
            src: t.attr("src"),
            element: t[0]
          }), n.each(s, function (e, n) {
            var r,
              i = t.css(n);
            if (!i) return !0;
            for (; r = o.exec(i);) u.push({
              src: r[2],
              element: t[0]
            });
          });
        });
      } else i.find("img:uncached").each(function () {
        u.push({
          src: this.src,
          element: this
        });
      });
      var a = u.length,
        l = 0;
      0 == a && t.call(i[0]), n.each(u, function (r, u) {
        var s = new Image();
        n(s).bind("load error", function (n) {
          if (l++, e.call(u.element, l, a, "load" == n.type), l == a) return t.call(i[0]), !1;
        }), s.src = u.src;
      });
    });
  };
},, function (t, e, n) {
  "use strict";

  function r(t) {
    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t;
  }
  function i(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
  }
  /*!
   * GSAP 3.5.1
   * https://greensock.com
   *
   * @license Copyright 2008-2020, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  n.r(e);
  var u,
    s,
    o,
    a,
    l,
    h,
    f,
    D,
    p,
    c,
    d,
    g,
    _,
    m,
    v,
    y,
    C,
    x,
    F,
    w,
    E,
    b,
    T,
    A,
    M,
    O,
    S,
    P = {
      autoSleep: 120,
      force3D: "auto",
      nullTargetWarn: 1,
      units: {
        lineHeight: ""
      }
    },
    B = {
      duration: .5,
      overwrite: !1,
      delay: 0
    },
    k = 1e8,
    L = 2 * Math.PI,
    N = L / 4,
    R = 0,
    I = Math.sqrt,
    z = Math.cos,
    Y = Math.sin,
    X = function X(t) {
      return "string" == typeof t;
    },
    j = function j(t) {
      return "function" == typeof t;
    },
    V = function V(t) {
      return "number" == typeof t;
    },
    U = function U(t) {
      return void 0 === t;
    },
    W = function W(t) {
      return "object" == _typeof(t);
    },
    q = function q(t) {
      return !1 !== t;
    },
    G = function G() {
      return "undefined" != typeof window;
    },
    H = function H(t) {
      return j(t) || X(t);
    },
    Q = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function () {},
    K = Array.isArray,
    Z = /(?:-?\.?\d|\.)+/gi,
    $ = /[-+=.]*\d+[.e\-+]*\d*[e\-\+]*\d*/g,
    J = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    tt = /[-+=.]*\d+(?:\.|e-|e)*\d*/gi,
    et = /[+-]=-?[\.\d]+/,
    nt = /[#\-+.]*\b[a-z\d-=+%.]+/gi,
    rt = {},
    it = {},
    ut = function ut(t) {
      return (it = St(t, rt)) && cn;
    },
    st = function st(t, e) {
      return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()");
    },
    ot = function ot(t, e) {
      return !e && console.warn(t);
    },
    at = function at(t, e) {
      return t && (rt[t] = e) && it && (it[t] = e) || rt;
    },
    lt = function lt() {
      return 0;
    },
    ht = {},
    ft = [],
    Dt = {},
    pt = {},
    ct = {},
    dt = 30,
    gt = [],
    _t = "",
    mt = function mt(t) {
      var e,
        n,
        r = t[0];
      if (W(r) || j(r) || (t = [t]), !(e = (r._gsap || {}).harness)) {
        for (n = gt.length; n-- && !gt[n].targetTest(r););
        e = gt[n];
      }
      for (n = t.length; n--;) t[n] && (t[n]._gsap || (t[n]._gsap = new Ie(t[n], e))) || t.splice(n, 1);
      return t;
    },
    vt = function vt(t) {
      return t._gsap || mt(ie(t))[0]._gsap;
    },
    yt = function yt(t, e, n) {
      return (n = t[e]) && j(n) ? t[e]() : U(n) && t.getAttribute && t.getAttribute(e) || n;
    },
    Ct = function Ct(t, e) {
      return (t = t.split(",")).forEach(e) || t;
    },
    xt = function xt(t) {
      return Math.round(1e5 * t) / 1e5 || 0;
    },
    Ft = function Ft(t, e) {
      for (var n = e.length, r = 0; t.indexOf(e[r]) < 0 && ++r < n;);
      return r < n;
    },
    wt = function wt(t, e, n) {
      var r,
        i = V(t[1]),
        u = (i ? 2 : 1) + (e < 2 ? 0 : 1),
        s = t[u];
      if (i && (s.duration = t[1]), s.parent = n, e) {
        for (r = s; n && !("immediateRender" in r);) r = n.vars.defaults || {}, n = q(n.vars.inherit) && n.parent;
        s.immediateRender = q(r.immediateRender), e < 2 ? s.runBackwards = 1 : s.startAt = t[u - 1];
      }
      return s;
    },
    Et = function Et() {
      var t,
        e,
        n = ft.length,
        r = ft.slice(0);
      for (Dt = {}, ft.length = 0, t = 0; t < n; t++) (e = r[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0);
    },
    bt = function bt(t, e, n, r) {
      ft.length && Et(), t.render(e, n, r), ft.length && Et();
    },
    Tt = function Tt(t) {
      var e = parseFloat(t);
      return (e || 0 === e) && (t + "").match(nt).length < 2 ? e : X(t) ? t.trim() : t;
    },
    At = function At(t) {
      return t;
    },
    Mt = function Mt(t, e) {
      for (var n in e) n in t || (t[n] = e[n]);
      return t;
    },
    Ot = function Ot(t, e) {
      for (var n in e) n in t || "duration" === n || "ease" === n || (t[n] = e[n]);
    },
    St = function St(t, e) {
      for (var n in e) t[n] = e[n];
      return t;
    },
    Pt = function t(e, n) {
      for (var r in n) e[r] = W(n[r]) ? t(e[r] || (e[r] = {}), n[r]) : n[r];
      return e;
    },
    Bt = function Bt(t, e) {
      var n,
        r = {};
      for (n in t) n in e || (r[n] = t[n]);
      return r;
    },
    kt = function kt(t) {
      var e = t.parent || u,
        n = t.keyframes ? Ot : Mt;
      if (q(t.inherit)) for (; e;) n(t, e.vars.defaults), e = e.parent || e._dp;
      return t;
    },
    Lt = function Lt(t, e, n, r) {
      void 0 === n && (n = "_first"), void 0 === r && (r = "_last");
      var i = e._prev,
        u = e._next;
      i ? i._next = u : t[n] === e && (t[n] = u), u ? u._prev = i : t[r] === e && (t[r] = i), e._next = e._prev = e.parent = null;
    },
    Nt = function Nt(t, e) {
      t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove(t), t._act = 0;
    },
    Rt = function Rt(t, e) {
      if (t && (!e || e._end > t._dur || e._start < 0)) for (var n = t; n;) n._dirty = 1, n = n.parent;
      return t;
    },
    It = function It(t) {
      for (var e = t.parent; e && e.parent;) e._dirty = 1, e.totalDuration(), e = e.parent;
      return t;
    },
    zt = function zt(t) {
      return t._repeat ? Yt(t._tTime, t = t.duration() + t._rDelay) * t : 0;
    },
    Yt = function Yt(t, e) {
      return (t /= e) && ~~t === t ? ~~t - 1 : ~~t;
    },
    Xt = function Xt(t, e) {
      return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur);
    },
    jt = function jt(t) {
      return t._end = xt(t._start + (t._tDur / Math.abs(t._ts || t._rts || 1e-8) || 0));
    },
    Vt = function Vt(t, e) {
      var n = t._dp;
      return n && n.smoothChildTiming && t._ts && (t._start = xt(t._dp._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), jt(t), n._dirty || Rt(n, t)), t;
    },
    Ut = function Ut(t, e) {
      var n;
      if ((e._time || e._initted && !e._dur) && (n = Xt(t.rawTime(), e), (!e._dur || Jt(0, e.totalDuration(), n) - e._tTime > 1e-8) && e.render(n, !0)), Rt(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
        if (t._dur < t.duration()) for (n = t; n._dp;) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
        t._zTime = -1e-8;
      }
    },
    Wt = function Wt(t, e, n, r) {
      return e.parent && Nt(e), e._start = xt(n + e._delay), e._end = xt(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)), function (t, e, n, r, i) {
        void 0 === n && (n = "_first"), void 0 === r && (r = "_last");
        var u,
          s = t[r];
        if (i) for (u = e[i]; s && s[i] > u;) s = s._prev;
        s ? (e._next = s._next, s._next = e) : (e._next = t[n], t[n] = e), e._next ? e._next._prev = e : t[r] = e, e._prev = s, e.parent = e._dp = t;
      }(t, e, "_first", "_last", t._sort ? "_start" : 0), t._recent = e, r || Ut(t, e), t;
    },
    qt = function qt(t, e) {
      return (rt.ScrollTrigger || st("scrollTrigger", e)) && rt.ScrollTrigger.create(e, t);
    },
    Gt = function Gt(t, e, n, r) {
      return We(t, e), t._initted ? !n && t._pt && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && h !== Ee.frame ? (ft.push(t), t._lazy = [e, r], 1) : void 0 : 1;
    },
    Ht = function Ht(t, e, n, r) {
      var i = t._repeat,
        u = xt(e) || 0,
        s = t._tTime / t._tDur;
      return s && !r && (t._time *= u / t._dur), t._dur = u, t._tDur = i ? i < 0 ? 1e10 : xt(u * (i + 1) + t._rDelay * i) : u, s && !r ? Vt(t, t._tTime = t._tDur * s) : t.parent && jt(t), n || Rt(t.parent, t), t;
    },
    Qt = function Qt(t) {
      return t instanceof Ye ? Rt(t) : Ht(t, t._dur);
    },
    Kt = {
      _start: 0,
      endTime: lt
    },
    Zt = function t(e, n) {
      var r,
        i,
        u = e.labels,
        s = e._recent || Kt,
        o = e.duration() >= k ? s.endTime(!1) : e._dur;
      return X(n) && (isNaN(n) || n in u) ? "<" === (r = n.charAt(0)) || ">" === r ? ("<" === r ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) : (r = n.indexOf("=")) < 0 ? (n in u || (u[n] = o), u[n]) : (i = +(n.charAt(r - 1) + n.substr(r + 1)), r > 1 ? t(e, n.substr(0, r - 1)) + i : o + i) : null == n ? o : +n;
    },
    $t = function $t(t, e) {
      return t || 0 === t ? e(t) : e;
    },
    Jt = function Jt(t, e, n) {
      return n < t ? t : n > e ? e : n;
    },
    te = function te(t) {
      return (t = (t + "").substr((parseFloat(t) + "").length)) && isNaN(t) ? t : "";
    },
    ee = [].slice,
    ne = function ne(t, e) {
      return t && W(t) && "length" in t && (!e && !t.length || t.length - 1 in t && W(t[0])) && !t.nodeType && t !== s;
    },
    re = function re(t, e, n) {
      return void 0 === n && (n = []), t.forEach(function (t) {
        var r;
        return X(t) && !e || ne(t, 1) ? (r = n).push.apply(r, ie(t)) : n.push(t);
      }) || n;
    },
    ie = function ie(t, e) {
      return !X(t) || e || !o && be() ? K(t) ? re(t, e) : ne(t) ? ee.call(t, 0) : t ? [t] : [] : ee.call(a.querySelectorAll(t), 0);
    },
    ue = function ue(t) {
      return t.sort(function () {
        return .5 - Math.random();
      });
    },
    se = function se(t) {
      if (j(t)) return t;
      var e = W(t) ? t : {
          each: t
        },
        n = Be(e.ease),
        r = e.from || 0,
        i = parseFloat(e.base) || 0,
        u = {},
        s = r > 0 && r < 1,
        o = isNaN(r) || s,
        a = e.axis,
        l = r,
        h = r;
      return X(r) ? l = h = {
        center: .5,
        edges: .5,
        end: 1
      }[r] || 0 : !s && o && (l = r[0], h = r[1]), function (t, s, f) {
        var D,
          p,
          c,
          d,
          g,
          _,
          m,
          v,
          y,
          C = (f || e).length,
          x = u[C];
        if (!x) {
          if (!(y = "auto" === e.grid ? 0 : (e.grid || [1, k])[1])) {
            for (m = -k; m < (m = f[y++].getBoundingClientRect().left) && y < C;);
            y--;
          }
          for (x = u[C] = [], D = o ? Math.min(y, C) * l - .5 : r % y, p = o ? C * h / y - .5 : r / y | 0, m = 0, v = k, _ = 0; _ < C; _++) c = _ % y - D, d = p - (_ / y | 0), x[_] = g = a ? Math.abs("y" === a ? d : c) : I(c * c + d * d), g > m && (m = g), g < v && (v = g);
          "random" === r && ue(x), x.max = m - v, x.min = v, x.v = C = (parseFloat(e.amount) || parseFloat(e.each) * (y > C ? C - 1 : a ? "y" === a ? C / y : y : Math.max(y, C / y)) || 0) * ("edges" === r ? -1 : 1), x.b = C < 0 ? i - C : i, x.u = te(e.amount || e.each) || 0, n = n && C < 0 ? Se(n) : n;
        }
        return C = (x[t] - x.min) / x.max || 0, xt(x.b + (n ? n(C) : C) * x.v) + x.u;
      };
    },
    oe = function oe(t) {
      var e = t < 1 ? Math.pow(10, (t + "").length - 2) : 1;
      return function (n) {
        return Math.floor(Math.round(parseFloat(n) / t) * t * e) / e + (V(n) ? 0 : te(n));
      };
    },
    ae = function ae(t, e) {
      var n,
        r,
        i = K(t);
      return !i && W(t) && (n = i = t.radius || k, t.values ? (t = ie(t.values), (r = !V(t[0])) && (n *= n)) : t = oe(t.increment)), $t(e, i ? j(t) ? function (e) {
        return r = t(e), Math.abs(r - e) <= n ? r : e;
      } : function (e) {
        for (var i, u, s = parseFloat(r ? e.x : e), o = parseFloat(r ? e.y : 0), a = k, l = 0, h = t.length; h--;) (i = r ? (i = t[h].x - s) * i + (u = t[h].y - o) * u : Math.abs(t[h] - s)) < a && (a = i, l = h);
        return l = !n || a <= n ? t[l] : e, r || l === e || V(e) ? l : l + te(e);
      } : oe(t));
    },
    le = function le(t, e, n, r) {
      return $t(K(t) ? !e : !0 === n ? !!(n = 0) : !r, function () {
        return K(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (r = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((t + Math.random() * (e - t)) / n) * n * r) / r;
      });
    },
    he = function he(t, e, n) {
      return $t(n, function (n) {
        return t[~~e(n)];
      });
    },
    fe = function fe(t) {
      for (var e, n, r, i, u = 0, s = ""; ~(e = t.indexOf("random(", u));) r = t.indexOf(")", e), i = "[" === t.charAt(e + 7), n = t.substr(e + 7, r - e - 7).match(i ? nt : Z), s += t.substr(u, e - u) + le(i ? n : +n[0], i ? 0 : +n[1], +n[2] || 1e-5), u = r + 1;
      return s + t.substr(u, t.length - u);
    },
    De = function De(t, e, n, r, i) {
      var u = e - t,
        s = r - n;
      return $t(i, function (e) {
        return n + ((e - t) / u * s || 0);
      });
    },
    pe = function pe(t, e, n) {
      var r,
        i,
        u,
        s = t.labels,
        o = k;
      for (r in s) (i = s[r] - e) < 0 == !!n && i && o > (i = Math.abs(i)) && (u = r, o = i);
      return u;
    },
    ce = function ce(t, e, n) {
      var r,
        i,
        u = t.vars,
        s = u[e];
      if (s) return r = u[e + "Params"], i = u.callbackScope || t, n && ft.length && Et(), r ? s.apply(i, r) : s.call(i);
    },
    de = function de(t) {
      return Nt(t), t.progress() < 1 && ce(t, "onInterrupt"), t;
    },
    ge = function ge(t) {
      var e = (t = !t.name && t.default || t).name,
        n = j(t),
        r = e && !n && t.init ? function () {
          this._props = [];
        } : t,
        i = {
          init: lt,
          render: un,
          add: Ve,
          kill: on,
          modifier: sn,
          rawVars: 0
        },
        u = {
          targetTest: 0,
          get: 0,
          getSetter: tn,
          aliases: {},
          register: 0
        };
      if (be(), t !== r) {
        if (pt[e]) return;
        Mt(r, Mt(Bt(t, i), u)), St(r.prototype, St(i, Bt(t, u))), pt[r.prop = e] = r, t.targetTest && (gt.push(r), ht[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin";
      }
      at(e, r), t.register && t.register(cn, r, hn);
    },
    _e = {
      aqua: [0, 255, 255],
      lime: [0, 255, 0],
      silver: [192, 192, 192],
      black: [0, 0, 0],
      maroon: [128, 0, 0],
      teal: [0, 128, 128],
      blue: [0, 0, 255],
      navy: [0, 0, 128],
      white: [255, 255, 255],
      olive: [128, 128, 0],
      yellow: [255, 255, 0],
      orange: [255, 165, 0],
      gray: [128, 128, 128],
      purple: [128, 0, 128],
      green: [0, 128, 0],
      red: [255, 0, 0],
      pink: [255, 192, 203],
      cyan: [0, 255, 255],
      transparent: [255, 255, 255, 0]
    },
    me = function me(t, e, n) {
      return 255 * (6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) + .5 | 0;
    },
    ve = function ve(t, e, n) {
      var r,
        i,
        u,
        s,
        o,
        a,
        l,
        h,
        f,
        D,
        p = t ? V(t) ? [t >> 16, t >> 8 & 255, 255 & t] : 0 : _e.black;
      if (!p) {
        if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), _e[t]) p = _e[t];else if ("#" === t.charAt(0)) 4 === t.length && (r = t.charAt(1), i = t.charAt(2), u = t.charAt(3), t = "#" + r + r + i + i + u + u), p = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & 255, 255 & t];else if ("hsl" === t.substr(0, 3)) {
          if (p = D = t.match(Z), e) {
            if (~t.indexOf("=")) return p = t.match($), n && p.length < 4 && (p[3] = 1), p;
          } else s = +p[0] % 360 / 360, o = +p[1] / 100, r = 2 * (a = +p[2] / 100) - (i = a <= .5 ? a * (o + 1) : a + o - a * o), p.length > 3 && (p[3] *= 1), p[0] = me(s + 1 / 3, r, i), p[1] = me(s, r, i), p[2] = me(s - 1 / 3, r, i);
        } else p = t.match(Z) || _e.transparent;
        p = p.map(Number);
      }
      return e && !D && (r = p[0] / 255, i = p[1] / 255, u = p[2] / 255, a = ((l = Math.max(r, i, u)) + (h = Math.min(r, i, u))) / 2, l === h ? s = o = 0 : (f = l - h, o = a > .5 ? f / (2 - l - h) : f / (l + h), s = l === r ? (i - u) / f + (i < u ? 6 : 0) : l === i ? (u - r) / f + 2 : (r - i) / f + 4, s *= 60), p[0] = ~~(s + .5), p[1] = ~~(100 * o + .5), p[2] = ~~(100 * a + .5)), n && p.length < 4 && (p[3] = 1), p;
    },
    ye = function ye(t) {
      var e = [],
        n = [],
        r = -1;
      return t.split(xe).forEach(function (t) {
        var i = t.match(J) || [];
        e.push.apply(e, i), n.push(r += i.length + 1);
      }), e.c = n, e;
    },
    Ce = function Ce(t, e, n) {
      var r,
        i,
        u,
        s,
        o = "",
        a = (t + o).match(xe),
        l = e ? "hsla(" : "rgba(",
        h = 0;
      if (!a) return t;
      if (a = a.map(function (t) {
        return (t = ve(t, e, 1)) && l + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")";
      }), n && (u = ye(t), (r = n.c).join(o) !== u.c.join(o))) for (s = (i = t.replace(xe, "1").split(J)).length - 1; h < s; h++) o += i[h] + (~r.indexOf(h) ? a.shift() || l + "0,0,0,0)" : (u.length ? u : a.length ? a : n).shift());
      if (!i) for (s = (i = t.split(xe)).length - 1; h < s; h++) o += i[h] + a[h];
      return o + i[s];
    },
    xe = function () {
      var t,
        e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
      for (t in _e) e += "|" + t + "\\b";
      return new RegExp(e + ")", "gi");
    }(),
    Fe = /hsl[a]?\(/,
    we = function we(t) {
      var e,
        n = t.join(" ");
      if (xe.lastIndex = 0, xe.test(n)) return e = Fe.test(n), t[1] = Ce(t[1], e), t[0] = Ce(t[0], e, ye(t[1])), !0;
    },
    Ee = (v = Date.now, y = 500, C = 33, x = v(), F = x, E = w = 1e3 / 240, T = function t(e) {
      var n,
        r,
        i,
        u,
        s = v() - F,
        o = !0 === e;
      if (s > y && (x += s - C), ((n = (i = (F += s) - x) - E) > 0 || o) && (u = ++g.frame, _ = i - 1e3 * g.time, g.time = i /= 1e3, E += n + (n >= w ? 4 : w - n), r = 1), o || (p = c(t)), r) for (m = 0; m < b.length; m++) b[m](i, _, u, e);
    }, g = {
      time: 0,
      frame: 0,
      tick: function tick() {
        T(!0);
      },
      deltaRatio: function deltaRatio(t) {
        return _ / (1e3 / (t || 60));
      },
      wake: function wake() {
        l && (!o && G() && (s = o = window, a = s.document || {}, rt.gsap = cn, (s.gsapVersions || (s.gsapVersions = [])).push(cn.version), ut(it || s.GreenSockGlobals || !s.gsap && s || {}), d = s.requestAnimationFrame), p && g.sleep(), c = d || function (t) {
          return setTimeout(t, E - 1e3 * g.time + 1 | 0);
        }, D = 1, T(2));
      },
      sleep: function sleep() {
        (d ? s.cancelAnimationFrame : clearTimeout)(p), D = 0, c = lt;
      },
      lagSmoothing: function lagSmoothing(t, e) {
        y = t || 1 / 1e-8, C = Math.min(e, y, 0);
      },
      fps: function fps(t) {
        w = 1e3 / (t || 240), E = 1e3 * g.time + w;
      },
      add: function add(t) {
        b.indexOf(t) < 0 && b.push(t), be();
      },
      remove: function remove(t) {
        var e;
        ~(e = b.indexOf(t)) && b.splice(e, 1) && m >= e && m--;
      },
      _listeners: b = []
    }),
    be = function be() {
      return !D && Ee.wake();
    },
    Te = {},
    Ae = /^[\d.\-M][\d.\-,\s]/,
    Me = /["']/g,
    Oe = function Oe(t) {
      for (var e, n, r, i = {}, u = t.substr(1, t.length - 3).split(":"), s = u[0], o = 1, a = u.length; o < a; o++) n = u[o], e = o !== a - 1 ? n.lastIndexOf(",") : n.length, r = n.substr(0, e), i[s] = isNaN(r) ? r.replace(Me, "").trim() : +r, s = n.substr(e + 1).trim();
      return i;
    },
    Se = function Se(t) {
      return function (e) {
        return 1 - t(1 - e);
      };
    },
    Pe = function t(e, n) {
      for (var r, i = e._first; i;) i instanceof Ye ? t(i, n) : !i.vars.yoyoEase || i._yoyo && i._repeat || i._yoyo === n || (i.timeline ? t(i.timeline, n) : (r = i._ease, i._ease = i._yEase, i._yEase = r, i._yoyo = n)), i = i._next;
    },
    Be = function Be(t, e) {
      return t && (j(t) ? t : Te[t] || function (t) {
        var e,
          n,
          r,
          i,
          u = (t + "").split("("),
          s = Te[u[0]];
        return s && u.length > 1 && s.config ? s.config.apply(null, ~t.indexOf("{") ? [Oe(u[1])] : (e = t, n = e.indexOf("(") + 1, r = e.indexOf(")"), i = e.indexOf("(", n), e.substring(n, ~i && i < r ? e.indexOf(")", r + 1) : r)).split(",").map(Tt)) : Te._CE && Ae.test(t) ? Te._CE("", t) : s;
      }(t)) || e;
    },
    ke = function ke(t, e, n, r) {
      void 0 === n && (n = function n(t) {
        return 1 - e(1 - t);
      }), void 0 === r && (r = function r(t) {
        return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2;
      });
      var i,
        u = {
          easeIn: e,
          easeOut: n,
          easeInOut: r
        };
      return Ct(t, function (t) {
        for (var e in Te[t] = rt[t] = u, Te[i = t.toLowerCase()] = n, u) Te[i + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = Te[t + "." + e] = u[e];
      }), u;
    },
    Le = function Le(t) {
      return function (e) {
        return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2;
      };
    },
    Ne = function t(e, n, r) {
      var i = n >= 1 ? n : 1,
        u = (r || (e ? .3 : .45)) / (n < 1 ? n : 1),
        s = u / L * (Math.asin(1 / i) || 0),
        o = function o(t) {
          return 1 === t ? 1 : i * Math.pow(2, -10 * t) * Y((t - s) * u) + 1;
        },
        a = "out" === e ? o : "in" === e ? function (t) {
          return 1 - o(1 - t);
        } : Le(o);
      return u = L / u, a.config = function (n, r) {
        return t(e, n, r);
      }, a;
    },
    Re = function t(e, n) {
      void 0 === n && (n = 1.70158);
      var r = function r(t) {
          return t ? --t * t * ((n + 1) * t + n) + 1 : 0;
        },
        i = "out" === e ? r : "in" === e ? function (t) {
          return 1 - r(1 - t);
        } : Le(r);
      return i.config = function (n) {
        return t(e, n);
      }, i;
    };
  Ct("Linear,Quad,Cubic,Quart,Quint,Strong", function (t, e) {
    var n = e < 5 ? e + 1 : e;
    ke(t + ",Power" + (n - 1), e ? function (t) {
      return Math.pow(t, n);
    } : function (t) {
      return t;
    }, function (t) {
      return 1 - Math.pow(1 - t, n);
    }, function (t) {
      return t < .5 ? Math.pow(2 * t, n) / 2 : 1 - Math.pow(2 * (1 - t), n) / 2;
    });
  }), Te.Linear.easeNone = Te.none = Te.Linear.easeIn, ke("Elastic", Ne("in"), Ne("out"), Ne()), A = 7.5625, O = 1 / (M = 2.75), ke("Bounce", function (t) {
    return 1 - S(1 - t);
  }, S = function S(t) {
    return t < O ? A * t * t : t < .7272727272727273 ? A * Math.pow(t - 1.5 / M, 2) + .75 : t < .9090909090909092 ? A * (t -= 2.25 / M) * t + .9375 : A * Math.pow(t - 2.625 / M, 2) + .984375;
  }), ke("Expo", function (t) {
    return t ? Math.pow(2, 10 * (t - 1)) : 0;
  }), ke("Circ", function (t) {
    return -(I(1 - t * t) - 1);
  }), ke("Sine", function (t) {
    return 1 === t ? 1 : 1 - z(t * N);
  }), ke("Back", Re("in"), Re("out"), Re()), Te.SteppedEase = Te.steps = rt.SteppedEase = {
    config: function config(t, e) {
      void 0 === t && (t = 1);
      var n = 1 / t,
        r = t + (e ? 0 : 1),
        i = e ? 1 : 0;
      return function (t) {
        return ((r * Jt(0, 1 - 1e-8, t) | 0) + i) * n;
      };
    }
  }, B.ease = Te["quad.out"], Ct("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (t) {
    return _t += t + "," + t + "Params,";
  });
  var Ie = function Ie(t, e) {
      this.id = R++, t._gsap = this, this.target = t, this.harness = e, this.get = e ? e.get : yt, this.set = e ? e.getSetter : tn;
    },
    ze = function () {
      function t(t, e) {
        var n = t.parent || u;
        this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Ht(this, +t.duration, 1, 1), this.data = t.data, D || Ee.wake(), n && Wt(n, this, e || 0 === e ? e : n._time, 1), t.reversed && this.reverse(), t.paused && this.paused(!0);
      }
      var e = t.prototype;
      return e.delay = function (t) {
        return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay;
      }, e.duration = function (t) {
        return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur;
      }, e.totalDuration = function (t) {
        return arguments.length ? (this._dirty = 0, Ht(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur;
      }, e.totalTime = function (t, e) {
        if (be(), !arguments.length) return this._tTime;
        var n = this._dp;
        if (n && n.smoothChildTiming && this._ts) {
          for (Vt(this, t); n.parent;) n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent;
          !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && Wt(this._dp, this, this._start - this._delay);
        }
        return (this._tTime !== t || !this._dur && !e || this._initted && 1e-8 === Math.abs(this._zTime) || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), bt(this, t, e)), this;
      }, e.time = function (t, e) {
        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + zt(this)) % this._dur || (t ? this._dur : 0), e) : this._time;
      }, e.totalProgress = function (t, e) {
        return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
      }, e.progress = function (t, e) {
        return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + zt(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
      }, e.iteration = function (t, e) {
        var n = this.duration() + this._rDelay;
        return arguments.length ? this.totalTime(this._time + (t - 1) * n, e) : this._repeat ? Yt(this._tTime, n) + 1 : 1;
      }, e.timeScale = function (t) {
        if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
        if (this._rts === t) return this;
        var e = this.parent && this._ts ? Xt(this.parent._time, this) : this._tTime;
        return this._rts = +t || 0, this._ts = this._ps || -1e-8 === t ? 0 : this._rts, It(this.totalTime(Jt(-this._delay, this._tDur, e), !0));
      }, e.paused = function (t) {
        return arguments.length ? (this._ps !== t && (this._ps = t, t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (be(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && (this._tTime -= 1e-8) && 1e-8 !== Math.abs(this._zTime)))), this) : this._ps;
      }, e.startTime = function (t) {
        if (arguments.length) {
          this._start = t;
          var e = this.parent || this._dp;
          return e && (e._sort || !this.parent) && Wt(e, this, t - this._delay), this;
        }
        return this._start;
      }, e.endTime = function (t) {
        return this._start + (q(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts);
      }, e.rawTime = function (t) {
        var e = this.parent || this._dp;
        return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Xt(e.rawTime(t), this) : this._tTime : this._tTime;
      }, e.globalTime = function (t) {
        for (var e = this, n = arguments.length ? t : e.rawTime(); e;) n = e._start + n / (e._ts || 1), e = e._dp;
        return n;
      }, e.repeat = function (t) {
        return arguments.length ? (this._repeat = t, Qt(this)) : this._repeat;
      }, e.repeatDelay = function (t) {
        return arguments.length ? (this._rDelay = t, Qt(this)) : this._rDelay;
      }, e.yoyo = function (t) {
        return arguments.length ? (this._yoyo = t, this) : this._yoyo;
      }, e.seek = function (t, e) {
        return this.totalTime(Zt(this, t), q(e));
      }, e.restart = function (t, e) {
        return this.play().totalTime(t ? -this._delay : 0, q(e));
      }, e.play = function (t, e) {
        return null != t && this.seek(t, e), this.reversed(!1).paused(!1);
      }, e.reverse = function (t, e) {
        return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1);
      }, e.pause = function (t, e) {
        return null != t && this.seek(t, e), this.paused(!0);
      }, e.resume = function () {
        return this.paused(!1);
      }, e.reversed = function (t) {
        return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)), this) : this._rts < 0;
      }, e.invalidate = function () {
        return this._initted = 0, this._zTime = -1e-8, this;
      }, e.isActive = function () {
        var t,
          e = this.parent || this._dp,
          n = this._start;
        return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= n && t < this.endTime(!0) - 1e-8));
      }, e.eventCallback = function (t, e, n) {
        var r = this.vars;
        return arguments.length > 1 ? (e ? (r[t] = e, n && (r[t + "Params"] = n), "onUpdate" === t && (this._onUpdate = e)) : delete r[t], this) : r[t];
      }, e.then = function (t) {
        var e = this;
        return new Promise(function (n) {
          var r = j(t) ? t : At,
            i = function i() {
              var t = e.then;
              e.then = null, j(r) && (r = r(e)) && (r.then || r === e) && (e.then = t), n(r), e.then = t;
            };
          e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? i() : e._prom = i;
        });
      }, e.kill = function () {
        de(this);
      }, t;
    }();
  Mt(ze.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -1e-8,
    _prom: 0,
    _ps: !1,
    _rts: 1
  });
  var Ye = function (t) {
    function e(e, n) {
      var i;
      return void 0 === e && (e = {}), (i = t.call(this, e, n) || this).labels = {}, i.smoothChildTiming = !!e.smoothChildTiming, i.autoRemoveChildren = !!e.autoRemoveChildren, i._sort = q(e.sortChildren), i.parent && Ut(i.parent, r(i)), e.scrollTrigger && qt(r(i), e.scrollTrigger), i;
    }
    i(e, t);
    var n = e.prototype;
    return n.to = function (t, e, n) {
      return new Qe(t, wt(arguments, 0, this), Zt(this, V(e) ? arguments[3] : n)), this;
    }, n.from = function (t, e, n) {
      return new Qe(t, wt(arguments, 1, this), Zt(this, V(e) ? arguments[3] : n)), this;
    }, n.fromTo = function (t, e, n, r) {
      return new Qe(t, wt(arguments, 2, this), Zt(this, V(e) ? arguments[4] : r)), this;
    }, n.set = function (t, e, n) {
      return e.duration = 0, e.parent = this, kt(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new Qe(t, e, Zt(this, n), 1), this;
    }, n.call = function (t, e, n) {
      return Wt(this, Qe.delayedCall(0, t, e), Zt(this, n));
    }, n.staggerTo = function (t, e, n, r, i, u, s) {
      return n.duration = e, n.stagger = n.stagger || r, n.onComplete = u, n.onCompleteParams = s, n.parent = this, new Qe(t, n, Zt(this, i)), this;
    }, n.staggerFrom = function (t, e, n, r, i, u, s) {
      return n.runBackwards = 1, kt(n).immediateRender = q(n.immediateRender), this.staggerTo(t, e, n, r, i, u, s);
    }, n.staggerFromTo = function (t, e, n, r, i, u, s, o) {
      return r.startAt = n, kt(r).immediateRender = q(r.immediateRender), this.staggerTo(t, e, r, i, u, s, o);
    }, n.render = function (t, e, n) {
      var r,
        i,
        s,
        o,
        a,
        l,
        h,
        f,
        D,
        p,
        c,
        d,
        g = this._time,
        _ = this._dirty ? this.totalDuration() : this._tDur,
        m = this._dur,
        v = this !== u && t > _ - 1e-8 && t >= 0 ? _ : t < 1e-8 ? 0 : t,
        y = this._zTime < 0 != t < 0 && (this._initted || !m);
      if (v !== this._tTime || n || y) {
        if (g !== this._time && m && (v += this._time - g, t += this._time - g), r = v, D = this._start, l = !(f = this._ts), y && (m || (g = this._zTime), (t || !e) && (this._zTime = t)), this._repeat && (c = this._yoyo, a = m + this._rDelay, r = xt(v % a), v === _ ? (o = this._repeat, r = m) : ((o = ~~(v / a)) && o === v / a && (r = m, o--), r > m && (r = m)), p = Yt(this._tTime, a), !g && this._tTime && p !== o && (p = o), c && 1 & o && (r = m - r, d = 1), o !== p && !this._lock)) {
          var C = c && 1 & p,
            x = C === (c && 1 & o);
          if (o < p && (C = !C), g = C ? 0 : m, this._lock = 1, this.render(g || (d ? 0 : xt(o * a)), e, !m)._lock = 0, !e && this.parent && ce(this, "onRepeat"), this.vars.repeatRefresh && !d && (this.invalidate()._lock = 1), g !== this._time || l !== !this._ts) return this;
          if (m = this._dur, _ = this._tDur, x && (this._lock = 2, g = C ? m : -1e-4, this.render(g, !0), this.vars.repeatRefresh && !d && this.invalidate()), this._lock = 0, !this._ts && !l) return this;
          Pe(this, d);
        }
        if (this._hasPause && !this._forcing && this._lock < 2 && (h = function (t, e, n) {
          var r;
          if (n > e) for (r = t._first; r && r._start <= n;) {
            if (!r._dur && "isPause" === r.data && r._start > e) return r;
            r = r._next;
          } else for (r = t._last; r && r._start >= n;) {
            if (!r._dur && "isPause" === r.data && r._start < e) return r;
            r = r._prev;
          }
        }(this, xt(g), xt(r))) && (v -= r - (r = h._start)), this._tTime = v, this._time = r, this._act = !f, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t), !g && r && !e && ce(this, "onStart"), r >= g && t >= 0) for (i = this._first; i;) {
          if (s = i._next, (i._act || r >= i._start) && i._ts && h !== i) {
            if (i.parent !== this) return this.render(t, e, n);
            if (i.render(i._ts > 0 ? (r - i._start) * i._ts : (i._dirty ? i.totalDuration() : i._tDur) + (r - i._start) * i._ts, e, n), r !== this._time || !this._ts && !l) {
              h = 0, s && (v += this._zTime = -1e-8);
              break;
            }
          }
          i = s;
        } else {
          i = this._last;
          for (var F = t < 0 ? t : r; i;) {
            if (s = i._prev, (i._act || F <= i._end) && i._ts && h !== i) {
              if (i.parent !== this) return this.render(t, e, n);
              if (i.render(i._ts > 0 ? (F - i._start) * i._ts : (i._dirty ? i.totalDuration() : i._tDur) + (F - i._start) * i._ts, e, n), r !== this._time || !this._ts && !l) {
                h = 0, s && (v += this._zTime = F ? -1e-8 : 1e-8);
                break;
              }
            }
            i = s;
          }
        }
        if (h && !e && (this.pause(), h.render(r >= g ? 0 : -1e-8)._zTime = r >= g ? 1 : -1, this._ts)) return this._start = D, jt(this), this.render(t, e, n);
        this._onUpdate && !e && ce(this, "onUpdate", !0), (v === _ && _ >= this.totalDuration() || !v && g) && (D !== this._start && Math.abs(f) === Math.abs(this._ts) || this._lock || ((t || !m) && (v === _ && this._ts > 0 || !v && this._ts < 0) && Nt(this, 1), e || t < 0 && !g || !v && !g || (ce(this, v === _ ? "onComplete" : "onReverseComplete", !0), this._prom && !(v < _ && this.timeScale() > 0) && this._prom())));
      }
      return this;
    }, n.add = function (t, e) {
      var n = this;
      if (V(e) || (e = Zt(this, e)), !(t instanceof ze)) {
        if (K(t)) return t.forEach(function (t) {
          return n.add(t, e);
        }), this;
        if (X(t)) return this.addLabel(t, e);
        if (!j(t)) return this;
        t = Qe.delayedCall(0, t);
      }
      return this !== t ? Wt(this, t, e) : this;
    }, n.getChildren = function (t, e, n, r) {
      void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === n && (n = !0), void 0 === r && (r = -k);
      for (var i = [], u = this._first; u;) u._start >= r && (u instanceof Qe ? e && i.push(u) : (n && i.push(u), t && i.push.apply(i, u.getChildren(!0, e, n)))), u = u._next;
      return i;
    }, n.getById = function (t) {
      for (var e = this.getChildren(1, 1, 1), n = e.length; n--;) if (e[n].vars.id === t) return e[n];
    }, n.remove = function (t) {
      return X(t) ? this.removeLabel(t) : j(t) ? this.killTweensOf(t) : (Lt(this, t), t === this._recent && (this._recent = this._last), Rt(this));
    }, n.totalTime = function (e, n) {
      return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = xt(Ee.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts))), t.prototype.totalTime.call(this, e, n), this._forcing = 0, this) : this._tTime;
    }, n.addLabel = function (t, e) {
      return this.labels[t] = Zt(this, e), this;
    }, n.removeLabel = function (t) {
      return delete this.labels[t], this;
    }, n.addPause = function (t, e, n) {
      var r = Qe.delayedCall(0, e || lt, n);
      return r.data = "isPause", this._hasPause = 1, Wt(this, r, Zt(this, t));
    }, n.removePause = function (t) {
      var e = this._first;
      for (t = Zt(this, t); e;) e._start === t && "isPause" === e.data && Nt(e), e = e._next;
    }, n.killTweensOf = function (t, e, n) {
      for (var r = this.getTweensOf(t, n), i = r.length; i--;) Xe !== r[i] && r[i].kill(t, e);
      return this;
    }, n.getTweensOf = function (t, e) {
      for (var n, r = [], i = ie(t), u = this._first, s = V(e); u;) u instanceof Qe ? Ft(u._targets, i) && (s ? (!Xe || u._initted && u._ts) && u.globalTime(0) <= e && u.globalTime(u.totalDuration()) > e : !e || u.isActive()) && r.push(u) : (n = u.getTweensOf(i, e)).length && r.push.apply(r, n), u = u._next;
      return r;
    }, n.tweenTo = function (t, e) {
      e = e || {};
      var n = this,
        r = Zt(n, t),
        i = e,
        u = i.startAt,
        s = i.onStart,
        o = i.onStartParams,
        a = Qe.to(n, Mt(e, {
          ease: "none",
          lazy: !1,
          time: r,
          overwrite: "auto",
          duration: e.duration || Math.abs((r - (u && "time" in u ? u.time : n._time)) / n.timeScale()) || 1e-8,
          onStart: function onStart() {
            n.pause();
            var t = e.duration || Math.abs((r - n._time) / n.timeScale());
            a._dur !== t && Ht(a, t, 0, 1).render(a._time, !0, !0), s && s.apply(a, o || []);
          }
        }));
      return a;
    }, n.tweenFromTo = function (t, e, n) {
      return this.tweenTo(e, Mt({
        startAt: {
          time: Zt(this, t)
        }
      }, n));
    }, n.recent = function () {
      return this._recent;
    }, n.nextLabel = function (t) {
      return void 0 === t && (t = this._time), pe(this, Zt(this, t));
    }, n.previousLabel = function (t) {
      return void 0 === t && (t = this._time), pe(this, Zt(this, t), 1);
    }, n.currentLabel = function (t) {
      return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + 1e-8);
    }, n.shiftChildren = function (t, e, n) {
      void 0 === n && (n = 0);
      for (var r, i = this._first, u = this.labels; i;) i._start >= n && (i._start += t, i._end += t), i = i._next;
      if (e) for (r in u) u[r] >= n && (u[r] += t);
      return Rt(this);
    }, n.invalidate = function () {
      var e = this._first;
      for (this._lock = 0; e;) e.invalidate(), e = e._next;
      return t.prototype.invalidate.call(this);
    }, n.clear = function (t) {
      void 0 === t && (t = !0);
      for (var e, n = this._first; n;) e = n._next, this.remove(n), n = e;
      return this._time = this._tTime = this._pTime = 0, t && (this.labels = {}), Rt(this);
    }, n.totalDuration = function (t) {
      var e,
        n,
        r,
        i = 0,
        s = this,
        o = s._last,
        a = k;
      if (arguments.length) return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -t : t));
      if (s._dirty) {
        for (r = s.parent; o;) e = o._prev, o._dirty && o.totalDuration(), (n = o._start) > a && s._sort && o._ts && !s._lock ? (s._lock = 1, Wt(s, o, n - o._delay, 1)._lock = 0) : a = n, n < 0 && o._ts && (i -= n, (!r && !s._dp || r && r.smoothChildTiming) && (s._start += n / s._ts, s._time -= n, s._tTime -= n), s.shiftChildren(-n, !1, -Infinity), a = 0), o._end > i && o._ts && (i = o._end), o = e;
        Ht(s, s === u && s._time > i ? s._time : i, 1, 1), s._dirty = 0;
      }
      return s._tDur;
    }, e.updateRoot = function (t) {
      if (u._ts && (bt(u, Xt(t, u)), h = Ee.frame), Ee.frame >= dt) {
        dt += P.autoSleep || 120;
        var e = u._first;
        if ((!e || !e._ts) && P.autoSleep && Ee._listeners.length < 2) {
          for (; e && !e._ts;) e = e._next;
          e || Ee.sleep();
        }
      }
    }, e;
  }(ze);
  Mt(Ye.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
  });
  var Xe,
    je = function je(t, e, n, r, i, u, s) {
      var o,
        a,
        l,
        h,
        f,
        D,
        p,
        c,
        d = new hn(this._pt, t, e, 0, 1, rn, null, i),
        g = 0,
        _ = 0;
      for (d.b = n, d.e = r, n += "", (p = ~(r += "").indexOf("random(")) && (r = fe(r)), u && (u(c = [n, r], t, e), n = c[0], r = c[1]), a = n.match(tt) || []; o = tt.exec(r);) h = o[0], f = r.substring(g, o.index), l ? l = (l + 1) % 5 : "rgba(" === f.substr(-5) && (l = 1), h !== a[_++] && (D = parseFloat(a[_ - 1]) || 0, d._pt = {
        _next: d._pt,
        p: f || 1 === _ ? f : ",",
        s: D,
        c: "=" === h.charAt(1) ? parseFloat(h.substr(2)) * ("-" === h.charAt(0) ? -1 : 1) : parseFloat(h) - D,
        m: l && l < 4 ? Math.round : 0
      }, g = tt.lastIndex);
      return d.c = g < r.length ? r.substring(g, r.length) : "", d.fp = s, (et.test(r) || p) && (d.e = 0), this._pt = d, d;
    },
    Ve = function Ve(t, e, n, r, i, u, s, o, a) {
      j(r) && (r = r(i || 0, t, u));
      var l,
        h = t[e],
        f = "get" !== n ? n : j(h) ? a ? t[e.indexOf("set") || !j(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](a) : t[e]() : h,
        D = j(h) ? a ? $e : Ze : Ke;
      if (X(r) && (~r.indexOf("random(") && (r = fe(r)), "=" === r.charAt(1) && (r = parseFloat(f) + parseFloat(r.substr(2)) * ("-" === r.charAt(0) ? -1 : 1) + (te(f) || 0))), f !== r) return isNaN(f * r) ? (!h && !(e in t) && st(e, r), je.call(this, t, e, f, r, D, o || P.stringFilter, a)) : (l = new hn(this._pt, t, e, +f || 0, r - (f || 0), "boolean" == typeof h ? nn : en, 0, D), a && (l.fp = a), s && l.modifier(s, this, t), this._pt = l);
    },
    Ue = function Ue(t, e, n, r, i, u) {
      var s, o, a, l;
      if (pt[t] && !1 !== (s = new pt[t]()).init(i, s.rawVars ? e[t] : function (t, e, n, r, i) {
        if (j(t) && (t = qe(t, i, e, n, r)), !W(t) || t.style && t.nodeType || K(t) || Q(t)) return X(t) ? qe(t, i, e, n, r) : t;
        var u,
          s = {};
        for (u in t) s[u] = qe(t[u], i, e, n, r);
        return s;
      }(e[t], r, i, u, n), n, r, u) && (n._pt = o = new hn(n._pt, i, t, 0, 1, s.render, s, 0, s.priority), n !== f)) for (a = n._ptLookup[n._targets.indexOf(i)], l = s._props.length; l--;) a[s._props[l]] = o;
      return s;
    },
    We = function t(e, n) {
      var r,
        i,
        s,
        o,
        a,
        l,
        h,
        f,
        D,
        p,
        c,
        d,
        g,
        _ = e.vars,
        m = _.ease,
        v = _.startAt,
        y = _.immediateRender,
        C = _.lazy,
        x = _.onUpdate,
        F = _.onUpdateParams,
        w = _.callbackScope,
        E = _.runBackwards,
        b = _.yoyoEase,
        T = _.keyframes,
        A = _.autoRevert,
        M = e._dur,
        O = e._startAt,
        S = e._targets,
        P = e.parent,
        k = P && "nested" === P.data ? P.parent._targets : S,
        L = "auto" === e._overwrite,
        N = e.timeline;
      if (N && (!T || !m) && (m = "none"), e._ease = Be(m, B.ease), e._yEase = b ? Se(Be(!0 === b ? m : b, B.ease)) : 0, b && e._yoyo && !e._repeat && (b = e._yEase, e._yEase = e._ease, e._ease = b), !N) {
        if (d = (f = S[0] ? vt(S[0]).harness : 0) && _[f.prop], r = Bt(_, ht), O && O.render(-1, !0).kill(), v) {
          if (Nt(e._startAt = Qe.set(S, Mt({
            data: "isStart",
            overwrite: !1,
            parent: P,
            immediateRender: !0,
            lazy: q(C),
            startAt: null,
            delay: 0,
            onUpdate: x,
            onUpdateParams: F,
            callbackScope: w,
            stagger: 0
          }, v))), y) if (n > 0) A || (e._startAt = 0);else if (M && !(n < 0 && O)) return void (n && (e._zTime = n));
        } else if (E && M) if (O) !A && (e._startAt = 0);else if (n && (y = !1), s = Mt({
          overwrite: !1,
          data: "isFromStart",
          lazy: y && q(C),
          immediateRender: y,
          stagger: 0,
          parent: P
        }, r), d && (s[f.prop] = d), Nt(e._startAt = Qe.set(S, s)), y) {
          if (!n) return;
        } else t(e._startAt, 1e-8);
        for (e._pt = 0, C = M && q(C) || C && !M, i = 0; i < S.length; i++) {
          if (h = (a = S[i])._gsap || mt(S)[i]._gsap, e._ptLookup[i] = p = {}, Dt[h.id] && ft.length && Et(), c = k === S ? i : k.indexOf(a), f && !1 !== (D = new f()).init(a, d || r, e, c, k) && (e._pt = o = new hn(e._pt, a, D.name, 0, 1, D.render, D, 0, D.priority), D._props.forEach(function (t) {
            p[t] = o;
          }), D.priority && (l = 1)), !f || d) for (s in r) pt[s] && (D = Ue(s, r, e, c, a, k)) ? D.priority && (l = 1) : p[s] = o = Ve.call(e, a, s, "get", r[s], c, k, 0, _.stringFilter);
          e._op && e._op[i] && e.kill(a, e._op[i]), L && e._pt && (Xe = e, u.killTweensOf(a, p, e.globalTime(0)), g = !e.parent, Xe = 0), e._pt && C && (Dt[h.id] = 1);
        }
        l && ln(e), e._onInit && e._onInit(e);
      }
      e._from = !N && !!_.runBackwards, e._onUpdate = x, e._initted = (!e._op || e._pt) && !g;
    },
    qe = function qe(t, e, n, r, i) {
      return j(t) ? t.call(e, n, r, i) : X(t) && ~t.indexOf("random(") ? fe(t) : t;
    },
    Ge = _t + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
    He = (Ge + ",id,stagger,delay,duration,paused,scrollTrigger").split(","),
    Qe = function (t) {
      function e(e, n, i, s) {
        var o;
        "number" == typeof n && (i.duration = n, n = i, i = null);
        var a,
          l,
          h,
          f,
          D,
          p,
          c,
          d,
          g = (o = t.call(this, s ? n : kt(n), i) || this).vars,
          _ = g.duration,
          m = g.delay,
          v = g.immediateRender,
          y = g.stagger,
          C = g.overwrite,
          x = g.keyframes,
          F = g.defaults,
          w = g.scrollTrigger,
          E = g.yoyoEase,
          b = o.parent,
          T = (K(e) || Q(e) ? V(e[0]) : "length" in n) ? [e] : ie(e);
        if (o._targets = T.length ? mt(T) : ot("GSAP target " + e + " not found. https://greensock.com", !P.nullTargetWarn) || [], o._ptLookup = [], o._overwrite = C, x || y || H(_) || H(m)) {
          if (n = o.vars, (a = o.timeline = new Ye({
            data: "nested",
            defaults: F || {}
          })).kill(), a.parent = r(o), x) Mt(a.vars.defaults, {
            ease: "none"
          }), x.forEach(function (t) {
            return a.to(T, t, ">");
          });else {
            if (f = T.length, c = y ? se(y) : lt, W(y)) for (D in y) ~Ge.indexOf(D) && (d || (d = {}), d[D] = y[D]);
            for (l = 0; l < f; l++) {
              for (D in h = {}, n) He.indexOf(D) < 0 && (h[D] = n[D]);
              h.stagger = 0, E && (h.yoyoEase = E), d && St(h, d), p = T[l], h.duration = +qe(_, r(o), l, p, T), h.delay = (+qe(m, r(o), l, p, T) || 0) - o._delay, !y && 1 === f && h.delay && (o._delay = m = h.delay, o._start += m, h.delay = 0), a.to(p, h, c(l, p, T));
            }
            a.duration() ? _ = m = 0 : o.timeline = 0;
          }
          _ || o.duration(_ = a.duration());
        } else o.timeline = 0;
        return !0 === C && (Xe = r(o), u.killTweensOf(T), Xe = 0), b && Ut(b, r(o)), (v || !_ && !x && o._start === xt(b._time) && q(v) && function t(e) {
          return !e || e._ts && t(e.parent);
        }(r(o)) && "nested" !== b.data) && (o._tTime = -1e-8, o.render(Math.max(0, -m))), w && qt(r(o), w), o;
      }
      i(e, t);
      var n = e.prototype;
      return n.render = function (t, e, n) {
        var r,
          i,
          u,
          s,
          o,
          a,
          l,
          h,
          f,
          D = this._time,
          p = this._tDur,
          c = this._dur,
          d = t > p - 1e-8 && t >= 0 ? p : t < 1e-8 ? 0 : t;
        if (c) {
          if (d !== this._tTime || !t || n || this._startAt && this._zTime < 0 != t < 0) {
            if (r = d, h = this.timeline, this._repeat) {
              if (s = c + this._rDelay, r = xt(d % s), d === p ? (u = this._repeat, r = c) : ((u = ~~(d / s)) && u === d / s && (r = c, u--), r > c && (r = c)), (a = this._yoyo && 1 & u) && (f = this._yEase, r = c - r), o = Yt(this._tTime, s), r === D && !n && this._initted) return this;
              u !== o && (h && this._yEase && Pe(h, a), !this.vars.repeatRefresh || a || this._lock || (this._lock = n = 1, this.render(xt(s * u), !0).invalidate()._lock = 0));
            }
            if (!this._initted) {
              if (Gt(this, t < 0 ? t : r, n, e)) return this._tTime = 0, this;
              if (c !== this._dur) return this.render(t, e, n);
            }
            for (this._tTime = d, this._time = r, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = l = (f || this._ease)(r / c), this._from && (this.ratio = l = 1 - l), r && !D && !e && ce(this, "onStart"), i = this._pt; i;) i.r(l, i.d), i = i._next;
            h && h.render(t < 0 ? t : !r && a ? -1e-8 : h._dur * l, e, n) || this._startAt && (this._zTime = t), this._onUpdate && !e && (t < 0 && this._startAt && this._startAt.render(t, !0, n), ce(this, "onUpdate")), this._repeat && u !== o && this.vars.onRepeat && !e && this.parent && ce(this, "onRepeat"), d !== this._tDur && d || this._tTime !== d || (t < 0 && this._startAt && !this._onUpdate && this._startAt.render(t, !0, !0), (t || !c) && (d === this._tDur && this._ts > 0 || !d && this._ts < 0) && Nt(this, 1), e || t < 0 && !D || !d && !D || (ce(this, d === p ? "onComplete" : "onReverseComplete", !0), this._prom && !(d < p && this.timeScale() > 0) && this._prom()));
          }
        } else !function (t, e, n, r) {
          var i,
            u,
            s = t.ratio,
            o = e < 0 || !e && s && !t._start && t._zTime > 1e-8 && !t._dp._lock || (t._ts < 0 || t._dp._ts < 0) && "isFromStart" !== t.data && "isStart" !== t.data ? 0 : 1,
            a = t._rDelay,
            l = 0;
          if (a && t._repeat && (l = Jt(0, t._tDur, e), Yt(l, a) !== (u = Yt(t._tTime, a)) && (s = 1 - o, t.vars.repeatRefresh && t._initted && t.invalidate())), o !== s || r || 1e-8 === t._zTime || !e && t._zTime) {
            if (!t._initted && Gt(t, e, r, n)) return;
            for (u = t._zTime, t._zTime = e || (n ? 1e-8 : 0), n || (n = e && !u), t.ratio = o, t._from && (o = 1 - o), t._time = 0, t._tTime = l, n || ce(t, "onStart"), i = t._pt; i;) i.r(o, i.d), i = i._next;
            t._startAt && e < 0 && t._startAt.render(e, !0, !0), t._onUpdate && !n && ce(t, "onUpdate"), l && t._repeat && !n && t.parent && ce(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === o && (o && Nt(t, 1), n || (ce(t, o ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()));
          } else t._zTime || (t._zTime = e);
        }(this, t, e, n);
        return this;
      }, n.targets = function () {
        return this._targets;
      }, n.invalidate = function () {
        return this._pt = this._op = this._startAt = this._onUpdate = this._act = this._lazy = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), t.prototype.invalidate.call(this);
      }, n.kill = function (t, e) {
        if (void 0 === e && (e = "all"), !(t || e && "all" !== e) && (this._lazy = 0, this.parent)) return de(this);
        if (this.timeline) {
          var n = this.timeline.totalDuration();
          return this.timeline.killTweensOf(t, e, Xe && !0 !== Xe.vars.overwrite)._first || de(this), this.parent && n !== this.timeline.totalDuration() && Ht(this, this._dur * this.timeline._tDur / n, 0, 1), this;
        }
        var r,
          i,
          u,
          s,
          o,
          a,
          l,
          h = this._targets,
          f = t ? ie(t) : h,
          D = this._ptLookup,
          p = this._pt;
        if ((!e || "all" === e) && function (t, e) {
          for (var n = t.length, r = n === e.length; r && n-- && t[n] === e[n];);
          return n < 0;
        }(h, f)) return "all" === e && (this._pt = 0), de(this);
        for (r = this._op = this._op || [], "all" !== e && (X(e) && (o = {}, Ct(e, function (t) {
          return o[t] = 1;
        }), e = o), e = function (t, e) {
          var n,
            r,
            i,
            u,
            s = t[0] ? vt(t[0]).harness : 0,
            o = s && s.aliases;
          if (!o) return e;
          for (r in n = St({}, e), o) if ((r in n)) for (i = (u = o[r].split(",")).length; i--;) n[u[i]] = n[r];
          return n;
        }(h, e)), l = h.length; l--;) if (~f.indexOf(h[l])) for (o in i = D[l], "all" === e ? (r[l] = e, s = i, u = {}) : (u = r[l] = r[l] || {}, s = e), s) (a = i && i[o]) && ("kill" in a.d && !0 !== a.d.kill(o) || Lt(this, a, "_pt"), delete i[o]), "all" !== u && (u[o] = 1);
        return this._initted && !this._pt && p && de(this), this;
      }, e.to = function (t, n) {
        return new e(t, n, arguments[2]);
      }, e.from = function (t, n) {
        return new e(t, wt(arguments, 1));
      }, e.delayedCall = function (t, n, r, i) {
        return new e(n, 0, {
          immediateRender: !1,
          lazy: !1,
          overwrite: !1,
          delay: t,
          onComplete: n,
          onReverseComplete: n,
          onCompleteParams: r,
          onReverseCompleteParams: r,
          callbackScope: i
        });
      }, e.fromTo = function (t, n, r) {
        return new e(t, wt(arguments, 2));
      }, e.set = function (t, n) {
        return n.duration = 0, n.repeatDelay || (n.repeat = 0), new e(t, n);
      }, e.killTweensOf = function (t, e, n) {
        return u.killTweensOf(t, e, n);
      }, e;
    }(ze);
  Mt(Qe.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
  }), Ct("staggerTo,staggerFrom,staggerFromTo", function (t) {
    Qe[t] = function () {
      var e = new Ye(),
        n = ee.call(arguments, 0);
      return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n);
    };
  });
  var Ke = function Ke(t, e, n) {
      return t[e] = n;
    },
    Ze = function Ze(t, e, n) {
      return t[e](n);
    },
    $e = function $e(t, e, n, r) {
      return t[e](r.fp, n);
    },
    Je = function Je(t, e, n) {
      return t.setAttribute(e, n);
    },
    tn = function tn(t, e) {
      return j(t[e]) ? Ze : U(t[e]) && t.setAttribute ? Je : Ke;
    },
    en = function en(t, e) {
      return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4, e);
    },
    nn = function nn(t, e) {
      return e.set(e.t, e.p, !!(e.s + e.c * t), e);
    },
    rn = function rn(t, e) {
      var n = e._pt,
        r = "";
      if (!t && e.b) r = e.b;else if (1 === t && e.e) r = e.e;else {
        for (; n;) r = n.p + (n.m ? n.m(n.s + n.c * t) : Math.round(1e4 * (n.s + n.c * t)) / 1e4) + r, n = n._next;
        r += e.c;
      }
      e.set(e.t, e.p, r, e);
    },
    un = function un(t, e) {
      for (var n = e._pt; n;) n.r(t, n.d), n = n._next;
    },
    sn = function sn(t, e, n, r) {
      for (var i, u = this._pt; u;) i = u._next, u.p === r && u.modifier(t, e, n), u = i;
    },
    on = function on(t) {
      for (var e, n, r = this._pt; r;) n = r._next, r.p === t && !r.op || r.op === t ? Lt(this, r, "_pt") : r.dep || (e = 1), r = n;
      return !e;
    },
    an = function an(t, e, n, r) {
      r.mSet(t, e, r.m.call(r.tween, n, r.mt), r);
    },
    ln = function ln(t) {
      for (var e, n, r, i, u = t._pt; u;) {
        for (e = u._next, n = r; n && n.pr > u.pr;) n = n._next;
        (u._prev = n ? n._prev : i) ? u._prev._next = u : r = u, (u._next = n) ? n._prev = u : i = u, u = e;
      }
      t._pt = r;
    },
    hn = function () {
      function t(t, e, n, r, i, u, s, o, a) {
        this.t = e, this.s = r, this.c = i, this.p = n, this.r = u || en, this.d = s || this, this.set = o || Ke, this.pr = a || 0, this._next = t, t && (t._prev = this);
      }
      return t.prototype.modifier = function (t, e, n) {
        this.mSet = this.mSet || this.set, this.set = an, this.m = t, this.mt = n, this.tween = e;
      }, t;
    }();
  Ct(_t + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (t) {
    return ht[t] = 1;
  }), rt.TweenMax = rt.TweenLite = Qe, rt.TimelineLite = rt.TimelineMax = Ye, u = new Ye({
    sortChildren: !1,
    defaults: B,
    autoRemoveChildren: !0,
    id: "root",
    smoothChildTiming: !0
  }), P.stringFilter = we;
  var fn = {
    registerPlugin: function registerPlugin() {
      for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
      e.forEach(function (t) {
        return ge(t);
      });
    },
    timeline: function timeline(t) {
      return new Ye(t);
    },
    getTweensOf: function getTweensOf(t, e) {
      return u.getTweensOf(t, e);
    },
    getProperty: function getProperty(t, e, n, r) {
      X(t) && (t = ie(t)[0]);
      var i = vt(t || {}).get,
        u = n ? At : Tt;
      return "native" === n && (n = ""), t ? e ? u((pt[e] && pt[e].get || i)(t, e, n, r)) : function (e, n, r) {
        return u((pt[e] && pt[e].get || i)(t, e, n, r));
      } : t;
    },
    quickSetter: function quickSetter(t, e, n) {
      if ((t = ie(t)).length > 1) {
        var r = t.map(function (t) {
            return cn.quickSetter(t, e, n);
          }),
          i = r.length;
        return function (t) {
          for (var e = i; e--;) r[e](t);
        };
      }
      t = t[0] || {};
      var u = pt[e],
        s = vt(t),
        o = s.harness && (s.harness.aliases || {})[e] || e,
        a = u ? function (e) {
          var r = new u();
          f._pt = 0, r.init(t, n ? e + n : e, f, 0, [t]), r.render(1, r), f._pt && un(1, f);
        } : s.set(t, o);
      return u ? a : function (e) {
        return a(t, o, n ? e + n : e, s, 1);
      };
    },
    isTweening: function isTweening(t) {
      return u.getTweensOf(t, !0).length > 0;
    },
    defaults: function defaults(t) {
      return t && t.ease && (t.ease = Be(t.ease, B.ease)), Pt(B, t || {});
    },
    config: function config(t) {
      return Pt(P, t || {});
    },
    registerEffect: function registerEffect(t) {
      var e = t.name,
        n = t.effect,
        r = t.plugins,
        i = t.defaults,
        u = t.extendTimeline;
      (r || "").split(",").forEach(function (t) {
        return t && !pt[t] && !rt[t] && ot(e + " effect requires " + t + " plugin.");
      }), ct[e] = function (t, e, r) {
        return n(ie(t), Mt(e || {}, i), r);
      }, u && (Ye.prototype[e] = function (t, n, r) {
        return this.add(ct[e](t, W(n) ? n : (r = n) && {}, this), r);
      });
    },
    registerEase: function registerEase(t, e) {
      Te[t] = Be(e);
    },
    parseEase: function parseEase(t, e) {
      return arguments.length ? Be(t, e) : Te;
    },
    getById: function getById(t) {
      return u.getById(t);
    },
    exportRoot: function exportRoot(t, e) {
      void 0 === t && (t = {});
      var n,
        r,
        i = new Ye(t);
      for (i.smoothChildTiming = q(t.smoothChildTiming), u.remove(i), i._dp = 0, i._time = i._tTime = u._time, n = u._first; n;) r = n._next, !e && !n._dur && n instanceof Qe && n.vars.onComplete === n._targets[0] || Wt(i, n, n._start - n._delay), n = r;
      return Wt(u, i, 0), i;
    },
    utils: {
      wrap: function t(e, n, r) {
        var i = n - e;
        return K(e) ? he(e, t(0, e.length), n) : $t(r, function (t) {
          return (i + (t - e) % i) % i + e;
        });
      },
      wrapYoyo: function t(e, n, r) {
        var i = n - e,
          u = 2 * i;
        return K(e) ? he(e, t(0, e.length - 1), n) : $t(r, function (t) {
          return e + ((t = (u + (t - e) % u) % u || 0) > i ? u - t : t);
        });
      },
      distribute: se,
      random: le,
      snap: ae,
      normalize: function normalize(t, e, n) {
        return De(t, e, 0, 1, n);
      },
      getUnit: te,
      clamp: function clamp(t, e, n) {
        return $t(n, function (n) {
          return Jt(t, e, n);
        });
      },
      splitColor: ve,
      toArray: ie,
      mapRange: De,
      pipe: function pipe() {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
        return function (t) {
          return e.reduce(function (t, e) {
            return e(t);
          }, t);
        };
      },
      unitize: function unitize(t, e) {
        return function (n) {
          return t(parseFloat(n)) + (e || te(n));
        };
      },
      interpolate: function t(e, n, r, i) {
        var u = isNaN(e + n) ? 0 : function (t) {
          return (1 - t) * e + t * n;
        };
        if (!u) {
          var s,
            o,
            a,
            l,
            h,
            f = X(e),
            D = {};
          if (!0 === r && (i = 1) && (r = null), f) e = {
            p: e
          }, n = {
            p: n
          };else if (K(e) && !K(n)) {
            for (a = [], l = e.length, h = l - 2, o = 1; o < l; o++) a.push(t(e[o - 1], e[o]));
            l--, u = function u(t) {
              t *= l;
              var e = Math.min(h, ~~t);
              return a[e](t - e);
            }, r = n;
          } else i || (e = St(K(e) ? [] : {}, e));
          if (!a) {
            for (s in n) Ve.call(D, e, s, "get", n[s]);
            u = function u(t) {
              return un(t, D) || (f ? e.p : e);
            };
          }
        }
        return $t(r, u);
      },
      shuffle: ue
    },
    install: ut,
    effects: ct,
    ticker: Ee,
    updateRoot: Ye.updateRoot,
    plugins: pt,
    globalTimeline: u,
    core: {
      PropTween: hn,
      globals: at,
      Tween: Qe,
      Timeline: Ye,
      Animation: ze,
      getCache: vt,
      _removeLinkedListItem: Lt
    }
  };
  Ct("to,from,fromTo,delayedCall,set,killTweensOf", function (t) {
    return fn[t] = Qe[t];
  }), Ee.add(Ye.updateRoot), f = fn.to({}, {
    duration: 0
  });
  var Dn = function Dn(t, e) {
      for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e;) n = n._next;
      return n;
    },
    pn = function pn(t, e) {
      return {
        name: t,
        rawVars: 1,
        init: function init(t, n, r) {
          r._onInit = function (t) {
            var r, i;
            if (X(n) && (r = {}, Ct(n, function (t) {
              return r[t] = 1;
            }), n = r), e) {
              for (i in r = {}, n) r[i] = e(n[i]);
              n = r;
            }
            !function (t, e) {
              var n,
                r,
                i,
                u = t._targets;
              for (n in e) for (r = u.length; r--;) (i = t._ptLookup[r][n]) && (i = i.d) && (i._pt && (i = Dn(i, n)), i && i.modifier && i.modifier(e[n], t, u[r], n));
            }(t, n);
          };
        }
      };
    },
    cn = fn.registerPlugin({
      name: "attr",
      init: function init(t, e, n, r, i) {
        var u, s;
        for (u in e) (s = this.add(t, "setAttribute", (t.getAttribute(u) || 0) + "", e[u], r, i, 0, 0, u)) && (s.op = u), this._props.push(u);
      }
    }, {
      name: "endArray",
      init: function init(t, e) {
        for (var n = e.length; n--;) this.add(t, n, t[n] || 0, e[n]);
      }
    }, pn("roundProps", oe), pn("modifiers"), pn("snap", ae)) || fn;
  Qe.version = Ye.version = cn.version = "3.5.1", l = 1, G() && be();
  Te.Power0, Te.Power1, Te.Power2, Te.Power3, Te.Power4, Te.Linear, Te.Quad, Te.Cubic, Te.Quart, Te.Quint, Te.Strong, Te.Elastic, Te.Back, Te.SteppedEase, Te.Bounce, Te.Sine, Te.Expo, Te.Circ;
  /*!
   * CSSPlugin 3.5.1
   * https://greensock.com
   *
   * Copyright 2008-2020, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  var dn,
    gn,
    _n,
    mn,
    vn,
    yn,
    Cn,
    xn,
    Fn = {},
    wn = 180 / Math.PI,
    En = Math.PI / 180,
    bn = Math.atan2,
    Tn = /([A-Z])/g,
    An = /(?:left|right|width|margin|padding|x)/i,
    Mn = /[\s,\(]\S/,
    On = {
      autoAlpha: "opacity,visibility",
      scale: "scaleX,scaleY",
      alpha: "opacity"
    },
    Sn = function Sn(t, e) {
      return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e);
    },
    Pn = function Pn(t, e) {
      return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e);
    },
    Bn = function Bn(t, e) {
      return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e);
    },
    kn = function kn(t, e) {
      var n = e.s + e.c * t;
      e.set(e.t, e.p, ~~(n + (n < 0 ? -.5 : .5)) + e.u, e);
    },
    Ln = function Ln(t, e) {
      return e.set(e.t, e.p, t ? e.e : e.b, e);
    },
    Nn = function Nn(t, e) {
      return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e);
    },
    Rn = function Rn(t, e, n) {
      return t.style[e] = n;
    },
    In = function In(t, e, n) {
      return t.style.setProperty(e, n);
    },
    zn = function zn(t, e, n) {
      return t._gsap[e] = n;
    },
    Yn = function Yn(t, e, n) {
      return t._gsap.scaleX = t._gsap.scaleY = n;
    },
    Xn = function Xn(t, e, n, r, i) {
      var u = t._gsap;
      u.scaleX = u.scaleY = n, u.renderTransform(i, u);
    },
    jn = function jn(t, e, n, r, i) {
      var u = t._gsap;
      u[e] = n, u.renderTransform(i, u);
    },
    Vn = "transform",
    Un = Vn + "Origin",
    Wn = function Wn(t, e) {
      var n = gn.createElementNS ? gn.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : gn.createElement(t);
      return n.style ? n : gn.createElement(t);
    },
    qn = function t(e, n, r) {
      var i = getComputedStyle(e);
      return i[n] || i.getPropertyValue(n.replace(Tn, "-$1").toLowerCase()) || i.getPropertyValue(n) || !r && t(e, Hn(n) || n, 1) || "";
    },
    Gn = "O,Moz,ms,Ms,Webkit".split(","),
    Hn = function Hn(t, e, n) {
      var r = (e || vn).style,
        i = 5;
      if (t in r && !n) return t;
      for (t = t.charAt(0).toUpperCase() + t.substr(1); i-- && !(Gn[i] + t in r););
      return i < 0 ? null : (3 === i ? "ms" : i >= 0 ? Gn[i] : "") + t;
    },
    Qn = function Qn() {
      "undefined" != typeof window && window.document && (dn = window, gn = dn.document, _n = gn.documentElement, vn = Wn("div") || {
        style: {}
      }, yn = Wn("div"), Vn = Hn(Vn), Un = Vn + "Origin", vn.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", xn = !!Hn("perspective"), mn = 1);
    },
    Kn = function t(e) {
      var n,
        r = Wn("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
        i = this.parentNode,
        u = this.nextSibling,
        s = this.style.cssText;
      if (_n.appendChild(r), r.appendChild(this), this.style.display = "block", e) try {
        n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = t;
      } catch (t) {} else this._gsapBBox && (n = this._gsapBBox());
      return i && (u ? i.insertBefore(this, u) : i.appendChild(this)), _n.removeChild(r), this.style.cssText = s, n;
    },
    Zn = function Zn(t, e) {
      for (var n = e.length; n--;) if (t.hasAttribute(e[n])) return t.getAttribute(e[n]);
    },
    $n = function $n(t) {
      var e;
      try {
        e = t.getBBox();
      } catch (n) {
        e = Kn.call(t, !0);
      }
      return e && (e.width || e.height) || t.getBBox === Kn || (e = Kn.call(t, !0)), !e || e.width || e.x || e.y ? e : {
        x: +Zn(t, ["x", "cx", "x1"]) || 0,
        y: +Zn(t, ["y", "cy", "y1"]) || 0,
        width: 0,
        height: 0
      };
    },
    Jn = function Jn(t) {
      return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !$n(t));
    },
    tr = function tr(t, e) {
      if (e) {
        var n = t.style;
        e in Fn && e !== Un && (e = Vn), n.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), n.removeProperty(e.replace(Tn, "-$1").toLowerCase())) : n.removeAttribute(e);
      }
    },
    er = function er(t, e, n, r, i, u) {
      var s = new hn(t._pt, e, n, 0, 1, u ? Nn : Ln);
      return t._pt = s, s.b = r, s.e = i, t._props.push(n), s;
    },
    nr = {
      deg: 1,
      rad: 1,
      turn: 1
    },
    rr = function t(e, n, r, i) {
      var u,
        s,
        o,
        a,
        l = parseFloat(r) || 0,
        h = (r + "").trim().substr((l + "").length) || "px",
        f = vn.style,
        D = An.test(n),
        p = "svg" === e.tagName.toLowerCase(),
        c = (p ? "client" : "offset") + (D ? "Width" : "Height"),
        d = "px" === i,
        g = "%" === i;
      return i === h || !l || nr[i] || nr[h] ? l : ("px" !== h && !d && (l = t(e, n, r, "px")), a = e.getCTM && Jn(e), g && (Fn[n] || ~n.indexOf("adius")) ? xt(l / (a ? e.getBBox()[D ? "width" : "height"] : e[c]) * 100) : (f[D ? "width" : "height"] = 100 + (d ? h : i), s = ~n.indexOf("adius") || "em" === i && e.appendChild && !p ? e : e.parentNode, a && (s = (e.ownerSVGElement || {}).parentNode), s && s !== gn && s.appendChild || (s = gn.body), (o = s._gsap) && g && o.width && D && o.time === Ee.time ? xt(l / o.width * 100) : ((g || "%" === h) && (f.position = qn(e, "position")), s === e && (f.position = "static"), s.appendChild(vn), u = vn[c], s.removeChild(vn), f.position = "absolute", D && g && ((o = vt(s)).time = Ee.time, o.width = s[c]), xt(d ? u * l / 100 : u && l ? 100 / u * l : 0))));
    },
    ir = function ir(t, e, n, r) {
      var i;
      return mn || Qn(), e in On && "transform" !== e && ~(e = On[e]).indexOf(",") && (e = e.split(",")[0]), Fn[e] && "transform" !== e ? (i = dr(t, r), i = "transformOrigin" !== e ? i[e] : gr(qn(t, Un)) + " " + i.zOrigin + "px") : (!(i = t.style[e]) || "auto" === i || r || ~(i + "").indexOf("calc(")) && (i = ar[e] && ar[e](t, e, n) || qn(t, e) || yt(t, e) || ("opacity" === e ? 1 : 0)), n && !~(i + "").indexOf(" ") ? rr(t, e, i, n) + n : i;
    },
    ur = function ur(t, e, n, r) {
      if (!n || "none" === n) {
        var i = Hn(e, t, 1),
          u = i && qn(t, i, 1);
        u && u !== n ? (e = i, n = u) : "borderColor" === e && (n = qn(t, "borderTopColor"));
      }
      var s,
        o,
        a,
        l,
        h,
        f,
        D,
        p,
        c,
        d,
        g,
        _,
        m = new hn(this._pt, t.style, e, 0, 1, rn),
        v = 0,
        y = 0;
      if (m.b = n, m.e = r, n += "", "auto" === (r += "") && (t.style[e] = r, r = qn(t, e) || r, t.style[e] = n), we(s = [n, r]), r = s[1], a = (n = s[0]).match(J) || [], (r.match(J) || []).length) {
        for (; o = J.exec(r);) D = o[0], c = r.substring(v, o.index), h ? h = (h + 1) % 5 : "rgba(" !== c.substr(-5) && "hsla(" !== c.substr(-5) || (h = 1), D !== (f = a[y++] || "") && (l = parseFloat(f) || 0, g = f.substr((l + "").length), (_ = "=" === D.charAt(1) ? +(D.charAt(0) + "1") : 0) && (D = D.substr(2)), p = parseFloat(D), d = D.substr((p + "").length), v = J.lastIndex - d.length, d || (d = d || P.units[e] || g, v === r.length && (r += d, m.e += d)), g !== d && (l = rr(t, e, f, d) || 0), m._pt = {
          _next: m._pt,
          p: c || 1 === y ? c : ",",
          s: l,
          c: _ ? _ * p : p - l,
          m: h && h < 4 ? Math.round : 0
        });
        m.c = v < r.length ? r.substring(v, r.length) : "";
      } else m.r = "display" === e && "none" === r ? Nn : Ln;
      return et.test(r) && (m.e = 0), this._pt = m, m;
    },
    sr = {
      top: "0%",
      bottom: "100%",
      left: "0%",
      right: "100%",
      center: "50%"
    },
    or = function or(t, e) {
      if (e.tween && e.tween._time === e.tween._dur) {
        var n,
          r,
          i,
          u = e.t,
          s = u.style,
          o = e.u,
          a = u._gsap;
        if ("all" === o || !0 === o) s.cssText = "", r = 1;else for (i = (o = o.split(",")).length; --i > -1;) n = o[i], Fn[n] && (r = 1, n = "transformOrigin" === n ? Un : Vn), tr(u, n);
        r && (tr(u, Vn), a && (a.svg && u.removeAttribute("transform"), dr(u, 1), a.uncache = 1));
      }
    },
    ar = {
      clearProps: function clearProps(t, e, n, r, i) {
        if ("isFromStart" !== i.data) {
          var u = t._pt = new hn(t._pt, e, n, 0, 0, or);
          return u.u = r, u.pr = -10, u.tween = i, t._props.push(n), 1;
        }
      }
    },
    lr = [1, 0, 0, 1, 0, 0],
    hr = {},
    fr = function fr(t) {
      return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t;
    },
    Dr = function Dr(t) {
      var e = qn(t, Vn);
      return fr(e) ? lr : e.substr(7).match($).map(xt);
    },
    pr = function pr(t, e) {
      var n,
        r,
        i,
        u,
        s = t._gsap || vt(t),
        o = t.style,
        a = Dr(t);
      return s.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (a = [(i = t.transform.baseVal.consolidate().matrix).a, i.b, i.c, i.d, i.e, i.f]).join(",") ? lr : a : (a !== lr || t.offsetParent || t === _n || s.svg || (i = o.display, o.display = "block", (n = t.parentNode) && t.offsetParent || (u = 1, r = t.nextSibling, _n.appendChild(t)), a = Dr(t), i ? o.display = i : tr(t, "display"), u && (r ? n.insertBefore(t, r) : n ? n.appendChild(t) : _n.removeChild(t))), e && a.length > 6 ? [a[0], a[1], a[4], a[5], a[12], a[13]] : a);
    },
    cr = function cr(t, e, n, r, i, u) {
      var s,
        o,
        a,
        l = t._gsap,
        h = i || pr(t, !0),
        f = l.xOrigin || 0,
        D = l.yOrigin || 0,
        p = l.xOffset || 0,
        c = l.yOffset || 0,
        d = h[0],
        g = h[1],
        _ = h[2],
        m = h[3],
        v = h[4],
        y = h[5],
        C = e.split(" "),
        x = parseFloat(C[0]) || 0,
        F = parseFloat(C[1]) || 0;
      n ? h !== lr && (o = d * m - g * _) && (a = x * (-g / o) + F * (d / o) - (d * y - g * v) / o, x = x * (m / o) + F * (-_ / o) + (_ * y - m * v) / o, F = a) : (x = (s = $n(t)).x + (~C[0].indexOf("%") ? x / 100 * s.width : x), F = s.y + (~(C[1] || C[0]).indexOf("%") ? F / 100 * s.height : F)), r || !1 !== r && l.smooth ? (v = x - f, y = F - D, l.xOffset = p + (v * d + y * _) - v, l.yOffset = c + (v * g + y * m) - y) : l.xOffset = l.yOffset = 0, l.xOrigin = x, l.yOrigin = F, l.smooth = !!r, l.origin = e, l.originIsAbsolute = !!n, t.style[Un] = "0px 0px", u && (er(u, l, "xOrigin", f, x), er(u, l, "yOrigin", D, F), er(u, l, "xOffset", p, l.xOffset), er(u, l, "yOffset", c, l.yOffset)), t.setAttribute("data-svg-origin", x + " " + F);
    },
    dr = function dr(t, e) {
      var n = t._gsap || new Ie(t);
      if ("x" in n && !e && !n.uncache) return n;
      var r,
        i,
        u,
        s,
        o,
        a,
        l,
        h,
        f,
        D,
        p,
        c,
        d,
        g,
        _,
        m,
        v,
        y,
        C,
        x,
        F,
        w,
        E,
        b,
        T,
        A,
        M,
        O,
        S,
        B,
        k,
        L,
        N = t.style,
        R = n.scaleX < 0,
        I = qn(t, Un) || "0";
      return r = i = u = a = l = h = f = D = p = 0, s = o = 1, n.svg = !(!t.getCTM || !Jn(t)), g = pr(t, n.svg), n.svg && (b = !n.uncache && t.getAttribute("data-svg-origin"), cr(t, b || I, !!b || n.originIsAbsolute, !1 !== n.smooth, g)), c = n.xOrigin || 0, d = n.yOrigin || 0, g !== lr && (y = g[0], C = g[1], x = g[2], F = g[3], r = w = g[4], i = E = g[5], 6 === g.length ? (s = Math.sqrt(y * y + C * C), o = Math.sqrt(F * F + x * x), a = y || C ? bn(C, y) * wn : 0, (f = x || F ? bn(x, F) * wn + a : 0) && (o *= Math.cos(f * En)), n.svg && (r -= c - (c * y + d * x), i -= d - (c * C + d * F))) : (L = g[6], B = g[7], M = g[8], O = g[9], S = g[10], k = g[11], r = g[12], i = g[13], u = g[14], l = (_ = bn(L, S)) * wn, _ && (b = w * (m = Math.cos(-_)) + M * (v = Math.sin(-_)), T = E * m + O * v, A = L * m + S * v, M = w * -v + M * m, O = E * -v + O * m, S = L * -v + S * m, k = B * -v + k * m, w = b, E = T, L = A), h = (_ = bn(-x, S)) * wn, _ && (m = Math.cos(-_), k = F * (v = Math.sin(-_)) + k * m, y = b = y * m - M * v, C = T = C * m - O * v, x = A = x * m - S * v), a = (_ = bn(C, y)) * wn, _ && (b = y * (m = Math.cos(_)) + C * (v = Math.sin(_)), T = w * m + E * v, C = C * m - y * v, E = E * m - w * v, y = b, w = T), l && Math.abs(l) + Math.abs(a) > 359.9 && (l = a = 0, h = 180 - h), s = xt(Math.sqrt(y * y + C * C + x * x)), o = xt(Math.sqrt(E * E + L * L)), _ = bn(w, E), f = Math.abs(_) > 2e-4 ? _ * wn : 0, p = k ? 1 / (k < 0 ? -k : k) : 0), n.svg && (b = t.getAttribute("transform"), n.forceCSS = t.setAttribute("transform", "") || !fr(qn(t, Vn)), b && t.setAttribute("transform", b))), Math.abs(f) > 90 && Math.abs(f) < 270 && (R ? (s *= -1, f += a <= 0 ? 180 : -180, a += a <= 0 ? 180 : -180) : (o *= -1, f += f <= 0 ? 180 : -180)), n.x = ((n.xPercent = r && Math.round(t.offsetWidth / 2) === Math.round(-r) ? -50 : 0) ? 0 : r) + "px", n.y = ((n.yPercent = i && Math.round(t.offsetHeight / 2) === Math.round(-i) ? -50 : 0) ? 0 : i) + "px", n.z = u + "px", n.scaleX = xt(s), n.scaleY = xt(o), n.rotation = xt(a) + "deg", n.rotationX = xt(l) + "deg", n.rotationY = xt(h) + "deg", n.skewX = f + "deg", n.skewY = D + "deg", n.transformPerspective = p + "px", (n.zOrigin = parseFloat(I.split(" ")[2]) || 0) && (N[Un] = gr(I)), n.xOffset = n.yOffset = 0, n.force3D = P.force3D, n.renderTransform = n.svg ? yr : xn ? vr : mr, n.uncache = 0, n;
    },
    gr = function gr(t) {
      return (t = t.split(" "))[0] + " " + t[1];
    },
    _r = function _r(t, e, n) {
      var r = te(e);
      return xt(parseFloat(e) + parseFloat(rr(t, "x", n + "px", r))) + r;
    },
    mr = function mr(t, e) {
      e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, vr(t, e);
    },
    vr = function vr(t, e) {
      var n = e || this,
        r = n.xPercent,
        i = n.yPercent,
        u = n.x,
        s = n.y,
        o = n.z,
        a = n.rotation,
        l = n.rotationY,
        h = n.rotationX,
        f = n.skewX,
        D = n.skewY,
        p = n.scaleX,
        c = n.scaleY,
        d = n.transformPerspective,
        g = n.force3D,
        _ = n.target,
        m = n.zOrigin,
        v = "",
        y = "auto" === g && t && 1 !== t || !0 === g;
      if (m && ("0deg" !== h || "0deg" !== l)) {
        var C,
          x = parseFloat(l) * En,
          F = Math.sin(x),
          w = Math.cos(x);
        x = parseFloat(h) * En, C = Math.cos(x), u = _r(_, u, F * C * -m), s = _r(_, s, -Math.sin(x) * -m), o = _r(_, o, w * C * -m + m);
      }
      "0px" !== d && (v += "perspective(" + d + ") "), (r || i) && (v += "translate(" + r + "%, " + i + "%) "), (y || "0px" !== u || "0px" !== s || "0px" !== o) && (v += "0px" !== o || y ? "translate3d(" + u + ", " + s + ", " + o + ") " : "translate(" + u + ", " + s + ") "), "0deg" !== a && (v += "rotate(" + a + ") "), "0deg" !== l && (v += "rotateY(" + l + ") "), "0deg" !== h && (v += "rotateX(" + h + ") "), "0deg" === f && "0deg" === D || (v += "skew(" + f + ", " + D + ") "), 1 === p && 1 === c || (v += "scale(" + p + ", " + c + ") "), _.style[Vn] = v || "translate(0, 0)";
    },
    yr = function yr(t, e) {
      var n,
        r,
        i,
        u,
        s,
        o = e || this,
        a = o.xPercent,
        l = o.yPercent,
        h = o.x,
        f = o.y,
        D = o.rotation,
        p = o.skewX,
        c = o.skewY,
        d = o.scaleX,
        g = o.scaleY,
        _ = o.target,
        m = o.xOrigin,
        v = o.yOrigin,
        y = o.xOffset,
        C = o.yOffset,
        x = o.forceCSS,
        F = parseFloat(h),
        w = parseFloat(f);
      D = parseFloat(D), p = parseFloat(p), (c = parseFloat(c)) && (p += c = parseFloat(c), D += c), D || p ? (D *= En, p *= En, n = Math.cos(D) * d, r = Math.sin(D) * d, i = Math.sin(D - p) * -g, u = Math.cos(D - p) * g, p && (c *= En, s = Math.tan(p - c), i *= s = Math.sqrt(1 + s * s), u *= s, c && (s = Math.tan(c), n *= s = Math.sqrt(1 + s * s), r *= s)), n = xt(n), r = xt(r), i = xt(i), u = xt(u)) : (n = d, u = g, r = i = 0), (F && !~(h + "").indexOf("px") || w && !~(f + "").indexOf("px")) && (F = rr(_, "x", h, "px"), w = rr(_, "y", f, "px")), (m || v || y || C) && (F = xt(F + m - (m * n + v * i) + y), w = xt(w + v - (m * r + v * u) + C)), (a || l) && (s = _.getBBox(), F = xt(F + a / 100 * s.width), w = xt(w + l / 100 * s.height)), s = "matrix(" + n + "," + r + "," + i + "," + u + "," + F + "," + w + ")", _.setAttribute("transform", s), x && (_.style[Vn] = s);
    },
    Cr = function Cr(t, e, n, r, i, u) {
      var s,
        o,
        a = X(i),
        l = parseFloat(i) * (a && ~i.indexOf("rad") ? wn : 1),
        h = u ? l * u : l - r,
        f = r + h + "deg";
      return a && ("short" === (s = i.split("_")[1]) && (h %= 360) !== h % 180 && (h += h < 0 ? 360 : -360), "cw" === s && h < 0 ? h = (h + 36e9) % 360 - 360 * ~~(h / 360) : "ccw" === s && h > 0 && (h = (h - 36e9) % 360 - 360 * ~~(h / 360))), t._pt = o = new hn(t._pt, e, n, r, h, Pn), o.e = f, o.u = "deg", t._props.push(n), o;
    },
    xr = function xr(t, e, n) {
      var r,
        i,
        u,
        s,
        o,
        a,
        l,
        h = yn.style,
        f = n._gsap;
      for (i in h.cssText = getComputedStyle(n).cssText + ";position:absolute;display:block;", h[Vn] = e, gn.body.appendChild(yn), r = dr(yn, 1), Fn) (u = f[i]) !== (s = r[i]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(i) < 0 && (o = te(u) !== (l = te(s)) ? rr(n, i, u, l) : parseFloat(u), a = parseFloat(s), t._pt = new hn(t._pt, f, i, o, a - o, Sn), t._pt.u = l || 0, t._props.push(i));
      gn.body.removeChild(yn);
    };
  Ct("padding,margin,Width,Radius", function (t, e) {
    var n = "Top",
      r = "Right",
      i = "Bottom",
      u = "Left",
      s = (e < 3 ? [n, r, i, u] : [n + u, n + r, i + r, i + u]).map(function (n) {
        return e < 2 ? t + n : "border" + n + t;
      });
    ar[e > 1 ? "border" + t : t] = function (t, e, n, r, i) {
      var u, o;
      if (arguments.length < 4) return u = s.map(function (e) {
        return ir(t, e, n);
      }), 5 === (o = u.join(" ")).split(u[0]).length ? u[0] : o;
      u = (r + "").split(" "), o = {}, s.forEach(function (t, e) {
        return o[t] = u[e] = u[e] || u[(e - 1) / 2 | 0];
      }), t.init(e, o, i);
    };
  });
  var Fr,
    wr,
    Er = {
      name: "css",
      register: Qn,
      targetTest: function targetTest(t) {
        return t.style && t.nodeType;
      },
      init: function init(t, e, n, r, i) {
        var u,
          s,
          o,
          a,
          l,
          h,
          f,
          D,
          p,
          c,
          d,
          g,
          _,
          m,
          v,
          y,
          C,
          x,
          F,
          w = this._props,
          E = t.style;
        for (f in mn || Qn(), e) if ("autoRound" !== f && (s = e[f], !pt[f] || !Ue(f, e, n, r, t, i))) if (l = _typeof(s), h = ar[f], "function" === l && (l = _typeof(s = s.call(n, r, t, i))), "string" === l && ~s.indexOf("random(") && (s = fe(s)), h) h(this, t, f, s, n) && (v = 1);else if ("--" === f.substr(0, 2)) this.add(E, "setProperty", getComputedStyle(t).getPropertyValue(f) + "", s + "", r, i, 0, 0, f);else if ("undefined" !== l) {
          if (u = ir(t, f), a = parseFloat(u), (c = "string" === l && "=" === s.charAt(1) ? +(s.charAt(0) + "1") : 0) && (s = s.substr(2)), o = parseFloat(s), f in On && ("autoAlpha" === f && (1 === a && "hidden" === ir(t, "visibility") && o && (a = 0), er(this, E, "visibility", a ? "inherit" : "hidden", o ? "inherit" : "hidden", !o)), "scale" !== f && "transform" !== f && ~(f = On[f]).indexOf(",") && (f = f.split(",")[0])), d = f in Fn) {
            if (g || ((_ = t._gsap).renderTransform || dr(t), m = !1 !== e.smoothOrigin && _.smooth, (g = this._pt = new hn(this._pt, E, Vn, 0, 1, _.renderTransform, _, 0, -1)).dep = 1), "scale" === f) this._pt = new hn(this._pt, _, "scaleY", _.scaleY, c ? c * o : o - _.scaleY), w.push("scaleY", f), f += "X";else {
              if ("transformOrigin" === f) {
                C = void 0, x = void 0, F = void 0, C = (y = s).split(" "), x = C[0], F = C[1] || "50%", "top" !== x && "bottom" !== x && "left" !== F && "right" !== F || (y = x, x = F, F = y), C[0] = sr[x] || x, C[1] = sr[F] || F, s = C.join(" "), _.svg ? cr(t, s, 0, m, 0, this) : ((p = parseFloat(s.split(" ")[2]) || 0) !== _.zOrigin && er(this, _, "zOrigin", _.zOrigin, p), er(this, E, f, gr(u), gr(s)));
                continue;
              }
              if ("svgOrigin" === f) {
                cr(t, s, 1, m, 0, this);
                continue;
              }
              if (f in hr) {
                Cr(this, _, f, a, s, c);
                continue;
              }
              if ("smoothOrigin" === f) {
                er(this, _, "smooth", _.smooth, s);
                continue;
              }
              if ("force3D" === f) {
                _[f] = s;
                continue;
              }
              if ("transform" === f) {
                xr(this, s, t);
                continue;
              }
            }
          } else f in E || (f = Hn(f) || f);
          if (d || (o || 0 === o) && (a || 0 === a) && !Mn.test(s) && f in E) o || (o = 0), (D = (u + "").substr((a + "").length)) !== (p = te(s) || (f in P.units ? P.units[f] : D)) && (a = rr(t, f, u, p)), this._pt = new hn(this._pt, d ? _ : E, f, a, c ? c * o : o - a, "px" !== p || !1 === e.autoRound || d ? Sn : kn), this._pt.u = p || 0, D !== p && (this._pt.b = u, this._pt.r = Bn);else if (f in E) ur.call(this, t, f, u, s);else {
            if (!(f in t)) {
              st(f, s);
              continue;
            }
            this.add(t, f, t[f], s, r, i);
          }
          w.push(f);
        }
        v && ln(this);
      },
      get: ir,
      aliases: On,
      getSetter: function getSetter(t, e, n) {
        var r = On[e];
        return r && r.indexOf(",") < 0 && (e = r), e in Fn && e !== Un && (t._gsap.x || ir(t, "x")) ? n && Cn === n ? "scale" === e ? Yn : zn : (Cn = n || {}) && ("scale" === e ? Xn : jn) : t.style && !U(t.style[e]) ? Rn : ~e.indexOf("-") ? In : tn(t, e);
      },
      core: {
        _removeProperty: tr,
        _getMatrix: pr
      }
    };
  cn.utils.checkPrefix = Hn, wr = Ct("x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + (Fr = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", function (t) {
    Fn[t] = 1;
  }), Ct(Fr, function (t) {
    P.units[t] = "deg", hr[t] = 1;
  }), On[wr[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + Fr, Ct("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", function (t) {
    var e = t.split(":");
    On[e[1]] = wr[e[0]];
  }), Ct("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (t) {
    P.units[t] = "px";
  }), cn.registerPlugin(Er);
  var br,
    Tr,
    Ar,
    Mr = cn.registerPlugin(Er) || cn,
    Or = Mr.core.Tween,
    Sr = function Sr() {
      return br || "undefined" != typeof window && (br = window.gsap) && br.registerPlugin && br;
    },
    Pr = function Pr(t) {
      br = Sr(), (Ar = br && br.parseEase("_CE")) ? (Tr = 1, br.parseEase("bounce").config = function (t) {
        return "object" == _typeof(t) ? kr("", t) : kr("bounce(" + t + ")", {
          strength: +t
        });
      }) : t && console.warn("Please gsap.registerPlugin(CustomEase, CustomBounce)");
    },
    Br = function Br(t) {
      var e,
        n = t.length,
        r = 1 / t[n - 2];
      for (e = 2; e < n; e += 2) t[e] = ~~(t[e] * r * 1e3) / 1e3;
      t[n - 2] = 1;
    },
    kr = function kr(t, e) {
      Tr || Pr(1), e = e || {};
      var n,
        r,
        i,
        u,
        s,
        o,
        a,
        l = Math.min(.999, e.strength || .7),
        h = l,
        f = (e.squash || 0) / 100,
        D = f,
        p = 1 / .03,
        c = .2,
        d = 1,
        g = .1,
        _ = [0, 0, .07, 0, .1, 1, .1, 1],
        m = [0, 0, 0, 0, .1, 0, .1, 0];
      for (s = 0; s < 200 && (o = g + (c *= h * ((h + 1) / 2)), u = 1 - (d *= l * l), r = (i = g + .49 * c) + .8 * (i - (n = g + d / p)), f && (g += f, n += f, i += f, r += f, o += f, a = f / D, m.push(g - f, 0, g - f, a, g - f / 2, a, g, a, g, 0, g, 0, g, -.6 * a, g + (o - g) / 6, 0, o, 0), _.push(g - f, 1, g, 1, g, 1), f *= l * l), _.push(g, 1, n, u, i, u, r, u, o, 1, o, 1), l *= .95, p = d / (o - r), g = o, !(u > .999)); s++);
      if (e.endAtStart && "false" !== e.endAtStart) {
        if (i = -.1, _.unshift(i, 1, i, 1, -.07, 0), D) for (i -= f = 2.5 * D, _.unshift(i, 1, i, 1, i, 1), m.splice(0, 6), m.unshift(i, 0, i, 0, i, 1, i + f / 2, 1, i + f, 1, i + f, 0, i + f, 0, i + f, -.6, i + f + .033, 0), s = 0; s < m.length; s += 2) m[s] -= i;
        for (s = 0; s < _.length; s += 2) _[s] -= i, _[s + 1] = 1 - _[s + 1];
      }
      return f && (Br(m), m[2] = "C" + m[2], Ar(e.squashID || t + "-squash", "M" + m.join(","))), Br(_), _[2] = "C" + _[2], Ar(t, "M" + _.join(","));
    },
    Lr = function () {
      function t(t, e) {
        this.ease = kr(t, e);
      }
      return t.create = function (t, e) {
        return kr(t, e);
      }, t.register = function (t) {
        br = t, Pr();
      }, t;
    }();
  /*!
   * CustomBounce 3.5.1
   * https://greensock.com
   *
   * @license Copyright 2008-2020, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  Sr() && br.registerPlugin(Lr), Lr.version = "3.5.1";
  /*!
   * paths 3.5.1
   * https://greensock.com
   *
   * Copyright 2008-2020, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  var Nr = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
    Rr = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
    Ir = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/gi,
    zr = /(^[#\.][a-z]|[a-y][a-z])/i,
    Yr = Math.PI / 180,
    Xr = 180 / Math.PI,
    jr = Math.sin,
    Vr = Math.cos,
    Ur = Math.abs,
    Wr = Math.sqrt,
    qr = Math.atan2,
    Gr = function Gr(t) {
      return "string" == typeof t;
    },
    Hr = function Hr(t) {
      return "number" == typeof t;
    },
    Qr = {},
    Kr = {},
    Zr = function Zr(t) {
      return Math.round((t + 1e8) % 1 * 1e5) / 1e5 || (t < 0 ? 0 : 1);
    },
    $r = function $r(t) {
      return Math.round(1e5 * t) / 1e5 || 0;
    },
    Jr = function Jr(t, e, n, r) {
      var i = t[e],
        u = 1 === r ? 6 : hi(i, n, r);
      if (u && u + n + 2 < i.length) return t.splice(e, 0, i.slice(0, n + u + 2)), i.splice(0, n + u), 1;
    },
    ti = function ti(t, e) {
      return e.totalLength = t.totalLength, t.samples ? (e.samples = t.samples.slice(0), e.lookup = t.lookup.slice(0), e.minLength = t.minLength, e.resolution = t.resolution) : e.totalPoints = t.totalPoints, e;
    },
    ei = function ei(t, e) {
      var n = t.length,
        r = t[n - 1] || [],
        i = r.length;
      e[0] === r[i - 2] && e[1] === r[i - 1] && (e = r.concat(e.slice(2)), n--), t[n] = e;
    };
  function ni(t) {
    var e,
      n = (t = Gr(t) && zr.test(t) && document.querySelector(t) || t).getAttribute ? t : 0;
    return n && (t = t.getAttribute("d")) ? (n._gsPath || (n._gsPath = {}), (e = n._gsPath[t]) && !e._dirty ? e : n._gsPath[t] = di(t)) : t ? Gr(t) ? di(t) : Hr(t[0]) ? [t] : t : console.warn("Expecting a <path> element or an SVG path data string");
  }
  function ri(t) {
    var e,
      n = 0;
    for (t.reverse(); n < t.length; n += 2) e = t[n], t[n] = t[n + 1], t[n + 1] = e;
    t.reversed = !t.reversed;
  }
  var ii = {
    rect: "rx,ry,x,y,width,height",
    circle: "r,cx,cy",
    ellipse: "rx,ry,cx,cy",
    line: "x1,x2,y1,y2"
  };
  function ui(t, e) {
    var n,
      r,
      i,
      u,
      s,
      o,
      a,
      l,
      h,
      f,
      D,
      p,
      c,
      d,
      g,
      _,
      m,
      v,
      y,
      C,
      x,
      F,
      w = t.tagName.toLowerCase(),
      E = .552284749831;
    return "path" !== w && t.getBBox ? (o = function (t, e) {
      var n,
        r = document.createElementNS("http://www.w3.org/2000/svg", "path"),
        i = [].slice.call(t.attributes),
        u = i.length;
      for (e = "," + e + ","; --u > -1;) n = i[u].nodeName.toLowerCase(), e.indexOf("," + n + ",") < 0 && r.setAttributeNS(null, n, i[u].nodeValue);
      return r;
    }(t, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points"), F = function (t, e) {
      for (var n = e ? e.split(",") : [], r = {}, i = n.length; --i > -1;) r[n[i]] = +t.getAttribute(n[i]) || 0;
      return r;
    }(t, ii[w]), "rect" === w ? (u = F.rx, s = F.ry || u, r = F.x, i = F.y, f = F.width - 2 * u, D = F.height - 2 * s, n = u || s ? "M" + (_ = (d = (c = r + u) + f) + u) + "," + (v = i + s) + " V" + (y = v + D) + " C" + [_, C = y + s * E, g = d + u * E, x = y + s, d, x, d - (d - c) / 3, x, c + (d - c) / 3, x, c, x, p = r + u * (1 - E), x, r, C, r, y, r, y - (y - v) / 3, r, v + (y - v) / 3, r, v, r, m = i + s * (1 - E), p, i, c, i, c + (d - c) / 3, i, d - (d - c) / 3, i, d, i, g, i, _, m, _, v].join(",") + "z" : "M" + (r + f) + "," + i + " v" + D + " h" + -f + " v" + -D + " h" + f + "z") : "circle" === w || "ellipse" === w ? ("circle" === w ? l = (u = s = F.r) * E : (u = F.rx, l = (s = F.ry) * E), n = "M" + ((r = F.cx) + u) + "," + (i = F.cy) + " C" + [r + u, i + l, r + (a = u * E), i + s, r, i + s, r - a, i + s, r - u, i + l, r - u, i, r - u, i - l, r - a, i - s, r, i - s, r + a, i - s, r + u, i - l, r + u, i].join(",") + "z") : "line" === w ? n = "M" + F.x1 + "," + F.y1 + " L" + F.x2 + "," + F.y2 : "polyline" !== w && "polygon" !== w || (n = "M" + (r = (h = (t.getAttribute("points") + "").match(Rr) || []).shift()) + "," + (i = h.shift()) + " L" + h.join(","), "polygon" === w && (n += "," + r + "," + i + "z")), o.setAttribute("d", mi(o._gsRawPath = di(n))), e && t.parentNode && (t.parentNode.insertBefore(o, t), t.parentNode.removeChild(t)), o) : t;
  }
  function si(t, e, n) {
    var r,
      i = t[e],
      u = t[e + 2],
      s = t[e + 4];
    return i += (u - i) * n, i += ((u += (s - u) * n) - i) * n, r = u + (s + (t[e + 6] - s) * n - u) * n - i, i = t[e + 1], i += ((u = t[e + 3]) - i) * n, i += ((u += ((s = t[e + 5]) - u) * n) - i) * n, $r(qr(u + (s + (t[e + 7] - s) * n - u) * n - i, r) * Xr);
  }
  function oi(t, e, n) {
    void 0 === n && (n = 1);
    var r = (e = e || 0) > n,
      i = Math.max(0, ~~(Ur(n - e) - 1e-8));
    if (r && (r = n, n = e, e = r, r = 1, i -= i ? 1 : 0), e < 0 || n < 0) {
      var u = 1 + ~~Math.min(e, n);
      e += u, n += u;
    }
    var s,
      o,
      a,
      l,
      h,
      f,
      D,
      p = function (t) {
        for (var e = [], n = 0; n < t.length; n++) e[n] = ti(t[n], t[n].slice(0));
        return ti(t, e);
      }(t.totalLength ? t : li(t)),
      c = n > 1,
      d = fi(p, e, Qr, !0),
      g = fi(p, n, Kr),
      _ = g.segment,
      m = d.segment,
      v = g.segIndex,
      y = d.segIndex,
      C = g.i,
      x = d.i,
      F = y === v,
      w = C === x && F,
      E = F && x > C || w && d.t > g.t;
    if (c || i) {
      if (Jr(p, y, x, d.t) && (s = 1, y++, w ? E ? g.t /= d.t : (g.t = (g.t - d.t) / (1 - d.t), v++, C = 0) : y <= v + 1 && !E && (v++, F && (C -= x))), g.t ? Jr(p, v, C, g.t) && (E && s && y++, r && v++) : (v--, r && y--), l = [], f = 1 + (h = p.length) * i, D = y, r) for (f += (h - (v = (v || h) - 1) + y) % h, a = 0; a < f; a++) ei(l, p[D]), D = (D || h) - 1;else for (f += (h - y + v) % h, a = 0; a < f; a++) ei(l, p[D++ % h]);
      p = l;
    } else if (o = 1 === g.t ? 6 : hi(_, C, g.t), e !== n) for (s = hi(m, x, w ? d.t / g.t : d.t), F && (o += s), _.splice(C + o + 2), (s || x) && m.splice(0, x + s), a = p.length; a--;) (a < y || a > v) && p.splice(a, 1);else _.angle = si(_, C + o, 0), d = _[C += o], g = _[C + 1], _.length = _.totalLength = 0, _.totalPoints = p.totalPoints = 8, _.push(d, g, d, g, d, g, d, g);
    return r && function (t, e) {
      var n = t.length;
      for (e || t.reverse(); n--;) t[n].reversed || ri(t[n]);
    }(p, c || i), p.totalLength = 0, p;
  }
  function ai(t, e, n) {
    e = e || 0, t.samples || (t.samples = [], t.lookup = []);
    var r,
      i,
      u,
      s,
      o,
      a,
      l,
      h,
      f,
      D,
      p,
      c,
      d,
      g,
      _,
      m,
      v,
      y = ~~t.resolution || 12,
      C = 1 / y,
      x = n ? e + 6 * n + 1 : t.length,
      F = t[e],
      w = t[e + 1],
      E = e ? e / 6 * y : 0,
      b = t.samples,
      T = t.lookup,
      A = (e ? t.minLength : 1e8) || 1e8,
      M = b[E + n * y - 1],
      O = e ? b[E - 1] : 0;
    for (b.length = T.length = 0, i = e + 2; i < x; i += 6) {
      if (u = t[i + 4] - F, s = t[i + 2] - F, o = t[i] - F, h = t[i + 5] - w, f = t[i + 3] - w, D = t[i + 1] - w, a = l = p = c = 0, Ur(u) < 1e-5 && Ur(h) < 1e-5 && Ur(o) + Ur(D) < 1e-5) t.length > 8 && (t.splice(i, 6), i -= 6, x -= 6);else for (r = 1; r <= y; r++) a = l - (l = ((g = C * r) * g * u + 3 * (d = 1 - g) * (g * s + d * o)) * g), p = c - (c = (g * g * h + 3 * d * (g * f + d * D)) * g), (m = Wr(p * p + a * a)) < A && (A = m), O += m, b[E++] = O;
      F += u, w += h;
    }
    if (M) for (M -= O; E < b.length; E++) b[E] += M;
    if (b.length && A) for (t.totalLength = v = b[b.length - 1] || 0, t.minLength = A, m = _ = 0, r = 0; r < v; r += A) T[m++] = b[_] < r ? ++_ : _;else t.totalLength = b[0] = 0;
    return e ? O - b[e / 2 - 1] : O;
  }
  function li(t, e) {
    var n, r, i;
    for (i = n = r = 0; i < t.length; i++) t[i].resolution = ~~e || 12, r += t[i].length, n += ai(t[i]);
    return t.totalPoints = r, t.totalLength = n, t;
  }
  function hi(t, e, n) {
    if (n <= 0 || n >= 1) return 0;
    var r = t[e],
      i = t[e + 1],
      u = t[e + 2],
      s = t[e + 3],
      o = t[e + 4],
      a = t[e + 5],
      l = r + (u - r) * n,
      h = u + (o - u) * n,
      f = i + (s - i) * n,
      D = s + (a - s) * n,
      p = l + (h - l) * n,
      c = f + (D - f) * n,
      d = o + (t[e + 6] - o) * n,
      g = a + (t[e + 7] - a) * n;
    return h += (d - h) * n, D += (g - D) * n, t.splice(e + 2, 4, $r(l), $r(f), $r(p), $r(c), $r(p + (h - p) * n), $r(c + (D - c) * n), $r(h), $r(D), $r(d), $r(g)), t.samples && t.samples.splice(e / 6 * t.resolution | 0, 0, 0, 0, 0, 0, 0, 0), 6;
  }
  function fi(t, e, n, r) {
    n = n || {}, t.totalLength || li(t), (e < 0 || e > 1) && (e = Zr(e));
    var i,
      u,
      s,
      o,
      a,
      l,
      h,
      f = 0,
      D = t[0];
    if (t.length > 1) {
      for (s = t.totalLength * e, a = l = 0; (a += t[l++].totalLength) < s;) f = l;
      e = (s - (o = a - (D = t[f]).totalLength)) / (a - o) || 0;
    }
    return i = D.samples, u = D.resolution, s = D.totalLength * e, o = (l = D.lookup[~~(s / D.minLength)] || 0) ? i[l - 1] : 0, (a = i[l]) < s && (o = a, a = i[++l]), h = 1 / u * ((s - o) / (a - o) + l % u), l = 6 * ~~(l / u), r && 1 === h && (l + 6 < D.length ? (l += 6, h = 0) : f + 1 < t.length && (l = h = 0, D = t[++f])), n.t = h, n.i = l, n.path = t, n.segment = D, n.segIndex = f, n;
  }
  function Di(t, e, n, r) {
    var i,
      u,
      s,
      o,
      a,
      l,
      h,
      f,
      D,
      p = t[0],
      c = r || {};
    if ((e < 0 || e > 1) && (e = Zr(e)), t.length > 1) {
      for (s = t.totalLength * e, a = l = 0; (a += t[l++].totalLength) < s;) p = t[l];
      e = (s - (o = a - p.totalLength)) / (a - o) || 0;
    }
    return i = p.samples, u = p.resolution, s = p.totalLength * e, o = (l = p.lookup[~~(s / p.minLength)] || 0) ? i[l - 1] : 0, (a = i[l]) < s && (o = a, a = i[++l]), D = 1 - (h = 1 / u * ((s - o) / (a - o) + l % u) || 0), f = p[l = 6 * ~~(l / u)], c.x = $r((h * h * (p[l + 6] - f) + 3 * D * (h * (p[l + 4] - f) + D * (p[l + 2] - f))) * h + f), c.y = $r((h * h * (p[l + 7] - (f = p[l + 1])) + 3 * D * (h * (p[l + 5] - f) + D * (p[l + 3] - f))) * h + f), n && (c.angle = p.totalLength ? si(p, l, h >= 1 ? 1 - 1e-9 : h || 1e-9) : p.angle || 0), c;
  }
  function pi(t, e, n, r, i, u, s) {
    for (var o, a, l, h, f, D = t.length; --D > -1;) for (a = (o = t[D]).length, l = 0; l < a; l += 2) h = o[l], f = o[l + 1], o[l] = h * e + f * r + u, o[l + 1] = h * n + f * i + s;
    return t._dirty = 1, t;
  }
  function ci(t, e, n, r, i, u, s, o, a) {
    if (t !== o || e !== a) {
      n = Ur(n), r = Ur(r);
      var l = i % 360 * Yr,
        h = Vr(l),
        f = jr(l),
        D = Math.PI,
        p = 2 * D,
        c = (t - o) / 2,
        d = (e - a) / 2,
        g = h * c + f * d,
        _ = -f * c + h * d,
        m = g * g,
        v = _ * _,
        y = m / (n * n) + v / (r * r);
      y > 1 && (n = Wr(y) * n, r = Wr(y) * r);
      var C = n * n,
        x = r * r,
        F = (C * x - C * v - x * m) / (C * v + x * m);
      F < 0 && (F = 0);
      var w = (u === s ? -1 : 1) * Wr(F),
        E = w * (n * _ / r),
        b = w * (-r * g / n),
        T = (t + o) / 2 + (h * E - f * b),
        A = (e + a) / 2 + (f * E + h * b),
        M = (g - E) / n,
        O = (_ - b) / r,
        S = (-g - E) / n,
        P = (-_ - b) / r,
        B = M * M + O * O,
        k = (O < 0 ? -1 : 1) * Math.acos(M / Wr(B)),
        L = (M * P - O * S < 0 ? -1 : 1) * Math.acos((M * S + O * P) / Wr(B * (S * S + P * P)));
      isNaN(L) && (L = D), !s && L > 0 ? L -= p : s && L < 0 && (L += p), k %= p, L %= p;
      var N,
        R = Math.ceil(Ur(L) / (p / 4)),
        I = [],
        z = L / R,
        Y = 4 / 3 * jr(z / 2) / (1 + Vr(z / 2)),
        X = h * n,
        j = f * n,
        V = f * -r,
        U = h * r;
      for (N = 0; N < R; N++) g = Vr(i = k + N * z), _ = jr(i), M = Vr(i += z), O = jr(i), I.push(g - Y * _, _ + Y * g, M + Y * O, O - Y * M, M, O);
      for (N = 0; N < I.length; N += 2) g = I[N], _ = I[N + 1], I[N] = g * X + _ * V + T, I[N + 1] = g * j + _ * U + A;
      return I[N - 2] = o, I[N - 1] = a, I;
    }
  }
  function di(t) {
    var e,
      n,
      r,
      i,
      u,
      s,
      o,
      a,
      l,
      h,
      f,
      D,
      p,
      c,
      d,
      g = (t + "").replace(Ir, function (t) {
        var e = +t;
        return e < 1e-4 && e > -1e-4 ? 0 : e;
      }).match(Nr) || [],
      _ = [],
      m = 0,
      v = 0,
      y = g.length,
      C = 0,
      x = "ERROR: malformed path: " + t,
      F = function F(t, e, n, r) {
        h = (n - t) / 3, f = (r - e) / 3, o.push(t + h, e + f, n - h, r - f, n, r);
      };
    if (!t || !isNaN(g[0]) || isNaN(g[1])) return console.log(x), _;
    for (e = 0; e < y; e++) if (p = u, isNaN(g[e]) ? s = (u = g[e].toUpperCase()) !== g[e] : e--, r = +g[e + 1], i = +g[e + 2], s && (r += m, i += v), e || (a = r, l = i), "M" === u) o && (o.length < 8 ? _.length -= 1 : C += o.length), m = a = r, v = l = i, o = [r, i], _.push(o), e += 2, u = "L";else if ("C" === u) o || (o = [0, 0]), s || (m = v = 0), o.push(r, i, m + 1 * g[e + 3], v + 1 * g[e + 4], m += 1 * g[e + 5], v += 1 * g[e + 6]), e += 6;else if ("S" === u) h = m, f = v, "C" !== p && "S" !== p || (h += m - o[o.length - 4], f += v - o[o.length - 3]), s || (m = v = 0), o.push(h, f, r, i, m += 1 * g[e + 3], v += 1 * g[e + 4]), e += 4;else if ("Q" === u) h = m + 2 / 3 * (r - m), f = v + 2 / 3 * (i - v), s || (m = v = 0), m += 1 * g[e + 3], v += 1 * g[e + 4], o.push(h, f, m + 2 / 3 * (r - m), v + 2 / 3 * (i - v), m, v), e += 4;else if ("T" === u) h = m - o[o.length - 4], f = v - o[o.length - 3], o.push(m + h, v + f, r + 2 / 3 * (m + 1.5 * h - r), i + 2 / 3 * (v + 1.5 * f - i), m = r, v = i), e += 2;else if ("H" === u) F(m, v, m = r, v), e += 1;else if ("V" === u) F(m, v, m, v = r + (s ? v - m : 0)), e += 1;else if ("L" === u || "Z" === u) "Z" === u && (r = a, i = l, o.closed = !0), ("L" === u || Ur(m - r) > .5 || Ur(v - i) > .5) && (F(m, v, r, i), "L" === u && (e += 2)), m = r, v = i;else if ("A" === u) {
      if (c = g[e + 4], d = g[e + 5], h = g[e + 6], f = g[e + 7], n = 7, c.length > 1 && (c.length < 3 ? (f = h, h = d, n--) : (f = d, h = c.substr(2), n -= 2), d = c.charAt(1), c = c.charAt(0)), D = ci(m, v, +g[e + 1], +g[e + 2], +g[e + 3], +c, +d, (s ? m : 0) + 1 * h, (s ? v : 0) + 1 * f), e += n, D) for (n = 0; n < D.length; n++) o.push(D[n]);
      m = o[o.length - 2], v = o[o.length - 1];
    } else console.log(x);
    return (e = o.length) < 6 ? (_.pop(), e = 0) : o[0] === o[e - 2] && o[1] === o[e - 1] && (o.closed = !0), _.totalPoints = C + e, _;
  }
  function gi(t, e) {
    void 0 === e && (e = 1);
    for (var n = t[0], r = 0, i = [n, r], u = 2; u < t.length; u += 2) i.push(n, r, t[u], r = (t[u] - n) * e / 2, n = t[u], -r);
    return i;
  }
  function _i(t, e, n) {
    var r,
      i,
      u,
      s,
      o,
      a,
      l,
      h,
      f,
      D,
      p,
      c,
      d,
      g,
      _ = t.length - 2,
      m = +t[0],
      v = +t[1],
      y = +t[2],
      C = +t[3],
      x = [m, v, m, v],
      F = y - m,
      w = C - v,
      E = Math.abs(t[_] - m) < .001 && Math.abs(t[_ + 1] - v) < .001;
    for (isNaN(n) && (n = Math.PI / 10), E && (t.push(y, C), y = m, C = v, m = t[_ - 2], v = t[_ - 1], t.unshift(m, v), _ += 4), e = e || 0 === e ? +e : 1, o = 2; o < _; o += 2) r = m, i = v, m = y, v = C, c = (a = F) * a + (h = w) * h, d = (F = (y = +t[o + 2]) - m) * F + (w = (C = +t[o + 3]) - v) * w, g = (l = y - r) * l + (f = C - i) * f, p = (u = Math.acos((c + d - g) / Wr(4 * c * d))) / Math.PI * e, D = Wr(c) * p, p *= Wr(d), m === r && v === i || (u > n ? (s = qr(f, l), x.push($r(m - Vr(s) * D), $r(v - jr(s) * D), $r(m), $r(v), $r(m + Vr(s) * p), $r(v + jr(s) * p))) : (s = qr(h, a), x.push($r(m - Vr(s) * D), $r(v - jr(s) * D)), s = qr(w, F), x.push($r(m), $r(v), $r(m + Vr(s) * p), $r(v + jr(s) * p))));
    return x.push($r(y), $r(C), $r(y), $r(C)), E && (x.splice(0, 6), x.length = x.length - 6), x;
  }
  function mi(t) {
    Hr(t[0]) && (t = [t]);
    var e,
      n,
      r,
      i,
      u = "",
      s = t.length;
    for (n = 0; n < s; n++) {
      for (i = t[n], u += "M" + $r(i[0]) + "," + $r(i[1]) + " C", e = i.length, r = 2; r < e; r++) u += $r(i[r++]) + "," + $r(i[r++]) + " " + $r(i[r++]) + "," + $r(i[r++]) + " " + $r(i[r++]) + "," + $r(i[r]) + " ";
      i.closed && (u += "z");
    }
    return u;
  }
  /*!
   * CustomEase 3.5.1
   * https://greensock.com
   *
   * @license Copyright 2008-2020, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  var vi,
    yi,
    Ci = function Ci() {
      return vi || "undefined" != typeof window && (vi = window.gsap) && vi.registerPlugin && vi;
    },
    xi = function xi() {
      (vi = Ci()) ? (vi.registerEase("_CE", Ti.create), yi = 1) : console.warn("Please gsap.registerPlugin(CustomEase)");
    },
    Fi = function Fi(t) {
      return ~~(1e3 * t + (t < 0 ? -.5 : .5)) / 1e3;
    },
    wi = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi,
    Ei = /[cLlsSaAhHvVtTqQ]/g,
    bi = function t(e, n, r, i, u, s, o, a, l, h, f) {
      var D,
        p = (e + r) / 2,
        c = (n + i) / 2,
        d = (r + u) / 2,
        g = (i + s) / 2,
        _ = (u + o) / 2,
        m = (s + a) / 2,
        v = (p + d) / 2,
        y = (c + g) / 2,
        C = (d + _) / 2,
        x = (g + m) / 2,
        F = (v + C) / 2,
        w = (y + x) / 2,
        E = o - e,
        b = a - n,
        T = Math.abs((r - o) * b - (i - a) * E),
        A = Math.abs((u - o) * b - (s - a) * E);
      return h || (h = [{
        x: e,
        y: n
      }, {
        x: o,
        y: a
      }], f = 1), h.splice(f || h.length - 1, 0, {
        x: F,
        y: w
      }), (T + A) * (T + A) > l * (E * E + b * b) && (D = h.length, t(e, n, p, c, v, y, F, w, l, h, f), t(F, w, C, x, _, m, o, a, l, h, f + 1 + (h.length - D))), h;
    },
    Ti = function () {
      function t(t, e, n) {
        yi || xi(), this.id = t, this.setData(e, n);
      }
      var e = t.prototype;
      return e.setData = function (t, e) {
        e = e || {};
        var n,
          r,
          i,
          u,
          s,
          o,
          a,
          l,
          h,
          f = (t = t || "0,0,1,1").match(wi),
          D = 1,
          p = [],
          c = [],
          d = e.precision || 1,
          g = d <= 1;
        if (this.data = t, (Ei.test(t) || ~t.indexOf("M") && t.indexOf("C") < 0) && (f = di(t)[0]), 4 === (n = f.length)) f.unshift(0, 0), f.push(1, 1), n = 8;else if ((n - 2) % 6) throw "Invalid CustomEase";
        for (0 == +f[0] && 1 == +f[n - 2] || function (t, e, n) {
          n || 0 === n || (n = Math.max(+t[t.length - 1], +t[1]));
          var r,
            i = -1 * +t[0],
            u = -n,
            s = t.length,
            o = 1 / (+t[s - 2] + i),
            a = -e || (Math.abs(+t[s - 1] - +t[1]) < .01 * (+t[s - 2] - +t[0]) ? function (t) {
              var e,
                n = t.length,
                r = 1e20;
              for (e = 1; e < n; e += 6) +t[e] < r && (r = +t[e]);
              return r;
            }(t) + u : +t[s - 1] + u);
          for (a = a ? 1 / a : -o, r = 0; r < s; r += 2) t[r] = (+t[r] + i) * o, t[r + 1] = (+t[r + 1] + u) * a;
        }(f, e.height, e.originY), this.segment = f, u = 2; u < n; u += 6) r = {
          x: +f[u - 2],
          y: +f[u - 1]
        }, i = {
          x: +f[u + 4],
          y: +f[u + 5]
        }, p.push(r, i), bi(r.x, r.y, +f[u], +f[u + 1], +f[u + 2], +f[u + 3], i.x, i.y, 1 / (2e5 * d), p, p.length - 1);
        for (n = p.length, u = 0; u < n; u++) a = p[u], l = p[u - 1] || a, (a.x > l.x || l.y !== a.y && l.x === a.x || a === l) && a.x <= 1 ? (l.cx = a.x - l.x, l.cy = a.y - l.y, l.n = a, l.nx = a.x, g && u > 1 && Math.abs(l.cy / l.cx - p[u - 2].cy / p[u - 2].cx) > 2 && (g = 0), l.cx < D && (l.cx ? D = l.cx : (l.cx = .001, u === n - 1 && (l.x -= .001, D = Math.min(D, .001), g = 0)))) : (p.splice(u--, 1), n--);
        if (s = 1 / (n = 1 / D + 1 | 0), o = 0, a = p[0], g) {
          for (u = 0; u < n; u++) h = u * s, a.nx < h && (a = p[++o]), r = a.y + (h - a.x) / a.cx * a.cy, c[u] = {
            x: h,
            cx: s,
            y: r,
            cy: 0,
            nx: 9
          }, u && (c[u - 1].cy = r - c[u - 1].y);
          c[n - 1].cy = p[p.length - 1].y - r;
        } else {
          for (u = 0; u < n; u++) a.nx < u * s && (a = p[++o]), c[u] = a;
          o < p.length - 1 && (c[u - 1] = p[p.length - 2]);
        }
        return this.ease = function (t) {
          var e = c[t * n | 0] || c[n - 1];
          return e.nx < t && (e = e.n), e.y + (t - e.x) / e.cx * e.cy;
        }, this.ease.custom = this, this.id && vi.registerEase(this.id, this.ease), this;
      }, e.getSVGData = function (e) {
        return t.getSVGData(this, e);
      }, t.create = function (e, n, r) {
        return new t(e, n, r).ease;
      }, t.register = function (t) {
        vi = t, xi();
      }, t.get = function (t) {
        return vi.parseEase(t);
      }, t.getSVGData = function (e, n) {
        var r,
          i,
          u,
          s,
          o,
          a,
          l,
          h,
          f,
          D,
          p = (n = n || {}).width || 100,
          c = n.height || 100,
          d = n.x || 0,
          g = (n.y || 0) + c,
          _ = vi.utils.toArray(n.path)[0];
        if (n.invert && (c = -c, g = 0), "string" == typeof e && (e = vi.parseEase(e)), e.custom && (e = e.custom), e instanceof t) r = mi(pi([e.segment], p, 0, 0, -c, d, g));else {
          for (r = [d, g], s = 1 / (l = Math.max(5, 200 * (n.precision || 1))), h = 5 / (l += 2), f = Fi(d + s * p), i = ((D = Fi(g + e(s) * -c)) - g) / (f - d), u = 2; u < l; u++) o = Fi(d + u * s * p), a = Fi(g + e(u * s) * -c), (Math.abs((a - D) / (o - f) - i) > h || u === l - 1) && (r.push(f, D), i = (a - D) / (o - f)), f = o, D = a;
          r = "M" + r.join(",");
        }
        return _ && _.setAttribute("d", r), r;
      }, t;
    }();
  Ci() && vi.registerPlugin(Ti), Ti.version = "3.5.1";
  /*!
   * CustomWiggle 3.5.1
   * https://greensock.com
   *
   * @license Copyright 2008-2020, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  var Ai,
    Mi,
    Oi,
    Si = function Si() {
      return Ai || "undefined" != typeof window && (Ai = window.gsap) && Ai.registerPlugin && Ai;
    },
    Pi = {
      easeOut: "M0,1,C0.7,1,0.6,0,1,0",
      easeInOut: "M0,0,C0.1,0,0.24,1,0.444,1,0.644,1,0.6,0,1,0",
      anticipate: "M0,0,C0,0.222,0.024,0.386,0,0.4,0.18,0.455,0.65,0.646,0.7,0.67,0.9,0.76,1,0.846,1,1",
      uniform: "M0,0,C0,0.95,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0"
    },
    Bi = function Bi(t) {
      return t;
    },
    ki = function ki(t) {
      if (!Mi) if (Ai = Si(), Oi = Ai && Ai.parseEase("_CE")) {
        for (var e in Pi) Pi[e] = Oi("", Pi[e]);
        Mi = 1, Ni("wiggle").config = function (t) {
          return "object" == _typeof(t) ? Ni("", t) : Ni("wiggle(" + t + ")", {
            wiggles: +t
          });
        };
      } else t && console.warn("Please gsap.registerPlugin(CustomEase, CustomWiggle)");
    },
    Li = function Li(t, e) {
      return "function" != typeof t && (t = Ai.parseEase(t) || Oi("", t)), t.custom || !e ? t : function (e) {
        return 1 - t(e);
      };
    },
    Ni = function Ni(t, e) {
      Mi || ki(1);
      var n,
        r,
        i,
        u,
        s,
        o,
        a,
        l,
        h,
        f = 0 | ((e = e || {}).wiggles || 10),
        D = 1 / f,
        p = D / 2,
        c = "anticipate" === e.type,
        d = Pi[e.type] || Pi.easeOut,
        g = Bi;
      if (c && (g = d, d = Pi.easeOut), e.timingEase && (g = Li(e.timingEase)), e.amplitudeEase && (d = Li(e.amplitudeEase, !0)), l = [0, 0, (o = g(p)) / 4, 0, o / 2, a = c ? -d(p) : d(p), o, a], "random" === e.type) {
        for (l.length = 4, n = g(D), r = 2 * Math.random() - 1, h = 2; h < f; h++) p = n, a = r, n = g(D * h), r = 2 * Math.random() - 1, i = Math.atan2(r - l[l.length - 3], n - l[l.length - 4]), u = Math.cos(i) * D, s = Math.sin(i) * D, l.push(p - u, a - s, p, a, p + u, a + s);
        l.push(n, 0, 1, 0);
      } else {
        for (h = 1; h < f; h++) l.push(g(p + D / 2), a), p += D, a = (a > 0 ? -1 : 1) * d(h * D), o = g(p), l.push(g(p - D / 2), a, o, a);
        l.push(g(p + D / 4), a, g(p + D / 4), 0, 1, 0);
      }
      for (h = l.length; --h > -1;) l[h] = ~~(1e3 * l[h]) / 1e3;
      return l[2] = "C" + l[2], Oi(t, "M" + l.join(","));
    },
    Ri = function () {
      function t(t, e) {
        this.ease = Ni(t, e);
      }
      return t.create = function (t, e) {
        return Ni(t, e);
      }, t.register = function (t) {
        Ai = t, ki();
      }, t;
    }();
  Si() && Ai.registerPlugin(Ri), Ri.version = "3.5.1";
  /*!
   * DrawSVGPlugin 3.5.1
   * https://greensock.com
   *
   * @license Copyright 2008-2020, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  var Ii,
    zi,
    Yi,
    Xi,
    ji,
    Vi = function Vi() {
      return "undefined" != typeof window;
    },
    Ui = function Ui() {
      return Ii || Vi() && (Ii = window.gsap) && Ii.registerPlugin && Ii;
    },
    Wi = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi,
    qi = {
      rect: ["width", "height"],
      circle: ["r", "r"],
      ellipse: ["rx", "ry"],
      line: ["x2", "y2"]
    },
    Gi = function Gi(t) {
      return Math.round(1e4 * t) / 1e4;
    },
    Hi = function Hi(t) {
      return parseFloat(t || 0);
    },
    Qi = function Qi(t, e) {
      return Hi(t.getAttribute(e));
    },
    Ki = Math.sqrt,
    Zi = function Zi(t, e, n, r, i, u) {
      return Ki(Math.pow((Hi(n) - Hi(t)) * i, 2) + Math.pow((Hi(r) - Hi(e)) * u, 2));
    },
    $i = function $i(t) {
      return console.warn(t);
    },
    Ji = function Ji(t) {
      return "non-scaling-stroke" === t.getAttribute("vector-effect");
    },
    tu = function tu(t) {
      if (!(t = zi(t)[0])) return 0;
      var e,
        n,
        r,
        i,
        u,
        s,
        o,
        a = t.tagName.toLowerCase(),
        l = t.style,
        h = 1,
        f = 1;
      Ji(t) && (f = t.getScreenCTM(), h = Ki(f.a * f.a + f.b * f.b), f = Ki(f.d * f.d + f.c * f.c));
      try {
        n = t.getBBox();
      } catch (t) {
        $i("Some browsers won't measure invisible elements (like display:none or masks inside defs).");
      }
      var D = n || {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        },
        p = D.x,
        c = D.y,
        d = D.width,
        g = D.height;
      if (n && (d || g) || !qi[a] || (d = Qi(t, qi[a][0]), g = Qi(t, qi[a][1]), "rect" !== a && "line" !== a && (d *= 2, g *= 2), "line" === a && (p = Qi(t, "x1"), c = Qi(t, "y1"), d = Math.abs(d - p), g = Math.abs(g - c))), "path" === a) i = l.strokeDasharray, l.strokeDasharray = "none", e = t.getTotalLength() || 0, h !== f && $i("Warning: <path> length cannot be measured when vector-effect is non-scaling-stroke and the element isn't proportionally scaled."), e *= (h + f) / 2, l.strokeDasharray = i;else if ("rect" === a) e = 2 * d * h + 2 * g * f;else if ("line" === a) e = Zi(p, c, p + d, c + g, h, f);else if ("polyline" === a || "polygon" === a) for (r = t.getAttribute("points").match(Wi) || [], "polygon" === a && r.push(r[0], r[1]), e = 0, u = 2; u < r.length; u += 2) e += Zi(r[u - 2], r[u - 1], r[u], r[u + 1], h, f) || 0;else "circle" !== a && "ellipse" !== a || (s = d / 2 * h, o = g / 2 * f, e = Math.PI * (3 * (s + o) - Ki((3 * s + o) * (s + 3 * o))));
      return e || 0;
    },
    eu = function eu(t, e) {
      if (!(t = zi(t)[0])) return [0, 0];
      e || (e = tu(t) + 1);
      var n = Yi.getComputedStyle(t),
        r = n.strokeDasharray || "",
        i = Hi(n.strokeDashoffset),
        u = r.indexOf(",");
      return u < 0 && (u = r.indexOf(" ")), (r = u < 0 ? e : Hi(r.substr(0, u)) || 1e-5) > e && (r = e), [Math.max(0, -i), Math.max(0, r - i)];
    },
    nu = function nu() {
      Vi() && (document, Yi = window, ji = Ii = Ui(), zi = Ii.utils.toArray, Xi = -1 !== ((Yi.navigator || {}).userAgent || "").indexOf("Edge"));
    },
    ru = {
      version: "3.5.1",
      name: "drawSVG",
      register: function register(t) {
        Ii = t, nu();
      },
      init: function init(t, e, n, r, i) {
        if (!t.getBBox) return !1;
        ji || nu();
        var u,
          s,
          o,
          a,
          l = tu(t) + 1;
        return this._style = t.style, this._target = t, e + "" == "true" ? e = "0 100%" : e ? -1 === (e + "").indexOf(" ") && (e = "0 " + e) : e = "0 0", s = function (t, e, n) {
          var r,
            i,
            u = t.indexOf(" ");
          return u < 0 ? (r = void 0 !== n ? n + "" : t, i = t) : (r = t.substr(0, u), i = t.substr(u + 1)), (r = ~r.indexOf("%") ? Hi(r) / 100 * e : Hi(r)) > (i = ~i.indexOf("%") ? Hi(i) / 100 * e : Hi(i)) ? [i, r] : [r, i];
        }(e, l, (u = eu(t, l))[0]), this._length = Gi(l + 10), 0 === u[0] && 0 === s[0] ? (o = Math.max(1e-5, s[1] - l), this._dash = Gi(l + o), this._offset = Gi(l - u[1] + o), this._offsetPT = this.add(this, "_offset", this._offset, Gi(l - s[1] + o))) : (this._dash = Gi(u[1] - u[0]) || 1e-6, this._offset = Gi(-u[0]), this._dashPT = this.add(this, "_dash", this._dash, Gi(s[1] - s[0]) || 1e-5), this._offsetPT = this.add(this, "_offset", this._offset, Gi(-s[0]))), Xi && (a = Yi.getComputedStyle(t)).strokeLinecap !== a.strokeLinejoin && (s = Hi(a.strokeMiterlimit), this.add(t.style, "strokeMiterlimit", s, s + .01)), this._live = Ji(t) || ~(e + "").indexOf("live"), this._props.push("drawSVG"), 1;
      },
      render: function render(t, e) {
        var n,
          r,
          i,
          u,
          s = e._pt,
          o = e._style;
        if (s) {
          for (e._live && (n = tu(e._target) + 11) !== e._length && (r = n / e._length, e._length = n, e._offsetPT.s *= r, e._offsetPT.c *= r, e._dashPT ? (e._dashPT.s *= r, e._dashPT.c *= r) : e._dash *= r); s;) s.r(t, s.d), s = s._next;
          i = e._dash, u = e._offset, n = e._length, o.strokeDashoffset = e._offset, 1 !== t && t ? o.strokeDasharray = i + "px," + n + "px" : (i - u < .001 && n - i <= 10 && (o.strokeDashoffset = u + 1), o.strokeDasharray = u < .001 && n - i <= 10 ? "none" : u === i ? "0px, 999999px" : i + "px," + n + "px");
        }
      },
      getLength: tu,
      getPosition: eu
    };
  Ui() && Ii.registerPlugin(ru);
  /*!
   * matrix 3.5.1
   * https://greensock.com
   *
   * Copyright 2008-2020, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  var iu,
    uu,
    su,
    ou,
    au,
    lu,
    hu,
    fu,
    Du = "transform",
    pu = Du + "Origin",
    cu = function cu(t) {
      var e = t.ownerDocument || t;
      !(Du in t.style) && "msTransform" in t.style && (pu = (Du = "msTransform") + "Origin");
      for (; e.parentNode && (e = e.parentNode););
      if (uu = window, hu = new Cu(), e) {
        iu = e, su = e.documentElement, ou = e.body;
        var n = e.createElement("div"),
          r = e.createElement("div");
        ou.appendChild(n), n.appendChild(r), n.style.position = "static", n.style[Du] = "translate3d(0,0,1px)", fu = r.offsetParent !== n, ou.removeChild(n);
      }
      return e;
    },
    du = [],
    gu = [],
    _u = function _u(t) {
      return t.ownerSVGElement || ("svg" === (t.tagName + "").toLowerCase() ? t : null);
    },
    mu = function t(e, n) {
      if (e.parentNode && (iu || cu(e))) {
        var r = _u(e),
          i = r ? r.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml",
          u = r ? n ? "rect" : "g" : "div",
          s = 2 !== n ? 0 : 100,
          o = 3 === n ? 100 : 0,
          a = "position:absolute;display:block;pointer-events:none;",
          l = iu.createElementNS ? iu.createElementNS(i.replace(/^https/, "http"), u) : iu.createElement(u);
        return n && (r ? (lu || (lu = t(e)), l.setAttribute("width", .01), l.setAttribute("height", .01), l.setAttribute("transform", "translate(" + s + "," + o + ")"), lu.appendChild(l)) : (au || ((au = t(e)).style.cssText = a), l.style.cssText = a + "width:0.1px;height:0.1px;top:" + o + "px;left:" + s + "px", au.appendChild(l))), l;
      }
      throw "Need document and parent.";
    },
    vu = function vu(t, e) {
      var n,
        r,
        i,
        u,
        s,
        o = _u(t),
        a = t === o,
        l = o ? du : gu;
      if (t === uu) return t;
      if (l.length || l.push(mu(t, 1), mu(t, 2), mu(t, 3)), n = o ? lu : au, o) i = a ? {
        x: 0,
        y: 0
      } : t.getBBox(), (r = t.transform ? t.transform.baseVal : {}).numberOfItems ? (u = (r = r.numberOfItems > 1 ? function (t) {
        for (var e = new Cu(), n = 0; n < t.numberOfItems; n++) e.multiply(t.getItem(n).matrix);
        return e;
      }(r) : r.getItem(0).matrix).a * i.x + r.c * i.y, s = r.b * i.x + r.d * i.y) : (r = hu, u = i.x, s = i.y), e && "g" === t.tagName.toLowerCase() && (u = s = 0), n.setAttribute("transform", "matrix(" + r.a + "," + r.b + "," + r.c + "," + r.d + "," + (r.e + u) + "," + (r.f + s) + ")"), (a ? o : t.parentNode).appendChild(n);else {
        if (u = s = 0, fu) for (r = t.offsetParent, i = t; i && (i = i.parentNode) && i !== r && i.parentNode;) (uu.getComputedStyle(i)[Du] + "").length > 4 && (u = i.offsetLeft, s = i.offsetTop, i = 0);
        (i = n.style).top = t.offsetTop - s + "px", i.left = t.offsetLeft - u + "px", r = uu.getComputedStyle(t), i[Du] = r[Du], i[pu] = r[pu], i.border = r.border, i.borderLeftStyle = r.borderLeftStyle, i.borderTopStyle = r.borderTopStyle, i.borderLeftWidth = r.borderLeftWidth, i.borderTopWidth = r.borderTopWidth, i.position = "fixed" === r.position ? "fixed" : "absolute", t.parentNode.appendChild(n);
      }
      return n;
    },
    yu = function yu(t, e, n, r, i, u, s) {
      return t.a = e, t.b = n, t.c = r, t.d = i, t.e = u, t.f = s, t;
    },
    Cu = function () {
      function t(t, e, n, r, i, u) {
        void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === r && (r = 1), void 0 === i && (i = 0), void 0 === u && (u = 0), yu(this, t, e, n, r, i, u);
      }
      var e = t.prototype;
      return e.inverse = function () {
        var t = this.a,
          e = this.b,
          n = this.c,
          r = this.d,
          i = this.e,
          u = this.f,
          s = t * r - e * n || 1e-10;
        return yu(this, r / s, -e / s, -n / s, t / s, (n * u - r * i) / s, -(t * u - e * i) / s);
      }, e.multiply = function (t) {
        var e = this.a,
          n = this.b,
          r = this.c,
          i = this.d,
          u = this.e,
          s = this.f,
          o = t.a,
          a = t.c,
          l = t.b,
          h = t.d,
          f = t.e,
          D = t.f;
        return yu(this, o * e + l * r, o * n + l * i, a * e + h * r, a * n + h * i, u + f * e + D * r, s + f * n + D * i);
      }, e.clone = function () {
        return new t(this.a, this.b, this.c, this.d, this.e, this.f);
      }, e.equals = function (t) {
        var e = this.a,
          n = this.b,
          r = this.c,
          i = this.d,
          u = this.e,
          s = this.f;
        return e === t.a && n === t.b && r === t.c && i === t.d && u === t.e && s === t.f;
      }, e.apply = function (t, e) {
        void 0 === e && (e = {});
        var n = t.x,
          r = t.y,
          i = this.a,
          u = this.b,
          s = this.c,
          o = this.d,
          a = this.e,
          l = this.f;
        return e.x = n * i + r * s + a || 0, e.y = n * u + r * o + l || 0, e;
      }, t;
    }();
  function xu(t, e, n) {
    if (!t || !t.parentNode || (iu || cu(t)).documentElement === t) return new Cu();
    var r = function (t) {
        for (var e, n; t && t !== ou;) (n = t._gsap) && !n.scaleX && !n.scaleY && n.renderTransform && (n.scaleX = n.scaleY = 1e-4, n.renderTransform(1, n), e ? e.push(n) : e = [n]), t = t.parentNode;
        return e;
      }(t.parentNode),
      i = _u(t) ? du : gu,
      u = vu(t, n),
      s = i[0].getBoundingClientRect(),
      o = i[1].getBoundingClientRect(),
      a = i[2].getBoundingClientRect(),
      l = u.parentNode,
      h = function t(e) {
        return "fixed" === uu.getComputedStyle(e).position || ((e = e.parentNode) && 1 === e.nodeType ? t(e) : void 0);
      }(t),
      f = new Cu((o.left - s.left) / 100, (o.top - s.top) / 100, (a.left - s.left) / 100, (a.top - s.top) / 100, s.left + (h ? 0 : uu.pageXOffset || iu.scrollLeft || su.scrollLeft || ou.scrollLeft || 0), s.top + (h ? 0 : uu.pageYOffset || iu.scrollTop || su.scrollTop || ou.scrollTop || 0));
    if (l.removeChild(u), r) for (s = r.length; s--;) (o = r[s]).scaleX = o.scaleY = 0, o.renderTransform(1, o);
    return e ? f.inverse() : f;
  }
  /*!
   * MotionPathPlugin 3.5.1
   * https://greensock.com
   *
   * @license Copyright 2008-2020, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  var Fu,
    wu,
    Eu,
    bu,
    Tu = ["x", "translateX", "left", "marginLeft"],
    Au = ["y", "translateY", "top", "marginTop"],
    Mu = Math.PI / 180,
    Ou = function Ou(t, e, n, r) {
      for (var i = e.length, u = 2 === r ? 0 : r, s = 0; s < i; s++) t[u] = parseFloat(e[s][n]), 2 === r && (t[u + 1] = 0), u += 2;
      return t;
    },
    Su = function Su(t, e, n) {
      return parseFloat(t._gsap.get(t, e, n || "px")) || 0;
    },
    Pu = function Pu(t) {
      var e,
        n = t[0],
        r = t[1];
      for (e = 2; e < t.length; e += 2) n = t[e] += n, r = t[e + 1] += r;
    },
    Bu = function Bu(t, e, n, r, i, u, s) {
      "cubic" === s.type ? e = [e] : (e.unshift(Su(n, r, s.unitX), i ? Su(n, i, s.unitY) : 0), s.relative && Pu(e), e = [(i ? _i : gi)(e, s.curviness)]);
      return e = u(Iu(e, n, s)), zu(t, n, r, e, "x", s.unitX), i && zu(t, n, i, e, "y", s.unitY), li(e, s.resolution || (0 === s.curviness ? 20 : 12));
    },
    ku = function ku(t) {
      return t;
    },
    Lu = /[-+\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/g,
    Nu = function Nu(t, e, n) {
      var r,
        i,
        u,
        s = xu(t);
      return "svg" === (t.tagName + "").toLowerCase() ? (i = (r = t.viewBox.baseVal).x, u = r.y, r.width || (r = {
        width: +t.getAttribute("width"),
        height: +t.getAttribute("height")
      })) : (r = e && t.getBBox && t.getBBox(), i = u = 0), e && "auto" !== e && (i += e.push ? e[0] * (r ? r.width : t.offsetWidth || 0) : e.x, u += e.push ? e[1] * (r ? r.height : t.offsetHeight || 0) : e.y), n.apply(i || u ? s.apply({
        x: i,
        y: u
      }) : {
        x: s.e,
        y: s.f
      });
    },
    Ru = function Ru(t, e, n, r) {
      var i,
        u = xu(t.parentNode, !0, !0),
        s = u.clone().multiply(xu(e)),
        o = Nu(t, n, u),
        a = Nu(e, r, u),
        l = a.x,
        h = a.y;
      return s.e = s.f = 0, "auto" === r && e.getTotalLength && "path" === e.tagName.toLowerCase() && (i = e.getAttribute("d").match(Lu) || [], l += (i = s.apply({
        x: +i[0],
        y: +i[1]
      })).x, h += i.y), (i || e.getBBox && t.getBBox && e.ownerSVGElement === t.ownerSVGElement) && (l -= (i = s.apply(e.getBBox())).x, h -= i.y), s.e = l - o.x, s.f = h - o.y, s;
    },
    Iu = function Iu(t, e, n) {
      var r,
        i,
        u,
        s = n.align,
        o = n.matrix,
        a = n.offsetX,
        l = n.offsetY,
        h = n.alignOrigin,
        f = t[0][0],
        D = t[0][1],
        p = Su(e, "x"),
        c = Su(e, "y");
      return t && t.length ? (s && ("self" === s || (r = bu(s)[0] || e) === e ? pi(t, 1, 0, 0, 1, p - f, c - D) : (h && !1 !== h[2] ? Fu.set(e, {
        transformOrigin: 100 * h[0] + "% " + 100 * h[1] + "%"
      }) : h = [Su(e, "xPercent") / -100, Su(e, "yPercent") / -100], u = (i = Ru(e, r, h, "auto")).apply({
        x: f,
        y: D
      }), pi(t, i.a, i.b, i.c, i.d, p + i.e - (u.x - i.e), c + i.f - (u.y - i.f)))), o ? pi(t, o.a, o.b, o.c, o.d, o.e, o.f) : (a || l) && pi(t, 1, 0, 0, 1, a || 0, l || 0), t) : ni("M0,0L0,0");
    },
    zu = function zu(t, e, n, r, i, u) {
      var s = e._gsap,
        o = s.harness,
        a = o && o.aliases && o.aliases[n],
        l = a && a.indexOf(",") < 0 ? a : n,
        h = t._pt = new wu(t._pt, e, l, 0, 0, ku, 0, s.set(e, l, t));
      h.u = Eu(s.get(e, l, u)) || 0, h.path = r, h.pp = i, t._props.push(l);
    },
    Yu = {
      version: "3.5.1",
      name: "motionPath",
      register: function register(t, e, n) {
        Eu = (Fu = t).utils.getUnit, bu = Fu.utils.toArray, wu = n;
      },
      init: function init(t, e) {
        if (!Fu) return console.warn("Please gsap.registerPlugin(MotionPathPlugin)"), !1;
        "object" == _typeof(e) && !e.style && e.path || (e = {
          path: e
        });
        var n,
          r,
          i,
          u,
          s,
          o,
          a = [],
          l = e.path,
          h = l[0],
          f = e.autoRotate,
          D = (s = e.start, o = "end" in e ? e.end : 1, function (t) {
            return s || 1 !== o ? oi(t, s, o) : t;
          });
        if (this.rawPaths = a, this.target = t, (this.rotate = f || 0 === f) && (this.rOffset = parseFloat(f) || 0, this.radians = !!e.useRadians, this.rProp = e.rotation || "rotation", this.rSet = t._gsap.set(t, this.rProp, this), this.ru = Eu(t._gsap.get(t, this.rProp)) || 0), Array.isArray(l) && !("closed" in l) && "number" != typeof h) {
          for (r in h) ~Tu.indexOf(r) ? i = r : ~Au.indexOf(r) && (u = r);
          for (r in i && u ? a.push(Bu(this, Ou(Ou([], l, i, 0), l, u, 1), t, e.x || i, e.y || u, D, e)) : i = u = 0, h) r !== i && r !== u && a.push(Bu(this, Ou([], l, r, 2), t, r, 0, D, e));
        } else li(n = D(Iu(ni(e.path), t, e)), e.resolution), a.push(n), zu(this, t, e.x || "x", n, "x", e.unitX || "px"), zu(this, t, e.y || "y", n, "y", e.unitY || "px");
      },
      render: function render(t, e) {
        var n = e.rawPaths,
          r = n.length,
          i = e._pt;
        for (t > 1 ? t = 1 : t < 0 && (t = 0); r--;) Di(n[r], t, !r && e.rotate, n[r]);
        for (; i;) i.set(i.t, i.p, i.path[i.pp] + i.u, i.d, t), i = i._next;
        e.rotate && e.rSet(e.target, e.rProp, n[0].angle * (e.radians ? Mu : 1) + e.rOffset + e.ru, e, t);
      },
      getLength: function getLength(t) {
        return li(ni(t)).totalLength;
      },
      sliceRawPath: oi,
      getRawPath: ni,
      pointsToSegment: _i,
      stringToRawPath: di,
      rawPathToString: mi,
      transformRawPath: pi,
      getGlobalMatrix: xu,
      getPositionOnPath: Di,
      cacheRawPathMeasurements: li,
      convertToPath: function convertToPath(t, e) {
        return bu(t).map(function (t) {
          return ui(t, !1 !== e);
        });
      },
      convertCoordinates: function convertCoordinates(t, e, n) {
        var r = xu(e, !0, !0).multiply(xu(t));
        return n ? r.apply(n) : r;
      },
      getAlignMatrix: Ru,
      getRelativePosition: function getRelativePosition(t, e, n, r) {
        var i = Ru(t, e, n, r);
        return {
          x: i.e,
          y: i.f
        };
      },
      arrayToRawPath: function arrayToRawPath(t, e) {
        var n = Ou(Ou([], t, (e = e || {}).x || "x", 0), t, e.y || "y", 1);
        return e.relative && Pu(n), ["cubic" === e.type ? n : _i(n, e.curviness)];
      }
    };
  (Fu || "undefined" != typeof window && (Fu = window.gsap) && Fu.registerPlugin && Fu) && Fu.registerPlugin(Yu);
  /*!
   * ScrollToPlugin 3.5.1
   * https://greensock.com
   *
   * @license Copyright 2008-2020, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  var Xu,
    ju,
    Vu,
    Uu,
    Wu,
    qu,
    Gu,
    Hu = function Hu() {
      return "undefined" != typeof window;
    },
    Qu = function Qu() {
      return Xu || Hu() && (Xu = window.gsap) && Xu.registerPlugin && Xu;
    },
    Ku = function Ku(t) {
      return "string" == typeof t;
    },
    Zu = function Zu(t, e) {
      var n = "x" === e ? "Width" : "Height",
        r = "scroll" + n,
        i = "client" + n;
      return t === Vu || t === Uu || t === Wu ? Math.max(Uu[r], Wu[r]) - (Vu["inner" + n] || Uu[i] || Wu[i]) : t[r] - t["offset" + n];
    },
    $u = function $u(t, e) {
      var n = "scroll" + ("x" === e ? "Left" : "Top");
      return t === Vu && (null != t.pageXOffset ? n = "page" + e.toUpperCase() + "Offset" : t = null != Uu[n] ? Uu : Wu), function () {
        return t[n];
      };
    },
    Ju = function Ju(t, e) {
      var n = qu(t)[0].getBoundingClientRect(),
        r = !e || e === Vu || e === Wu,
        i = r ? {
          top: Uu.clientTop - (Vu.pageYOffset || Uu.scrollTop || Wu.scrollTop || 0),
          left: Uu.clientLeft - (Vu.pageXOffset || Uu.scrollLeft || Wu.scrollLeft || 0)
        } : e.getBoundingClientRect(),
        u = {
          x: n.left - i.left,
          y: n.top - i.top
        };
      return !r && e && (u.x += $u(e, "x")(), u.y += $u(e, "y")()), u;
    },
    ts = function ts(t, e, n, r, i) {
      return isNaN(t) || "object" == _typeof(t) ? Ku(t) && "=" === t.charAt(1) ? parseFloat(t.substr(2)) * ("-" === t.charAt(0) ? -1 : 1) + r - i : "max" === t ? Zu(e, n) - i : Math.min(Zu(e, n), Ju(t, e)[n] - i) : parseFloat(t) - i;
    },
    es = function es() {
      Xu = Qu(), Hu() && Xu && document.body && (Vu = window, Wu = document.body, Uu = document.documentElement, qu = Xu.utils.toArray, Xu.config({
        autoKillThreshold: 7
      }), Gu = Xu.config(), ju = 1);
    },
    ns = {
      version: "3.5.1",
      name: "scrollTo",
      rawVars: 1,
      register: function register(t) {
        Xu = t, es();
      },
      init: function init(t, e, n, r, i) {
        ju || es();
        this.isWin = t === Vu, this.target = t, this.tween = n, "object" != _typeof(e) ? Ku((e = {
          y: e
        }).y) && "max" !== e.y && "=" !== e.y.charAt(1) && (e.x = e.y) : e.nodeType && (e = {
          y: e,
          x: e
        }), this.vars = e, this.autoKill = !!e.autoKill, this.getX = $u(t, "x"), this.getY = $u(t, "y"), this.x = this.xPrev = this.getX(), this.y = this.yPrev = this.getY(), null != e.x ? (this.add(this, "x", this.x, ts(e.x, t, "x", this.x, e.offsetX || 0), r, i, Math.round), this._props.push("scrollTo_x")) : this.skipX = 1, null != e.y ? (this.add(this, "y", this.y, ts(e.y, t, "y", this.y, e.offsetY || 0), r, i, Math.round), this._props.push("scrollTo_y")) : this.skipY = 1;
      },
      render: function render(t, e) {
        for (var n, r, i, u, s, o = e._pt, a = e.target, l = e.tween, h = e.autoKill, f = e.xPrev, D = e.yPrev, p = e.isWin; o;) o.r(t, o.d), o = o._next;
        n = p || !e.skipX ? e.getX() : f, i = (r = p || !e.skipY ? e.getY() : D) - D, u = n - f, s = Gu.autoKillThreshold, e.x < 0 && (e.x = 0), e.y < 0 && (e.y = 0), h && (!e.skipX && (u > s || u < -s) && n < Zu(a, "x") && (e.skipX = 1), !e.skipY && (i > s || i < -s) && r < Zu(a, "y") && (e.skipY = 1), e.skipX && e.skipY && (l.kill(), e.vars.onAutoKill && e.vars.onAutoKill.apply(l, e.vars.onAutoKillParams || []))), p ? Vu.scrollTo(e.skipX ? n : e.x, e.skipY ? r : e.y) : (e.skipY || (a.scrollTop = e.y), e.skipX || (a.scrollLeft = e.x)), e.xPrev = e.x, e.yPrev = e.y;
      },
      kill: function kill(t) {
        var e = "scrollTo" === t;
        (e || "scrollTo_x" === t) && (this.skipX = 1), (e || "scrollTo_y" === t) && (this.skipY = 1);
      }
    };
  ns.max = Zu, ns.getOffset = Ju, ns.buildGetter = $u, Qu() && Xu.registerPlugin(ns);
  /*!
   * strings: 3.5.1
   * https://greensock.com
   *
   * Copyright 2008-2020, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  var rs = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;
  /*!
   * SplitText: 3.5.1
   * https://greensock.com
   *
   * @license Copyright 2008-2020, GreenSock. All rights reserved.
   * Subject to the terms at https://greensock.com/standard-license or for
   * Club GreenSock members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  */
  var is,
    us,
    ss,
    os,
    as = /(?:\r|\n|\t\t)/g,
    ls = /(?:\s\s+)/g,
    hs = function hs(t) {
      return us.getComputedStyle(t);
    },
    fs = Array.isArray,
    Ds = [].slice,
    ps = function ps(t, e) {
      var n;
      return fs(t) ? t : "string" == (n = _typeof(t)) && !e && t ? Ds.call(is.querySelectorAll(t), 0) : t && "object" === n && "length" in t ? Ds.call(t, 0) : t ? [t] : [];
    },
    cs = function cs(t) {
      return "absolute" === t.position || !0 === t.absolute;
    },
    ds = function ds(t, e) {
      for (var n, r = e.length; --r > -1;) if (n = e[r], t.substr(0, n.length) === n) return n.length;
    },
    gs = function gs(t, e) {
      void 0 === t && (t = "");
      var n = ~t.indexOf("++"),
        r = 1;
      return n && (t = t.split("++").join("")), function () {
        return "<" + e + " style='position:relative;display:inline-block;'" + (t ? " class='" + t + (n ? r++ : "") + "'>" : ">");
      };
    },
    _s = function t(e, n, r) {
      var i = e.nodeType;
      if (1 === i || 9 === i || 11 === i) for (e = e.firstChild; e; e = e.nextSibling) t(e, n, r);else 3 !== i && 4 !== i || (e.nodeValue = e.nodeValue.split(n).join(r));
    },
    ms = function ms(t, e) {
      for (var n = e.length; --n > -1;) t.push(e[n]);
    },
    vs = function vs(t, e, n) {
      for (var r; t && t !== e;) {
        if (r = t._next || t.nextSibling) return r.textContent.charAt(0) === n;
        t = t.parentNode || t._parent;
      }
    },
    ys = function t(e) {
      var n,
        r,
        i = ps(e.childNodes),
        u = i.length;
      for (n = 0; n < u; n++) (r = i[n])._isSplit ? t(r) : (n && 3 === r.previousSibling.nodeType ? r.previousSibling.nodeValue += 3 === r.nodeType ? r.nodeValue : r.firstChild.nodeValue : 3 !== r.nodeType && e.insertBefore(r.firstChild, r), e.removeChild(r));
    },
    Cs = function Cs(t, e) {
      return parseFloat(e[t]) || 0;
    },
    xs = function xs(t, e, n, r, i, u, s) {
      var o,
        a,
        l,
        h,
        f,
        D,
        p,
        c,
        d,
        g,
        _,
        m,
        v = hs(t),
        y = Cs("paddingLeft", v),
        C = -999,
        x = Cs("borderBottomWidth", v) + Cs("borderTopWidth", v),
        F = Cs("borderLeftWidth", v) + Cs("borderRightWidth", v),
        w = Cs("paddingTop", v) + Cs("paddingBottom", v),
        E = Cs("paddingLeft", v) + Cs("paddingRight", v),
        b = Cs("fontSize", v) * (e.lineThreshold || .2),
        T = v.textAlign,
        A = [],
        M = [],
        O = [],
        S = e.wordDelimiter || " ",
        P = e.tag ? e.tag : e.span ? "span" : "div",
        B = e.type || e.split || "chars,words,lines",
        k = i && ~B.indexOf("lines") ? [] : null,
        L = ~B.indexOf("words"),
        N = ~B.indexOf("chars"),
        R = cs(e),
        I = e.linesClass,
        z = ~(I || "").indexOf("++"),
        Y = [];
      for (z && (I = I.split("++").join("")), l = (a = t.getElementsByTagName("*")).length, f = [], o = 0; o < l; o++) f[o] = a[o];
      if (k || R) for (o = 0; o < l; o++) ((D = (h = f[o]).parentNode === t) || R || N && !L) && (m = h.offsetTop, k && D && Math.abs(m - C) > b && ("BR" !== h.nodeName || 0 === o) && (p = [], k.push(p), C = m), R && (h._x = h.offsetLeft, h._y = m, h._w = h.offsetWidth, h._h = h.offsetHeight), k && ((h._isSplit && D || !N && D || L && D || !L && h.parentNode.parentNode === t && !h.parentNode._isSplit) && (p.push(h), h._x -= y, vs(h, t, S) && (h._wordEnd = !0)), "BR" === h.nodeName && (h.nextSibling && "BR" === h.nextSibling.nodeName || 0 === o) && k.push([])));
      for (o = 0; o < l; o++) D = (h = f[o]).parentNode === t, "BR" !== h.nodeName ? (R && (d = h.style, L || D || (h._x += h.parentNode._x, h._y += h.parentNode._y), d.left = h._x + "px", d.top = h._y + "px", d.position = "absolute", d.display = "block", d.width = h._w + 1 + "px", d.height = h._h + "px"), !L && N ? h._isSplit ? (h._next = h.nextSibling, h.parentNode.appendChild(h)) : h.parentNode._isSplit ? (h._parent = h.parentNode, !h.previousSibling && h.firstChild && (h.firstChild._isFirst = !0), h.nextSibling && " " === h.nextSibling.textContent && !h.nextSibling.nextSibling && Y.push(h.nextSibling), h._next = h.nextSibling && h.nextSibling._isFirst ? null : h.nextSibling, h.parentNode.removeChild(h), f.splice(o--, 1), l--) : D || (m = !h.nextSibling && vs(h.parentNode, t, S), h.parentNode._parent && h.parentNode._parent.appendChild(h), m && h.parentNode.appendChild(is.createTextNode(" ")), "span" === P && (h.style.display = "inline"), A.push(h)) : h.parentNode._isSplit && !h._isSplit && "" !== h.innerHTML ? M.push(h) : N && !h._isSplit && ("span" === P && (h.style.display = "inline"), A.push(h))) : k || R ? (h.parentNode && h.parentNode.removeChild(h), f.splice(o--, 1), l--) : L || t.appendChild(h);
      for (o = Y.length; --o > -1;) Y[o].parentNode.removeChild(Y[o]);
      if (k) {
        for (R && (g = is.createElement(P), t.appendChild(g), _ = g.offsetWidth + "px", m = g.offsetParent === t ? 0 : t.offsetLeft, t.removeChild(g)), d = t.style.cssText, t.style.cssText = "display:none;"; t.firstChild;) t.removeChild(t.firstChild);
        for (c = " " === S && (!R || !L && !N), o = 0; o < k.length; o++) {
          for (p = k[o], (g = is.createElement(P)).style.cssText = "display:block;text-align:" + T + ";position:" + (R ? "absolute;" : "relative;"), I && (g.className = I + (z ? o + 1 : "")), O.push(g), l = p.length, a = 0; a < l; a++) "BR" !== p[a].nodeName && (h = p[a], g.appendChild(h), c && h._wordEnd && g.appendChild(is.createTextNode(" ")), R && (0 === a && (g.style.top = h._y + "px", g.style.left = y + m + "px"), h.style.top = "0px", m && (h.style.left = h._x - m + "px")));
          0 === l ? g.innerHTML = "&nbsp;" : L || N || (ys(g), _s(g, String.fromCharCode(160), " ")), R && (g.style.width = _, g.style.height = h._h + "px"), t.appendChild(g);
        }
        t.style.cssText = d;
      }
      R && (s > t.clientHeight && (t.style.height = s - w + "px", t.clientHeight < s && (t.style.height = s + x + "px")), u > t.clientWidth && (t.style.width = u - E + "px", t.clientWidth < u && (t.style.width = u + F + "px"))), ms(n, A), L && ms(r, M), ms(i, O);
    },
    Fs = function Fs(t, e, n, r) {
      var i,
        u,
        s,
        o,
        a,
        l,
        h,
        f,
        D = e.tag ? e.tag : e.span ? "span" : "div",
        p = ~(e.type || e.split || "chars,words,lines").indexOf("chars"),
        c = cs(e),
        d = e.wordDelimiter || " ",
        g = " " !== d ? "" : c ? "&#173; " : " ",
        _ = "</" + D + ">",
        m = 1,
        v = e.specialChars ? "function" == typeof e.specialChars ? e.specialChars : ds : null,
        y = is.createElement("div"),
        C = t.parentNode;
      for (C.insertBefore(y, t), y.textContent = t.nodeValue, C.removeChild(t), h = -1 !== (i = function t(e) {
        var n = e.nodeType,
          r = "";
        if (1 === n || 9 === n || 11 === n) {
          if ("string" == typeof e.textContent) return e.textContent;
          for (e = e.firstChild; e; e = e.nextSibling) r += t(e);
        } else if (3 === n || 4 === n) return e.nodeValue;
        return r;
      }(t = y)).indexOf("<"), !1 !== e.reduceWhiteSpace && (i = i.replace(ls, " ").replace(as, "")), h && (i = i.split("<").join("{{LT}}")), a = i.length, u = (" " === i.charAt(0) ? g : "") + n(), s = 0; s < a; s++) if (l = i.charAt(s), v && (f = v(i.substr(s), e.specialChars))) l = i.substr(s, f || 1), u += p && " " !== l ? r() + l + "</" + D + ">" : l, s += f - 1;else if (l === d && i.charAt(s - 1) !== d && s) {
        for (u += m ? _ : "", m = 0; i.charAt(s + 1) === d;) u += g, s++;
        s === a - 1 ? u += g : ")" !== i.charAt(s + 1) && (u += g + n(), m = 1);
      } else "{" === l && "{{LT}}" === i.substr(s, 6) ? (u += p ? r() + "{{LT}}</" + D + ">" : "{{LT}}", s += 5) : l.charCodeAt(0) >= 55296 && l.charCodeAt(0) <= 56319 || i.charCodeAt(s + 1) >= 65024 && i.charCodeAt(s + 1) <= 65039 ? (o = ((i.substr(s, 12).split(rs) || [])[1] || "").length || 2, u += p && " " !== l ? r() + i.substr(s, o) + "</" + D + ">" : i.substr(s, o), s += o - 1) : u += p && " " !== l ? r() + l + "</" + D + ">" : l;
      t.outerHTML = u + (m ? _ : ""), h && _s(C, "{{LT}}", "<");
    },
    ws = function t(e, n, r, i) {
      var u,
        s,
        o = ps(e.childNodes),
        a = o.length,
        l = cs(n);
      if (3 !== e.nodeType || a > 1) {
        for (n.absolute = !1, u = 0; u < a; u++) (3 !== (s = o[u]).nodeType || /\S+/.test(s.nodeValue)) && (l && 3 !== s.nodeType && "inline" === hs(s).display && (s.style.display = "inline-block", s.style.position = "relative"), s._isSplit = !0, t(s, n, r, i));
        return n.absolute = l, void (e._isSplit = !0);
      }
      Fs(e, n, r, i);
    },
    Es = function () {
      function t(t, e) {
        ss || (is = document, us = window, ss = 1), this.elements = ps(t), this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = e || {}, this.split(e);
      }
      var e = t.prototype;
      return e.split = function (t) {
        this.isSplit && this.revert(), this.vars = t = t || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
        for (var e, n, r, i = this.elements.length, u = t.tag ? t.tag : t.span ? "span" : "div", s = gs(t.wordsClass, u), o = gs(t.charsClass, u); --i > -1;) r = this.elements[i], this._originals[i] = r.innerHTML, e = r.clientHeight, n = r.clientWidth, ws(r, t, s, o), xs(r, t, this.chars, this.words, this.lines, n, e);
        return this.chars.reverse(), this.words.reverse(), this.lines.reverse(), this.isSplit = !0, this;
      }, e.revert = function () {
        var t = this._originals;
        if (!t) throw "revert() call wasn't scoped properly.";
        return this.elements.forEach(function (e, n) {
          return e.innerHTML = t[n];
        }), this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this;
      }, t.create = function (e, n) {
        return new t(e, n);
      }, t;
    }();
  Es.version = "3.5.1", Mr.registerPlugin(Qe, Or, Ye, Ye, Lr, Ti, Ri, ru, Yu, ns, Er);
  var bs = os = window.punchgs = window.tpGS = {};
  for (var Ts in bs.gsap = Mr, bs.TweenLite = Qe, bs.TweenMax = Or, bs.TimelineLite = Ye, bs.TimelineMax = Ye, bs.CustomBounce = Lr, bs.CustomEase = Ti, bs.CustomWiggle = Ri, bs.DrawSVGPlugin = ru, bs.MotionPathPlugin = Yu, bs.ScrollToPlugin = ns, bs.CSSPlugin = Er, /*! Map SplitText to tpGS TPGSSPLITTEXT */
  bs.SplitText = Es, bs.RAD2DEG = 180 / Math.PI, bs.DEG2RAD = Math.PI / 180, /*! REGISTER MOTION PATH (BEZIER) */
  bs.gsap.registerPlugin(bs.MotionPathPlugin), bs.gsap.config({
    nullTargetWarn: !1
  }), /*!FallBack for old and new Eases*/
  bs.eases = bs.gsap.parseEase(), bs.eases) bs.eases.hasOwnProperty(Ts) && void 0 === bs[Ts] && (bs[Ts] = bs.eases[Ts])
  /*! FallBack for Essential Grid */;
  void 0 !== os && void 0 !== os.TweenLite && void 0 === os.TweenLite.lagSmoothing && (os.TweenLite.lagSmoothing = function () {});
  var As = [];
  function Ms(t, e, n) {
    var r = document.createElement("canvas"),
      i = r.getContext("2d");
    if (r.width = 100, r.height = 200, 0 === t.length) i.fillStyle = n;else {
      for (var u = i.createLinearGradient(0, 0, 100, 0), s = 0; s < t.length; s++) u.addColorStop(t[s].stop / 100, t[s].color);
      i.fillStyle = u;
    }
    i.fillRect(0, 0, 100, 200);
    var o = i.getImageData(0, 0, 100, 2).data,
      a = "";
    for (s = 0; s < e.length; s++) {
      var l = Math.ceil(e[s]),
        h = 4 * (0 !== l ? l - 1 : l);
      a += "rgba(" + o[h] + "," + o[h + 1] + "," + o[h + 2] + "," + o[h + 3] / 255 + ")", a += " " + l + (e.length - 1 === s ? "%" : "%,");
    }
    return r.remove(), a;
  }
  function Os(t, e, n, r) {
    for (var i = "", u = bs.gsap.utils.mapRange(0, r.length - 1, 0, t.length - 1), s = 0; s < r.length; s++) {
      var o = Math.round(u(s));
      i += t[o].color, i += " " + t[o].stop + (r.length - 1 === s ? "%" : "%,");
    }
    return i;
  }
  function Ss(t) {
    var e = /rgb([\s\S]*?)%/g,
      n = [],
      r = [],
      i = [];
    do {
      (s = e.exec(t)) && n.push(s[0]);
    } while (s);
    for (var u = 0; u < n.length; u++) {
      var s = n[u],
        o = (t = /rgb([\s\S]*?)\)/.exec(s), /\)([\s\S]*?)%/.exec(s));
      t[0] && (t = t[0]), o[1] && (o = o[1]), i.push(parseFloat(o)), r.push({
        color: t,
        stop: parseFloat(o)
      });
    }
    return 0 === r.length && (r.push({
      color: t,
      stop: 0
    }), i.push(0), r.push({
      color: t,
      stop: 100
    }), i.push(100)), {
      points: r,
      stops: i
    };
  }
  bs.getSSGColors = function (t, e, n) {
    if (n = void 0 === n ? "fading" : n, -1 === t.indexOf("gradient") && -1 === e.indexOf("gradient")) return {
      from: t,
      to: e
    };
    for (var r = {
        from: t,
        to: e
      }, i = 0; i < As.length; i++) {
      if (As[i].from === t && As[i].to === e && As[i].type === n) return {
        from: As[i].rFrom,
        to: As[i].rTo
      };
      if (As[i].from === e && As[i].to === t && As[i].type === n) return {
        from: As[i].rTo,
        to: As[i].rFrom
      };
    }
    var u = Ss(t),
      s = Ss(e);
    if (u.stops.length === s.stops.length && -1 !== t.indexOf("gradient") && -1 !== e.indexOf("gradient")) return {
      from: t,
      to: e
    };
    var o,
      a,
      l = u.stops;
    for (i = 0; i < s.stops.length; i++) -1 === l.indexOf(s.stops[i]) && l.push(s.stops[i]);
    if (l.sort(function (t, e) {
      return t - e;
    }), -1 !== t.indexOf("gradient(")) {
      var h = -1 !== t.indexOf("deg,") ? t.indexOf("deg,") + 4 : -1 !== t.indexOf("at center,") ? t.indexOf("at center,") + 10 : t.indexOf("gradient(") + 9;
      o = t.substring(0, h), -1 === e.indexOf("gradient(") && (a = t.substring(0, h));
    }
    if (-1 !== e.indexOf("gradient(")) {
      h = -1 !== e.indexOf("deg,") ? e.indexOf("deg,") + 4 : -1 !== e.indexOf("at center,") ? e.indexOf("at center,") + 10 : e.indexOf("gradient(") + 9;
      a = e.substring(0, h), -1 === t.indexOf("gradient(") && (o = e.substring(0, h));
    }
    return "fading" === n ? (u.stops.length, s.stops.length, o += Ms(u.points, l, t), a += Ms(s.points, l, e)) : "sliding" === n && (u.stops.length > s.stops.length ? a += Os(s.points, l, e, u.points) : o += Os(u.points, l, t, s.points)), o += ")", a += ")", "sliding" === n && (u.stops.length > s.stops.length ? o = t : a = e), r.rFrom = o, r.rTo = a, r.tyep = n, As.push(r), {
      from: o,
      to: a
    };
  };
}]);
window.RS_MODULES = window.RS_MODULES || {};
window.RS_MODULES.tpGS = {
  loaded: true,
  version: "6.4.11"
};
if (window.RS_MODULES.checkMinimal) window.RS_MODULES.checkMinimal();
/*!
  - Slider Revolution JavaScript Plugin -
..........................xXXXXX.................
................. xXXXXX..xXXXXX..xXXXXX.........
..................xXXXXX..xXXXXX..xXXXXX.........
..........xXXXXX..xXXXXX..xXXXXX..xXXXXX.........
..........xXXXXX..xXXXXX..xXXXXX..xXXXXX.........
..........xXXXXX..xXXXXX..xXXXXX..xXXXXX.........
..........xXXXXX..xXXXXX..xXXXXX..xXXXXX.........
..........xXXXXX..xXXXXX..xXXXXX..xXXXXX.........
.........,xXXXXX..xXXXXX..xXXXXX..xXXXXX.........
.........,xXXXXX..xXXXXX..xXXXXX..xXXXXX.........
.........,xXXXXX..xXXXXX..xXXXXX..xXXXXX.........
..........xXXXXX..xXXXXX..xXXXXX..xXXXXX.........
.....................xxxxxxxxxxxxxxxxxxx.........
.....................xxxxxxxxxxxxxxxxxxx.........
.....................xxxxxxxxxxxxxxxxxxx.........
			   DATE: 2021-07-01
	@author: Krisztian Horvath, ThemePunch OHG.
INTRODUCING GIT
UPDATES AND DOCS AT:
https://www.themepunch.com/support-center
GET LICENSE AT:
https://www.themepunch.com/links/slider_revolution_wordpress_regular_license
LICENSE:
Copyright (c) 2009-2019, ThemePunch. All rights reserved.
This work is subject to the terms at https://www.themepunch.com/links/slider_revolution_wordpress_regular_license (Regular / Extended)
*/
!function (e, i) {
  "use strict";

  var t = "Slider Revolution 6.5.4";
  window.RSANYID = window.RSANYID === i ? [] : window.RSANYID, window.RSANYID_sliderID = window.RSANYID_sliderID === i ? [] : window.RSANYID_sliderID, e.fn.revolution = e.fn.revolution || {};
  var a = e.fn.revolution;
  e.fn.revolutionInit = function (t) {
    return this.each(function () {
      a.ISM = a.ISM || a.is_mobile();
      for (var s = document.getElementsByClassName("rs-p-wp-fix"); s[0];) s[0].parentNode.removeChild(s[0]);
      this.id !== i ? (a[n] = {
        anyid: []
      }, this.id = a.revCheckIDS(n, this, !0)) : this.id = "rs_module_" + Math.round(1e7 * Math.random());
      var n = this.id,
        d = a.clone(t);
      a[n] = G(t), a[n].ignoreHeightChange = a.ISM && "fullscreen" === a[n].sliderLayout && a[n].ignoreHeightChange, a[n].option_export = d, a[n].anyid = [], a[n]._Lshortcuts = {}, a[n].computedStyle = {}, a[n].c = e(this), a[n].cpar = a[n].c.parent(), a[n].canvas = a[n].c.find("rs-slides"), a[n].caches = {
        calcResponsiveLayersList: [],
        contWidthManager: {}
      }, a[n].sbgs = {}, window.RSBrowser = window.RSBrowser === i ? a.get_browser() : window.RSBrowser, a.setIsIOS(), a.setIsChrome8889(), a[n].noDetach = a[n].BUG_ie_clipPath = "Edge" === window.RSBrowser || "IE" === window.RSBrowser, a.getByTag = r(), a[n].indexhelper = 0, a[n].fullScreenOffsetResult = 0, a[n].level = 0, a[n].rtl = e("body").hasClass("rtl"), a[n]._L = a[n]._L === i ? {} : a[n]._L, a[n].emptyObject = "{}", a[n].dimensionReCheck = {}, a.globalListener === i && a.pageHandler(n), a[n].stopAfterLoops != i && a[n].stopAfterLoops > -1 ? a[n].looptogo = a[n].stopAfterLoops : a[n].looptogo = "disabled", window.T = a[n], a[n].BUG_safari_clipPath = "Safari" === a.get_browser() && a.get_browser_version() > "12", a[n].minHeight = "fullwidth" === a[n].sliderLayout ? 0 : a[n].minHeight != i && "" !== a[n].minHeight ? parseInt(a[n].minHeight, 0) : 0, a[n].minHeight = a[n].minHeight === i ? 0 : a[n].minHeight, a[n].isEdge = "Edge" === a.get_browser(), o(n), a.updateVisibleArea(n), B(n), a.mesuredScrollBarDone || a.mesureScrollBar(), window.requestAnimationFrame(function () {
        if ("fullscreen" === a[n].sliderLayout) {
          var e = a.getFullscreenOffsets(n);
          0 !== e && a[n].cpar.height(a.getWinH(n) - e);
        }
        a[n].cpar[0].style.visibility = "visible";
      }), "hero" == a[n].sliderType && a[n].c.find("rs-slide").each(function (i) {
        i > 0 && e(this).remove();
      }), a[n].navigation.use = "hero" !== a[n].sliderType && ("carousel" == a[n].sliderType || a[n].navigation.keyboardNavigation || "on" == a[n].navigation.mouseScrollNavigation || "carousel" == a[n].navigation.mouseScrollNavigation || a[n].navigation.touch.touchenabled || a[n].navigation.arrows.enable || a[n].navigation.bullets.enable || a[n].navigation.thumbnails.enable || a[n].navigation.tabs.enable), a[n].c.find("rs-bgvideo").each(function () {
        "RS-BGVIDEO" !== this.tagName || this.id !== i && "" !== this.id || (this.id = "rs-bg-video-" + Math.round(1e6 * Math.random()));
      }), tpGS.force3D = "auto", !0 === a[n].modal.useAsModal && -1 === a.RS_prioList.indexOf(n) && (a.RS_toInit[n] = !1, a.RS_prioList.push(n)), a.RS_killedlist !== i && -1 !== a.RS_killedlist.indexOf(n) && (a.RS_toInit[n] = !1, a.RS_prioList.push(n)), !0 === a.RS_prioListFirstInit && !0 !== a[n].modal.useAsModal && -1 === a.RS_prioList.indexOf(n) && (a.RS_toInit[n] = !1, a.RS_prioList.push(n)), a.initNextRevslider(n);
    });
  };
  a = window.RS_F;
  e.fn.extend({
    getRSJASONOptions: function getRSJASONOptions(e) {
      console.log(JSON.stringify(a[e].option_export));
    },
    getRSVersion: function getRSVersion(e) {
      var i,
        t,
        a = window.SliderRevolutionVersion;
      if (!e) {
        for (var r in i = t = "---------------------------------------------------------\n", i += "    Currently Loaded Slider Revolution & SR Modules :\n" + t, a) a.hasOwnProperty(r) && (i += a[r].alias + ": " + a[r].ver + "\n");
        i += t;
      }
      return e ? a : i;
    },
    revremoveslide: function revremoveslide(i) {
      return this.each(function () {
        var t = this.id;
        if (!(i < 0 || i > a[t].slideamount) && a[t] && a[t].slides.length > 0 && (i > 0 || i <= a[t].slides.length)) {
          var r = a.gA(a[t].slides[i], "key");
          a[t].slideamount = a[t].slideamount - 1, a[t].realslideamount = a[t].realslideamount - 1, n("rs-bullet", r, t), n("rs-tab", r, t), n("rs-thumb", r, t), e(a[t].slides[i]).remove(), a[t].thumbs = s(a[t].thumbs, i), a.updateNavIndexes && a.updateNavIndexes(t), i <= a[t].pr_active_key && (a[t].pr_active_key = a[t].pr_active_key - 1);
        }
      });
    },
    revaddcallback: function revaddcallback(e) {
      return this.each(function () {
        a[this.id] && (a[this.id].callBackArray === i && (a[this.id].callBackArray = []), a[this.id].callBackArray.push(e));
      });
    },
    revgetparallaxproc: function revgetparallaxproc() {
      if (a[this[0].id]) return a[this[0].id].scrollproc;
    },
    revdebugmode: function revdebugmode() {},
    revscroll: function revscroll(i) {
      return this.each(function () {
        var t = e(this);
        e("body,html").animate({
          scrollTop: t.offset().top + t.height() - i + "px"
        }, {
          duration: 400
        });
      });
    },
    revredraw: function revredraw() {
      return this.each(function () {
        m(this.id, i, !0);
      });
    },
    revkill: function revkill() {
      return this.each(function () {
        var t = this.id;
        a[t].c.data("conthover", 1), a[t].c.data("conthoverchanged", 1), a[t].c.trigger("revolution.slide.onpause"), a[t].tonpause = !0, a[t].c.trigger("stoptimer"), a[t].sliderisrunning = !1;
        var r = "updateContainerSizes." + a[t].c.attr("id");
        a.window.unbind(r), tpGS.gsap.killTweensOf(a[t].c.find("*"), !1), tpGS.gsap.killTweensOf(a[t].c, !1), a[t].c.unbind("hover, mouseover, mouseenter,mouseleave, resize"), a[t].c.find("*").each(function () {
          var t = e(this);
          t.unbind("on, hover, mouseenter,mouseleave,mouseover, resize,restarttimer, stoptimer"), t.off("on, hover, mouseenter,mouseleave,mouseover, resize"), t.data("mySplitText", null), t.data("ctl", null), t.data("tween") != i && t.data("tween").kill(), t.data("pztl") != i && t.data("pztl").kill(), t.data("timeline_out") != i && t.data("timeline_out").kill(), t.data("timeline") != i && t.data("timeline").kill(), t.remove(), t.empty(), t = null;
        }), tpGS.gsap.killTweensOf(a[t].c.find("*"), !1), tpGS.gsap.killTweensOf(a[t].c, !1), a[t].progressC.remove();
        try {
          a[t].c.closest(".rev_slider_wrapper").detach();
        } catch (e) {}
        try {
          a[t].c.closest("rs-fullwidth-wrap").remove();
        } catch (e) {}
        try {
          a[t].c.closest("rs-module-wrap").remove();
        } catch (e) {}
        try {
          a[t].c.remove();
        } catch (e) {}
        a[t].cpar.detach(), a[t].c.html(""), a[t].c = null, delete a[t], a.RS_prioList.splice(a.RS_prioList.indexOf(t), 1), a.RS_toInit[t] = !1, a.RS_killedlist = a.RS_killedlist === i ? [] : a.RS_killedlist, -1 === a.RS_killedlist.indexOf(t) && a.RS_killedlist.push(t);
      });
    },
    revpause: function revpause() {
      return this.each(function () {
        var t = e(this);
        t != i && t.length > 0 && e("body").find("#" + t.attr("id")).length > 0 && (t.data("conthover", 1), t.data("conthoverchanged", 1), t.trigger("revolution.slide.onpause"), a[this.id].tonpause = !0, t.trigger("stoptimer"));
      });
    },
    revresume: function revresume() {
      return this.each(function () {
        if (a[this.id] !== i) {
          var t = e(this);
          t.data("conthover", 0), t.data("conthoverchanged", 1), t.trigger("revolution.slide.onresume"), a[this.id].tonpause = !1, t.trigger("starttimer");
        }
      });
    },
    revmodal: function revmodal(t) {
      var r = this instanceof e ? this[0] : this,
        o = r.id;
      a[r.id] !== i && a.revModal(o, t);
    },
    revstart: function revstart() {
      var t = this instanceof e ? this[0] : this;
      return a[t.id] === i ? (console.log("Slider is Not Existing"), !1) : a[t.id].sliderisrunning || !0 === a[t.id].initEnded ? (console.log("Slider Is Running Already"), !1) : (a[t.id].c = e(t), a[t.id].canvas = a[t.id].c.find("rs-slides"), u(t.id), !0);
    },
    revnext: function revnext() {
      return this.each(function () {
        a[this.id] !== i && a.callingNewSlide(this.id, 1, "carousel" === a[this.id].sliderType);
      });
    },
    revprev: function revprev() {
      return this.each(function () {
        a[this.id] !== i && a.callingNewSlide(this.id, -1, "carousel" === a[this.id].sliderType);
      });
    },
    revmaxslide: function revmaxslide() {
      return e(this).find("rs-slide").length;
    },
    revcurrentslide: function revcurrentslide() {
      if (a[e(this)[0].id] !== i) return parseInt(a[e(this)[0].id].pr_active_key, 0) + 1;
    },
    revlastslide: function revlastslide() {
      return e(this).find("rs-slide").length;
    },
    revshowslide: function revshowslide(e) {
      return this.each(function () {
        a[this.id] !== i && e !== i && a.callingNewSlide(this.id, "to" + (e - 1));
      });
    },
    revcallslidewithid: function revcallslidewithid(e) {
      return this.each(function () {
        a[this.id] !== i && a.callingNewSlide(this.id, e, "carousel" === a[this.id].sliderType);
      });
    }
  }), a = e.fn.revolution, e.extend(!0, a, {
    isNumeric: function isNumeric(e) {
      return !isNaN(parseFloat(e)) && isFinite(e);
    },
    trim: function trim(e) {
      return e !== i && null !== e && "string" == typeof e ? e.trim() : e;
    },
    setCookie: function setCookie(e, i, t) {
      var a = new Date();
      a.setTime(a.getTime() + 60 * t * 60 * 1e3);
      var r = "expires=" + a.toUTCString();
      document.cookie = e + "=" + i + ";" + r + ";path=/";
    },
    getCookie: function getCookie(e) {
      for (var i = e + "=", t = document.cookie.split(";"), a = 0; a < t.length; a++) {
        for (var r = t[a]; " " == r.charAt(0);) r = r.substring(1);
        if (0 == r.indexOf(i)) return decodeURIComponent(r.substring(i.length, r.length));
      }
      return "";
    },
    mesureScrollBar: function mesureScrollBar() {
      a.mesuredScrollBarDone = !0, requestAnimationFrame(function () {
        var e = document.createElement("div");
        e.className = "RSscrollbar-measure", document.body.appendChild(e), a.mesuredScrollbarWidth = e.offsetWidth - e.clientWidth, document.body.removeChild(e);
      });
    },
    pageHandler: function pageHandler(t) {
      a.globalListener = !0, a.window = e(window), a.document = e(document), a.RS_toInit = {}, a.RS_prioList = [], a.RS_swapping = [], a.RS_swapList = {}, window.isSafari11 === i && (window.isSafari11 = a.isSafari11()), a.ISM ? (window.addEventListener("orientationchange", function () {
        a.getWindowDimension(!1, !0), setTimeout(function () {
          a.getWindowDimension(!0, !0);
        }, 400);
      }), window.addEventListener("resize", a.getWindowDimension), tpGS.gsap.delayedCall(3, function () {
        window.removeEventListener("resize", a.getWindowDimension);
      })) : window.addEventListener("resize", a.getWindowDimension), a.getWindowDimension(!1), a.stickySupported = !1, "IE" !== window.RSBrowser && (a.stickySupported = !0), a.checkParrentOverflows(t);
      var r = a.getByTag(document, "RS-MODULE");
      for (var o in r) r.hasOwnProperty(o) && (a.RS_toInit[r[o].id] = !1, a.RS_prioList.push(r[o].id));
      a.nextSlider = t, a.RS_prioListFirstInit = !0, a.hasNavClickListener === i && (a.document.on(a.is_mobile() ? "touchstart" : "mouseenter", ".tparrows, .tp-bullets, .tp-bullet, .tp-tab, .tp-thumb, .tp-thumbs, .tp-tabs, .tp-rightarrow, .tp-leftarrow", function (e) {
        this.classList.add("rs-touchhover");
      }), a.document.on(a.is_mobile() ? "touchend" : "mouseleave", ".tparrows, .tp-bullets, .tp-bullet, .tp-tab, .tp-thumb, .tp-tabs,  .tp-rightarrow, .tp-leftarrow", function (e) {
        var i = this;
        requestAnimationFrame(function () {
          i.classList.remove("rs-touchhover");
        });
      }), a.hasNavClickListener = !0), window.addEventListener("unload", function (e) {
        for (var i in a.RS_toInit) if (a.hasOwnProperty(i)) {
          for (var r in a[i].sbgs) if (a[t].sbgs.hasOwnProperty(r)) {
            var o = a[t].sbgs[r];
            a.destroyCanvas(o.canvas), a.destroyCanvas(o.shadowCanvas), o.three && a.destroyCanvas(o.three.canvas), a.destroyCanvas(o.patternImageCanvas), a.destroyCanvas(o.fmShadow), a.destroyCanvas(o.help_canvas);
          }
          a.destroyCanvas(a[i].createPattern);
        }
        var s = document.querySelectorAll("canvas");
        for (var i in s) s.hasOwnProperty(i) && a.destroyCanvas(s[i]);
      });
    },
    destroyCanvas: function destroyCanvas(e) {
      e && (e.width = e.height = 0, e.remove(), e = null);
    },
    checkParrentOverflows: function checkParrentOverflows(e) {
      window.requestAnimationFrame(function () {
        for (var i = a[e].cpar[0]; i.parentNode && !1 !== a.stickySupported;) {
          if ("RS-MODULE-WRAP" !== i.tagName && "RS-FULLWIDTH-WRAP" !== i.tagName && "RS-MODULE-WRAP" !== i.tagName && -1 === i.className.indexOf("wp-block-themepunch-revslider")) {
            var t = window.getComputedStyle(i);
            a.stickySupported = "hidden" !== t.overflow && "hidden" !== t.overflowX && "hidden" !== t.overflowY;
          }
          i = i.parentNode;
        }
      });
    },
    initNextRevslider: function initNextRevslider(e) {
      a.RS_prioList[0] === e && !1 === a.RS_toInit[e] ? (a.RS_toInit[e] = "waiting", c(e), setTimeout(function () {
        a.initNextRevslider(e);
      }, 19)) : a.RS_prioList[0] === e && "waiting" === a.RS_toInit[e] ? setTimeout(function () {
        a.initNextRevslider(e);
      }, 19) : a.RS_prioList[0] === e && !0 === a.RS_toInit[e] ? (a.RS_prioList.shift(), 0 !== a.RS_prioList.length && setTimeout(function () {
        a.initNextRevslider(e);
      }, 19)) : a.RS_prioList[0] !== e && !1 === a.RS_toInit[e] ? setTimeout(function () {
        a.initNextRevslider(e);
      }, 19) : 0 === a.RS_prioList.length && !0 === a.RS_toInit[e] && c(e);
    },
    scrollTicker: function scrollTicker(e) {
      1 != a.scrollTickerAdded && (a.slidersToScroll = [], a.scrollTickerAdded = !0, a.ISM ? (tpGS.gsap.ticker.fps(150), tpGS.gsap.ticker.add(function () {
        a.generalObserver();
      })) : document.addEventListener("scroll", function (e) {
        a.scrollRaF === i && (a.scrollRaF = requestAnimationFrame(a.generalObserver.bind(this, !0)));
      }, {
        passive: !0
      })), a.slidersToScroll.push(e), a.generalObserver(a.ISM);
    },
    generalObserver: function generalObserver(e, t) {
      for (var r in a.scrollRaF && (a.scrollRaF = cancelAnimationFrame(a.scrollRaF)), a.lastwindowheight = a.lastwindowheight || a.winH, a.scrollY = window.scrollY, a.slidersToScroll) a.slidersToScroll.hasOwnProperty(r) && a.scrollHandling(a.slidersToScroll[r], e, i, t);
    },
    wrapObserver: {
      targets: [],
      init: function init(e) {
        var i = 1,
          t = 0,
          r = 0,
          o = s.bind(a.wrapObserver);
        function s() {
          if (r++, requestAnimationFrame(o), !(r - t < 30 / i)) {
            t = r;
            for (var s = 0; s < a.wrapObserver.targets.length; s++) if (a.wrapObserver.targets.hasOwnProperty(s)) {
              var n = a.wrapObserver.targets[s],
                d = n.elem.getBoundingClientRect();
              n.lw === d.width && n.lh === d.height || 0 === d.width || (n.callback && (n.callback.pause(), n.callback.kill(), n.callback = null), n.callback = tpGS.gsap.to({}, {
                duration: .2,
                onComplete: e.bind(window, n.elem, n.id)
              })), n.lw = d.width, n.lh = d.height;
            }
          }
        }
        s();
      },
      observe: function observe(e, i) {
        if ("" !== (e = e.getBoundingClientRect ? e : e[0].getBoundingClientRect ? e[0] : "")) {
          var t = e.getBoundingClientRect();
          a.wrapObserver.targets.push({
            elem: e,
            id: i,
            lw: t.width,
            lh: t.height
          });
        }
      }
    },
    enterViewPort: function enterViewPort(t, r) {
      !0 !== a[t].started ? (a[t].started = !0, a.lazyLoadAllSlides(t), a[t].c.trigger("revolution.slide.firstrun"), setTimeout(function () {
        k(t), "hero" !== a[t].sliderType && a.manageNavigation && a[t].navigation.use && !0 === a[t].navigation.createNavigationDone && a.manageNavigation(t), a[t].slideamount > 1 && T(t), setTimeout(function () {
          a[t] !== i && (a[t].revolutionSlideOnLoaded = !0, a[t].c.trigger("revolution.slide.onloaded"));
        }, 50);
      }, a[t].startDelay), a[t].startDelay = 0, window.requestAnimationFrame(function () {
        h(t);
      })) : (a[t].waitForCountDown && (T(t), a[t].waitForCountDown = !1), "playing" != a[t].sliderlaststatus && a[t].sliderlaststatus != i || a[t].c.trigger("starttimer"), a[t].lastplayedvideos != i && a[t].lastplayedvideos.length > 0 && e.each(a[t].lastplayedvideos, function (e, i) {
        a.playVideo(i, t);
      }));
    },
    leaveViewPort: function leaveViewPort(t) {
      a[t].sliderlaststatus = a[t].sliderstatus, a[t].c.trigger("stoptimer"), a[t].playingvideos != i && a[t].playingvideos.length > 0 && (a[t].lastplayedvideos = e.extend(!0, [], a[t].playingvideos), a[t].playingvideos && e.each(a[t].playingvideos, function (e, i) {
        a[t].leaveViewPortBasedStop = !0, a.stopVideo && a.stopVideo(i, t);
      }));
    },
    scrollHandling: function scrollHandling(e, t, r, o) {
      if (a[e] !== i) {
        var s = a[e].topc !== i ? a[e].topc[0].getBoundingClientRect() : 0 === a[e].canv.height ? a[e].cpar[0].getBoundingClientRect() : a[e].c[0].getBoundingClientRect();
        s.hheight = 0 === s.height ? 0 === a[e].canv.height ? a[e].module.height : a[e].canv.height : s.height, a[e].scrollproc = s.top < 0 || s.hheight > a.lastwindowheight && s.top < a.lastwindowheight ? s.top / s.hheight : s.bottom > a.lastwindowheight ? (s.bottom - a.lastwindowheight) / s.hheight : 0;
        var n = Math.max(0, 1 - Math.abs(a[e].scrollproc));
        a[e].viewPort.enable && ("%" === a[e].viewPort.vaType[a[e].level] && (a[e].viewPort.visible_area[a[e].level] <= n || n > 0 && n <= 1 && a[e].sbtimeline.fixed) || "px" === a[e].viewPort.vaType[a[e].level] && (s.top <= 0 && s.bottom >= a.lastwindowheight || s.top >= 0 && s.bottom <= a.lastwindowheight || s.top >= 0 && s.top < a.lastwindowheight - a[e].viewPort.visible_area[a[e].level] || s.bottom >= a[e].viewPort.visible_area[a[e].level] && s.bottom < a.lastwindowheight) ? a[e].inviewport || (a[e].inviewport = !0, a.enterViewPort(e, !0), a[e].c.trigger("enterviewport")) : a[e].inviewport && (a[e].inviewport = !1, a.leaveViewPort(e), a[e].c.trigger("leftviewport"))), a[e].inviewport && (a.callBackHandling && a.callBackHandling(e, "parallax", "start"), requestAnimationFrame(function () {
          "fullscreen" === a[e].sliderLayout && a.getFullscreenOffsets(e);
        }), a.parallaxProcesses(e, s, o, r), a.callBackHandling && a.callBackHandling(e, "parallax", "end"));
      }
    },
    clone: function clone(e, t) {
      if (t === i && e === i) return {};
      return function e(t, a) {
        var r = Array.isArray(t) ? [] : {};
        for (var o in t) t.hasOwnProperty(o) && (t[o] !== i && "object" == _typeof(t[o]) && a ? r[o] = e(t[o], !0) : t[o] !== i && (r[o] = t[o]));
        return r;
      }(e, t);
    },
    closest: function closest(e, i) {
      return e && (i(e) ? e : a.closest(e.parentNode, i));
    },
    closestNode: function closestNode(e, i) {
      return a.closest(e, function (e) {
        return e.nodeName === i;
      });
    },
    closestClass: function closestClass(e, i) {
      return a.closest(e, function (e) {
        return (" " + e.className + " ").indexOf(" " + i + " ") >= 0;
      });
    },
    getWinH: function getWinH(e) {
      return a[e].ignoreHeightChange ? a.mobileWinH : a.winH;
    },
    getWindowDimension: function getWindowDimension(e, t) {
      !1 === e ? (a.rAfScrollbar = "skip", a.winWAll = window.innerWidth, a.winWSbar = document.documentElement.clientWidth, a.ISM ? (a.zoom = t ? 1 : a.winWSbar / a.winWAll, a.winW = 1 !== a.zoom ? a.winWSbar * a.zoom : Math.min(a.winWAll, a.winWSbar), a.winH = 1 !== a.zoom ? window.innerHeight * a.zoom : window.innerHeight, t && window.visualViewport && (a.winH *= window.visualViewport.scale, a.winWAll *= window.visualViewport.scale), a.scrollBarWidth = 0) : (a.isModalOpen && a.openModalId !== i && a[a.openModalId] !== i && a[a.openModalId].canv.height > a.winH ? a.scrollBarWidth = a.mesuredScrollbarWidth : a.scrollBarWidth = a.winWAll - a.winWSbar, a.winW = Math.min(a.winWAll, a.winWSbar), a.winH = window.innerHeight), a.ISM && a.winH > 125 && (a.lastwindowheight !== i && Math.abs(a.lastwindowheight - a.winH) < 125 ? a.mobileWinH = a.lastwindowheight : a.mobileWinH = a.winH)) : clearTimeout(a.windowDimenstionDelay), a.windowDimenstionDelay = setTimeout(function () {
        a.rAfScrollbar = i, a.winWAll = window.innerWidth, a.winWSbar = document.documentElement.clientWidth, a.ISM ? (a.zoom = t ? 1 : a.winWSbar / a.winWAll, a.RS_px_ratio = window.devicePixelRatio || window.screen.availWidth / document.documentElement.clientWidth, a.winW = 1 !== a.zoom ? a.winWSbar * a.zoom : Math.min(a.winWAll, a.winWSbar), a.winH = 1 !== a.zoom ? window.innerHeight * a.zoom : window.innerHeight, t && window.visualViewport && (a.winH *= window.visualViewport.scale, a.winWAll *= window.visualViewport.scale), a.scrollBarWidth = 0, t && tpGS.gsap.delayedCall(.1, function () {
          a.getWindowDimension();
        })) : (a.isModalOpen && a.openModalId !== i && a[a.openModalId] !== i && a[a.openModalId].canv.height > a.winH ? a.scrollBarWidth = a.mesuredScrollbarWidth : a.scrollBarWidth = a.winWAll - a.winWSbar, a.winW = Math.min(a.winWAll, a.winWSbar), a.winH = window.innerHeight), a.ISM && a.winH > 125 && (a.lastwindowheight !== i && Math.abs(a.lastwindowheight - a.winH) < 125 ? a.mobileWinH = a.lastwindowheight : a.mobileWinH = a.winH), !1 !== e && a.document.trigger("updateContainerSizes");
      }, 100);
    },
    aC: function aC(i, t) {
      i && (i.classList && i.classList.add ? i.classList.add("" + t) : e(i).addClass(t));
    },
    rC: function rC(i, t) {
      i && (i.classList && i.classList.remove ? i.classList.remove("" + t) : e(i).removeClass(t));
    },
    sA: function sA(e, i, t) {
      e && e.setAttribute && e.setAttribute("data-" + i, t);
    },
    gA: function gA(e, t, a) {
      return e === i ? i : e.hasAttribute && e.hasAttribute("data-" + t) && e.getAttribute("data-" + t) !== i && null !== e.getAttribute("data-" + t) ? e.getAttribute("data-" + t) : a !== i ? a : i;
    },
    rA: function rA(e, i) {
      e && e.removeAttribute && e.removeAttribute("data-" + i);
    },
    iWA: function iWA(e, t) {
      return a[e].justifyCarousel ? "static" === t ? a[e].carousel.wrapwidth : a[e].carousel.slide_widths[t !== i ? t : a[e].carousel.focused] : a[e].gridwidth[a[e].level];
    },
    iHE: function iHE(e, i) {
      return a[e].useFullScreenHeight ? a[e].canv.height : Math.max(a[e].currentRowsHeight, a[e].gridheight[a[e].level]);
    },
    updateFixedScrollTimes: function updateFixedScrollTimes(e) {
      !0 === a[e].sbtimeline.set && !0 === a[e].sbtimeline.fixed && "auto" !== a[e].sliderLayout && (a[e].sbtimeline.rest = a[e].duration - a[e].sbtimeline.fixEnd, a[e].sbtimeline.time = a[e].duration - (a[e].sbtimeline.fixStart + a[e].sbtimeline.rest), a[e].sbtimeline.extended = a[e].sbtimeline.time / 10);
    },
    addSafariFix: function addSafariFix(e) {
      !0 === window.isSafari11 && !0 !== a[e].safari3dFix && (a[e].safari3dFix = !0, a[e].c[0].className += " safarifix");
    },
    openModalAPI: function openModalAPI(t, r, o, s, n, d) {
      if (window.RS_60_MODALS !== i && -1 != e.inArray(t, window.RS_60_MODALS) || window.RS_60_MODAL_API_CALLS !== i && -1 != e.inArray(t, window.RS_60_MODAL_API_CALLS)) e.inArray(t, window.RS_60_MODALS) >= 0 && e.fn.revolution.document.trigger("RS_OPENMODAL_" + t, r);else {
        window.RS_60_MODAL_API_CALLS = window.RS_60_MODAL_API_CALLS || [], window.RS_60_MODAL_API_CALLS.push(t), s && a.showModalCover(n, d, "show");
        var l = {
          action: "revslider_ajax_call_front",
          client_action: "get_slider_html",
          alias: t,
          usage: "modal"
        };
        e.ajax({
          type: "post",
          url: o,
          dataType: "json",
          data: l,
          success: function success(o, l, c) {
            if (null !== o && 1 == o.success) {
              var p;
              if (o.waiting !== i) for (p in o.waiting) -1 == e.inArray(o.waiting[p], RS_MODULES.waiting) && (RS_MODULES.waiting.push(o.waiting[p]), window.RS_MODULES.minimal = !1);
              if (o.toload !== i) {
                var g = "";
                for (p in RS_MODULES = RS_MODULES || {}, RS_MODULES.requestedScripts = [], o.toload) o.toload.hasOwnProperty(p) && (RS_MODULES != i && RS_MODULES[p] != i && !0 === RS_MODULES[p].loaded || -1 === e.inArray(p, RS_MODULES.requestedScripts) && (RS_MODULES.requestedScripts.push(p), g += o.toload[p]));
                "" !== g && e("body").append(g);
              }
              e("body").append(o.data), s && a.showModalCover(n, d, "hide"), a[t] !== i && a[t].openModalApiListener ? e.fn.revolution.document.trigger("RS_OPENMODAL_" + t, r) : e(document).on("RS_MODALOPENLISTENER_" + t, function () {
                e.fn.revolution.document.trigger("RS_OPENMODAL_" + t, r);
              });
            } else s && a.showModalCover(n, d, "hide");
          },
          error: function error(e) {
            s && a.showModalCover(n, d, "hide"), console.log("Modal Can not be Loaded"), console.log(e);
          }
        });
      }
    },
    showModalCover: function showModalCover(t, r, o) {
      switch (o) {
        case "show":
          var s;
          if (r.spin !== i && "off" !== r.spin && (s = a.buildSpinner(t, "spinner" + r.spin, r.spinc, "modalspinner")), r.bg !== i && !1 !== r.bg && "false" !== r.bg && "transparent" !== r.bg) {
            var n = e('<rs-modal-cover data-alias="' + r.alias + '" data-rid="' + t + '" id="' + t + '_modal_bg" style="display:none;opacity:0;background:' + r.bg + '"></rs-modal-cover>');
            e("body").append(n), r.speed = parseFloat(r.speed), r.speed = r.speed > 200 ? r.speed / 1e3 : r.speed, r.speed = Math.max(Math.min(3, r.speed), .3), tpGS.gsap.to(n, r.speed, {
              display: "block",
              opacity: 1,
              ease: "power3.inOut"
            }), a.isModalOpen = !0, s !== i && n.append(s);
          } else s !== i && a[t].c.append(s);
          break;
        case "hide":
          (n = e('rs-modal-cover[data-alias="' + r.alias + '"] .modalspinner')) !== i && n.length > 0 ? n.remove() : t !== i && a[t].c.find(".modalspinner").remove();
      }
    },
    revModal: function revModal(t, r) {
      if (t !== i && a[t] !== i && "clicked" !== a[t].modal.closeProtection) {
        if (!0 === a[t].modal.closeProtection) return a[t].modal.closeProtection, void setTimeout(function () {
          a[t].modal.closeProtection = !1, a.revModal(t, r);
        }, 750);
        switch (r.mode) {
          case "show":
            if (!0 === a[t].modal.isLive) return;
            if (!0 === a.anyModalclosing) return;
            a[t].modal.isLive = !0, r.slide = r.slide === i ? "to0" : r.slide, a[t].modal.bodyclass !== i && a[t].modal.bodyclass.length >= 0 && document.body.classList.add(a[t].modal.bodyclass), a[t].modal.bg.attr("data-rid", t), tpGS.gsap.to(a[t].modal.bg, a[t].modal.coverSpeed, {
              display: "block",
              opacity: 1,
              ease: "power3.inOut"
            }), tpGS.gsap.set(a[t].modal.c, {
              display: "auto" === a[t].sliderLayout ? "inline-block" : "block",
              opacity: 0
            }), a[t].cpar.removeClass("hideallscrollbars"), tpGS.gsap.set(a[t].cpar, {
              display: "block",
              opacity: 1
            });
            var o = {
              a: 0
            };
            a.isModalOpen = !0, a[t].clearModalBG = !0, tpGS.gsap.fromTo(o, a[t].modal.coverSpeed / 5, {
              a: 0
            }, {
              a: 10,
              ease: "power3.inOut",
              onComplete: function onComplete() {
                a.openModalId = t, a[t].sliderisrunning ? a.callingNewSlide(t, r.slide) : ("to0" !== r.slide && (a[t].startWithSlideKey = r.slide), u(t));
              }
            }), setTimeout(function () {
              tpGS.gsap.fromTo([a[t].modal.c], .01, {
                opacity: 0
              }, {
                opacity: 1,
                delay: a[t].modal.coverSpeed / 4,
                ease: "power3.inOut",
                onComplete: function onComplete() {}
              }), window.overscrollhistory = document.body.style.overflow, document.body.style.overflow = "hidden", a.getWindowDimension();
            }, 250);
            break;
          case "close":
            if (!0 === a.anyModalclosing) return;
            a.anyModalclosing = !0, a.openModalId = i, x(t), document.body.style.overflow = window.overscrollhistory, a[t].cpar.addClass("hideallscrollbars"), a[t].modal.bodyclass !== i && a[t].modal.bodyclass.length >= 0 && document.body.classList.remove(a[t].modal.bodyclass), tpGS.gsap.to(a[t].modal.bg, a[t].modal.coverSpeed, {
              display: "none",
              opacity: 0,
              ease: "power3.inOut"
            }), tpGS.gsap.to(a[t].modal.c, a[t].modal.coverSpeed / 6.5, {
              display: "none",
              delay: a[t].modal.coverSpeed / 4,
              opacity: 0,
              onComplete: function onComplete() {
                tpGS.gsap.set(a[t].cpar, {
                  display: "none",
                  opacity: 0
                }), a.document.trigger("revolution.all.resize"), a.document.trigger("revolution.modal.close", [a[t].modal]), a.getWindowDimension(), a.isModalOpen = !1;
              }
            }), a[t].modal.closeProtection = !0, clearTimeout(a[t].modal.closeTimer), a[t].modal.closeTimer = setTimeout(function () {
              a.anyModalclosing = !1, a[t].modal.isLive = !1, a[t].modal.closeProtection = !1;
            }, Math.max(750, 1020 * a[t].modal.coverSpeed));
            break;
          case "init":
            if (window.RS_60_MODALS = window.RS_60_MODALS === i ? [] : window.RS_60_MODALS, -1 === e.inArray(a[t].modal.alias, window.RS_60_MODALS) && window.RS_60_MODALS.push(a[t].modal.alias), a[t].modal.listener === i && (a[t].modal.c = e("#" + t + "_modal"), !1 !== a[t].modal.cover && "false" !== a[t].modal.cover || (a[t].modal.coverColor = "transparent"), a[t].modal.bg = e('rs-modal-cover[data-alias="' + r.alias + '"]'), a[t].modal.bg === i || 0 === a[t].modal.bg.length ? (a[t].modal.bg = e('<rs-modal-cover style="display:none;opacity:0;background:' + a[t].modal.coverColor + '" data-rid="' + t + '" id="' + t + '_modal_bg"></rs-modal-cover>'), "auto" === a[t].sliderLayout && a[t].modal.cover ? e("body").append(a[t].modal.bg) : a[t].modal.c.append(a[t].modal.bg)) : a[t].modal.bg.attr("data-rid", t), a[t].modal.c[0].className += "rs-modal-" + a[t].sliderLayout, a[t].modal.calibration = {
              left: "auto" === a[t].sliderLayout ? "center" === a[t].modal.horizontal ? "50%" : "left" === a[t].modal.horizontal ? "0px" : "auto" : "0px",
              right: "auto" === a[t].sliderLayout ? "center" === a[t].modal.horizontal ? "auto" : "left" === a[t].modal.horizontal ? "auto" : "0px" : "0px",
              top: "auto" === a[t].sliderLayout || "fullwidth" === a[t].sliderLayout ? "middle" === a[t].modal.vertical ? "50%" : "top" === a[t].modal.vertical ? "0px" : "auto" : "0px",
              bottom: "auto" === a[t].sliderLayout || "fullwidth" === a[t].sliderLayout ? "middle" === a[t].modal.vertical ? "auto" : "top" === a[t].modal.vertical ? "auto" : "0px" : "0px",
              y: ("auto" === a[t].sliderLayout || "fullwidth" === a[t].sliderLayout) && "middle" === a[t].modal.vertical ? "-50%" : 0,
              x: "auto" === a[t].sliderLayout && "center" === a[t].modal.horizontal ? "-50%" : 0
            }, "-50%" === a[t].modal.calibration.y && (a[t].modal.calibration.filter = "blur(0px)"), tpGS.gsap.set(a[t].modal.c, "auto" === a[t].sliderLayout || "fullscreen" === a[t].sliderLayout ? e.extend(!0, a[t].modal.calibration, {
              opacity: 0,
              display: "none"
            }) : {
              opacity: 0,
              display: "none"
            }), "fullwidth" === a[t].sliderLayout && tpGS.gsap.set(a[t].modal.c.find("rs-module-wrap"), a[t].modal.calibration), a.document.on("RS_OPENMODAL_" + a[t].modal.alias, function (e, i) {
              a[t].initEnded = !0, a.revModal(t, {
                mode: "show",
                slide: i
              });
            }), a[a[t].modal.alias] = a[a[t].modal.alias] || {}, a[a[t].modal.alias].openModalApiListener = !0, a.document.trigger("RS_MODALOPENLISTENER_" + a[t].modal.alias), a.document.on("click", "rs-modal-cover", function () {
              a.revModal(a.gA(this, "rid"), {
                mode: "close"
              });
            }), a[t].modal.listener = !0, a[t].modal.trigger !== i)) {
              var s,
                n = a[t].modal.trigger.split(";");
              for (o in a[t].modal.trigger = {}, n) if (n.hasOwnProperty(o)) switch ((s = n[o].split(":"))[0]) {
                case "t":
                  a[t].modal.trigger.time = parseInt(s[1], 0);
                  break;
                case "s":
                  a[t].modal.trigger.scroll = s[1];
                  break;
                case "so":
                  a[t].modal.trigger.scrollo = parseInt(s[1], 0);
                  break;
                case "e":
                  a[t].modal.trigger.event = s[1];
                  break;
                case "ha":
                  a[t].modal.trigger.hash = s[1];
                  break;
                case "co":
                  a[t].modal.trigger.cookie = s[1];
              }
              var d = !0;
              if (a[t].modal.trigger.cookie !== i ? d = "true" !== a.getCookie(a[t].modal.alias + "_modal_one_time") : "true" == a.getCookie(a[t].modal.alias + "_modal_one_time") && a.setCookie(a[t].modal.alias + "_modal_one_time", !1, 10), d && (a[t].modal.trigger.time !== i && 0 !== a[t].modal.trigger.time && (a[t].modal.trigger.cookie !== i && a.setCookie(a[t].modal.alias + "_modal_one_time", !0, a[t].modal.trigger.cookie), setTimeout(function () {
                a.document.trigger("RS_OPENMODAL_" + a[t].modal.alias);
              }, a[t].modal.trigger.time)), a[t].modal.trigger.scrollo !== i || a[t].modal.trigger.scroll !== i)) {
                a[t].modal.trigger.scroll !== i && e(a[t].modal.trigger.scroll)[0] !== i && (a[t].modal.trigger.scroll = e(a[t].modal.trigger.scroll)[0]);
                var l = function l() {
                  if (a[t].modal.trigger.scroll !== i) var e = a[t].modal.trigger.scroll.getBoundingClientRect();
                  (a[t].modal.trigger.scroll !== i && Math.abs(e.top + (e.bottom - e.top) / 2 - a.getWinH(t) / 2) < 50 || a[t].modal.trigger.scrollo !== i && Math.abs(a[t].modal.trigger.scrollo - (a.scrollY !== i ? a.scrollY : window.scrollY)) < 100) && (a.document.trigger("RS_OPENMODAL_" + a[t].modal.alias), a[t].modal.trigger.cookie !== i && a.setCookie(a[t].modal.alias + "_modal_one_time", !0, a[t].modal.trigger.cookie), document.removeEventListener("scroll", l));
                };
                document.addEventListener("scroll", l, {
                  id: t,
                  passive: !0
                });
              }
              a[t].modal.trigger.event !== i && a.document.on(a[t].modal.trigger.event, function () {
                a.document.trigger("RS_OPENMODAL_" + a[t].modal.alias);
              }), "t" == a[t].modal.trigger.hash && window.location.hash.substring(1) == a[t].modal.alias && a.document.trigger("RS_OPENMODAL_" + a[t].modal.alias);
            }
        }
      }
    },
    smartConvertDivs: function smartConvertDivs(e) {
      var i = "";
      if ("string" == typeof e && e.indexOf("#") >= 0) {
        var t = e.split(","),
          a = t.length - 1;
        for (var r in t) i = "string" == typeof t[r] && "#" === t[r][0] ? i + t[r][1] / t[r][3] * 100 + "%" + (r < a ? "," : "") : i + t[r] + (r < a ? "," : "");
      } else i = e;
      return i;
    },
    revToResp: function revToResp(e, t, a, r) {
      if ((e = e === i ? a : e) !== i) {
        if (r = r === i ? "," : r, "boolean" != typeof e && ("object" != _typeof(e) || Array.isArray(e))) {
          try {
            e = e.replace(/[[\]]/g, "").replace(/\'/g, "").split(r);
          } catch (e) {}
          for (e = Array.isArray(e) ? e : [e]; e.length < t;) e[e.length] = e[e.length - 1];
        }
        return e;
      }
    },
    loadImages: function loadImages(t, r, o, s) {
      if (t !== i && 0 !== t.length) {
        var n = [];
        if (Array.isArray(t)) for (var d in t) t.hasOwnProperty(d) && t[d] !== i && n.push(t[d]);else n.push(t);
        for (var l in n) if (n.hasOwnProperty(l)) {
          var c = n[l].querySelectorAll("img, rs-sbg, .rs-svg");
          for (var d in c) if (c.hasOwnProperty(d)) {
            c[d] !== i && c[d].dataset !== i && c[d].dataset.src !== i && c[d].dataset.src.indexOf("dummy.png") >= 0 && c[d].src.indexOf("data") >= 0 && delete c[d].dataset.src;
            var p = g(c[d], i, r),
              u = p !== i ? p : a.gA(c[d], "svg_src") != i ? a.gA(c[d], "svg_src") : c[d].src === i ? e(c[d]).data("src") : c[d].src,
              h = a.gA(c[d], "svg_src") != i ? "svg" : "img";
            u !== i && a[r].loadqueue !== i && 0 == a[r].loadqueue.filter(function (e) {
              return e.src === u;
            }).length && a[r].loadqueue.push({
              src: u,
              img: c[d],
              index: d,
              starttoload: e.now(),
              type: h || "img",
              prio: o,
              progress: c[d].complete && u === c[d].src ? "loaded" : "prepared",
              static: s,
              width: c[d].complete && u === c[d].src ? c[d].width : i,
              height: c[d].complete && u === c[d].src ? c[d].height : i
            });
          }
        }
        b(r);
      }
    },
    waitForCurrentImages: function waitForCurrentImages(t, r, o) {
      if (t !== i && 0 !== t.length && a[r] !== i) {
        var s = !1,
          n = [];
        if (Array.isArray(t)) for (var d in t) t.hasOwnProperty(d) && t[d] !== i && n.push(t[d]);else n.push(t);
        for (var l in n) if (n.hasOwnProperty(l)) {
          var c = n[l].querySelectorAll("img, rs-sbg, .rs-svg");
          for (d in c) if (c.hasOwnProperty(d) && "length" !== d && !(c[d].className.indexOf("rs-pzimg") >= 0)) {
            var p = e(c[d]).data(),
              u = g(c[d], i, r),
              h = u !== i ? u : a.gA(c[d], "svg_src") != i ? a.gA(c[d], "svg_src") : c[d].src === i ? p.src : c[d].src,
              m = a.getLoadObj(r, h);
            if (a.sA(c[d], "src-rs-ref", h), p.loaded === i && m !== i && m.progress && "loaded" == m.progress) {
              if ("img" == m.type) {
                if (c[d].src.slice(c[d].src.length - 10) !== m.src.slice(m.src.length - 10) && (c[d].src = m.src), p.slidebgimage) {
                  -1 == m.src.indexOf("images/transparent.png") && -1 == m.src.indexOf("assets/transparent.png") || p.bgcolor === i || p.bgcolor !== i && "transparent" !== p.bgcolor && (m.bgColor = !0, m.useBGColor = !0), a.sA(n[l], "owidth", m.width), a.sA(n[l], "oheight", m.height);
                  var v = a.getByTag(n[l], "RS-SBG-WRAP"),
                    f = a.gA(n[l], "key");
                  if (a[r].sbgs[f].loadobj = m, v.length > 0 && (a.sA(v[0], "owidth", m.width), a.sA(v[0], "oheight", m.height)), "carousel" === a[r].sliderType) {
                    var y = e(v),
                      w = a.getSlideIndex(r, f);
                    (a[r].carousel.justify && a[r].carousel.slide_widths === i || a[r].carousel.slide_width === i) && a.setCarouselDefaults(r, !0), y.data("panzoom") === i || a[r].panzoomTLs !== i && a[r].panzoomTLs[w] !== i || a.startPanZoom(y, r, 0, w, "prepare", f), a[r].sbgs[f].isHTML5 && !a[r].sbgs[f].videoisplaying && (a[r].sbgs[f].video = a[r].sbgs[f].loadobj.img), n[l].getAttribute("data-iratio") !== i && !n[l].getAttribute("data-iratio") && m.img && m.img.naturalWidth && (n[l].setAttribute("data-iratio", m.img.naturalWidth / m.img.naturalHeight), a.setCarouselDefaults(r, "redraw"), !0 === a[r].carousel.ocfirsttun && a.organiseCarousel(r, "right", !0, !1, !1)), a.updateSlideBGs(r, f, a[r].sbgs[f]);
                  }
                }
              } else "svg" == m.type && "loaded" == m.progress && (c[d].innerHTML = m.innerHTML);
              p.loaded = !0;
            }
            m && m.progress && m.progress.match(/inprogress|inload|prepared/g) && (!m.error && e.now() - m.starttoload < 15e3 ? s = !0 : (m.progress = "failed", m.reported_img || (m.reported_img = !0, console.log(h + "  Could not be loaded !")))), 1 != a[r].youtubeapineeded || window.YT && YT.Player != i || (s = S("youtube", r)), 1 != a[r].vimeoapineeded || window.Vimeo || (s = S("vimeo", r));
          }
        }
        !a.ISM && a[r].audioqueue && a[r].audioqueue.length > 0 && e.each(a[r].audioqueue, function (i, t) {
          t.status && "prepared" === t.status && e.now() - t.start < t.waittime && (s = !0);
        }), e.each(a[r].loadqueue, function (i, t) {
          !0 === t.static && ("loaded" != t.progress && "done" !== t.progress || "failed" === t.progress) && ("failed" != t.progress || t.reported ? !t.error && e.now() - t.starttoload < 5e3 ? s = !0 : t.reported || (t.reported = _(t.src, t.error)) : t.reported = _(t.src, t.error));
        }), s ? tpGS.gsap.delayedCall(.02, a.waitForCurrentImages, [t, r, o]) : o !== i && tpGS.gsap.delayedCall(1e-4, o);
      }
    },
    updateVisibleArea: function updateVisibleArea(e) {
      for (var t in a[e].viewPort.visible_area = a.revToResp(a[e].viewPort.visible_area, a[e].rle, "0px"), a[e].viewPort.vaType = new Array(4), a[e].viewPort.visible_area) a[e].viewPort.visible_area.hasOwnProperty(t) && (!1 === a[e].viewPort.local && !0 === a[e].viewPort.global ? (a[e].viewPort.vaType[t] = a[e].viewPort.globalDist.indexOf("%") >= 0 ? "%" : "px", a[e].viewPort.visible_area[t] = parseInt(a[e].viewPort.globalDist)) : (a.isNumeric(a[e].viewPort.visible_area[t]) && (a[e].viewPort.visible_area[t] += "%"), a[e].viewPort.visible_area[t] !== i && (a[e].viewPort.vaType[t] = a[e].viewPort.visible_area[t].indexOf("%") >= 0 ? "%" : "px"), a[e].viewPort.visible_area[t] = parseInt(a[e].viewPort.visible_area[t], 0)), a[e].viewPort.visible_area[t] = "%" == a[e].viewPort.vaType[t] ? a[e].viewPort.visible_area[t] / 100 : a[e].viewPort.visible_area[t]);
    },
    observeFonts: function observeFonts(e, t, r) {
      r = r === i ? 0 : r, a.fonts === i && (a.fonts = {}, a.monoWidth = d("monospace"), a.sansWidth = d("sans-serif"), a.serifWidth = d("serif")), r++;
      var o = a.fonts[e];
      !0 !== a.fonts[e] && (a.fonts[e] = a.monoWidth !== d(e + ",monospace") || a.sansWidth !== d(e + ",sans-serif") || a.serifWidth !== d(e + ",serif")), 100 === r || (!1 === o || o === i) && !0 === a.fonts[e] ? (d(e + ",monospace", !0), d(e + ",sans-serif", !0), d(e + ",serif", !0), t()) : setTimeout(function () {
        a.observeFonts(e, t, r);
      }, 19);
    },
    getversion: function getversion() {
      return t;
    },
    currentSlideIndex: function currentSlideIndex(e) {
      return a[e].pr_active_key;
    },
    iOSVersion: function iOSVersion() {
      return !!(navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/iPad/i)) && navigator.userAgent.match(/OS 4_\d like Mac OS X/i);
    },
    setIsIOS: function setIsIOS() {
      a.isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream || "MacIntel" === navigator.platform && void 0 !== navigator.standalone;
    },
    setIsChrome8889: function setIsChrome8889() {
      a.isChrome8889 = a.isChrome8889 === i ? navigator.userAgent.indexOf("Chrome/88") >= 0 || navigator.userAgent.indexOf("Chrome/89") >= 0 : a.isChrome8889;
    },
    isIE: function isIE() {
      if (a.isIERes === i) {
        var t = e('<div style="display:none;"/>').appendTo(e("body"));
        t.html("\x3c!--[if IE 8]><a>&nbsp;</a><![endif]--\x3e"), a.isIERes = t.find("a").length, t.remove();
      }
      return a.isIERes;
    },
    is_mobile: function is_mobile() {
      var e = ["android", "webos", "iphone", "ipad", "blackberry", "Android", "webos", "iPod", "iPhone", "iPad", "Blackberry", "BlackBerry"],
        t = !1;
      if (window.orientation !== i) t = !0;else for (var a in e) e.hasOwnProperty(a) && (t = !!(t || navigator.userAgent.split(e[a]).length > 1) || t);
      return t && document.body && -1 === document.body.className.indexOf("rs-ISM") && (document.body.className += " rs-ISM"), t;
    },
    is_android: function is_android() {
      var e = ["android", "Android"],
        i = !1;
      for (var t in e) e.hasOwnProperty(t) && (i = !!(i || navigator.userAgent.split(e[t]).length > 1) || i);
      return i;
    },
    callBackHandling: function callBackHandling(i, t, r) {
      a[i].callBackArray && e.each(a[i].callBackArray, function (e, i) {
        i && i.inmodule && i.inmodule === t && i.atposition && i.atposition === r && i.callback && i.callback.call();
      });
    },
    get_browser: function get_browser() {
      var e,
        i = navigator.userAgent,
        t = i.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
      return /trident/i.test(t[1]) ? (e = /\brv[ :]+(\d+)/g.exec(i) || [], "IE") : "Chrome" === t[1] && null != (e = i.match(/\b(OPR|Edge)\/(\d+)/)) ? e[1].replace("OPR", "Opera") : (t = t[2] ? [t[1], t[2]] : [navigator.appName, navigator.appVersion, "-?"], null != (e = i.match(/version\/(\d+)/i)) && t.splice(1, 1, e[1]), t[0]);
    },
    get_browser_version: function get_browser_version() {
      var e,
        i = navigator.appName,
        t = navigator.userAgent,
        a = t.match(/(edge|opera|chrome|safari|firefox|msie)\/?\s*(\.?\d+(\.\d+)*)/i);
      return a && null != (e = t.match(/version\/([\.\d]+)/i)) && (a[2] = e[1]), (a = a ? [a[1], a[2]] : [i, navigator.appVersion, "-?"])[1];
    },
    isFaceBook: function isFaceBook() {
      return a.isFaceBookApp == i && (a.isFaceBookApp = navigator.userAgent || navigator.vendor || window.opera, a.isFaceBookApp = a.isFaceBookApp.indexOf("FBAN") > -1 || a.isFaceBookApp.indexOf("FBAV") > -1), a.isFaceBookApp;
    },
    isFirefox: function isFirefox(e) {
      return a[e].isFirefox = a[e].isFirefox === i ? "Firefox" === a.get_browser() : a[e].isFirefox, a.isFF = a[e].isFirefox, a[e].isFirefox;
    },
    isSafari11: function isSafari11() {
      return "safari" === a.trim(a.get_browser().toLowerCase()) && parseFloat(a.get_browser_version()) >= 11;
    },
    isWebkit: function isWebkit() {
      var e = /(webkit)[ \/]([\w.]+)/.exec(navigator.userAgent.toLowerCase());
      return e && e[1] && "webkit" === e[1];
    },
    isIE11: function isIE11() {
      return a.IE11 = a.IE11 === i ? !!navigator.userAgent.match(/Trident.*rv\:11\./) : a.IE11, a.IE11;
    },
    deepLink: function deepLink(e, t) {
      if (t !== i) {
        var r = parseInt(t.toString().replace(/^slide/, "").replace("-", ""), 10);
        if (isNaN(r)) for (var o in a[e].slides) if (a[e].slides.hasOwnProperty(o) && a.gA(a[e].slides[o], "deeplink") === t) {
          r = parseInt(a.gA(a[e].slides[o], "originalindex"), 10);
          break;
        }
        return isNaN(r) || r < 1 || r > a[e].realslideamount ? void 0 : r;
      }
    },
    getHorizontalOffset: function getHorizontalOffset(e, i) {
      var t = l(e, ".outer-left"),
        a = l(e, ".outer-right");
      return "left" == i ? t : "right" == i ? a : "all" == i ? {
        left: t,
        right: a,
        both: t + a,
        inuse: t + a != 0
      } : t + a;
    },
    getComingSlide: function getComingSlide(e, t) {
      var r = a[e].pr_next_key !== i ? a[e].pr_next_key : a[e].pr_processing_key !== i ? a[e].pr_processing_key : a[e].pr_active_key,
        o = 0;
      if (o = 0, a[e].pr_active_slide !== i && "true" == a.gA(a[e].pr_active_slide[0], "not_in_nav") && (r = a[e].pr_lastshown_key), t !== i && a.isNumeric(t) || t !== i && t.match(/to/g)) o = 1 === t || -1 === t ? parseInt(r, 0) + t < 0 ? a[e].slideamount - 1 : parseInt(r, 0) + t >= a[e].slideamount ? 0 : parseInt(r, 0) + t : (t = a.isNumeric(t) ? t : parseInt(t.split("to")[1], 0)) < 0 ? 0 : t > a[e].slideamount - 1 ? a[e].slideamount - 1 : t;else if (t) for (var s in a[e].slides) a[e].slides.hasOwnProperty(s) && (o = a[e].slides && a[e].slides[s] && (a.gA(a[e].slides[s], "key") === t || a[e].slides[s].id === t) ? s : o);
      return {
        nindex: o,
        aindex: r
      };
    },
    callingNewSlide: function callingNewSlide(e, t, r) {
      var o = a.getComingSlide(e, t);
      a[e].pr_next_key = o.nindex, a[e].sdir = a[e].pr_next_key < a[e].pr_active_key ? 1 : 0, r && a[e].carousel !== i && (a[e].carousel.focused = a[e].pr_next_key), a[e].ctNavElement ? a[e].ctNavElement = !1 : a[e].c.trigger("revolution.nextslide.waiting"), (a[e].started && o.aindex === a[e].pr_next_key && o.aindex === a[e].pr_lastshown_key || a[e].pr_next_key !== o.aindex && -1 != a[e].pr_next_key && a[e].pr_lastshown_key !== i) && k(e, r);
    },
    getLoadObj: function getLoadObj(e, t) {
      var r = a[e].loadqueue !== i && a[e].loadqueue.filter(function (e) {
        return e.src === t;
      })[0];
      return r === i ? {
        src: t
      } : r;
    },
    getResponsiveLevel: function getResponsiveLevel(e) {
      var i = 9999,
        t = 0,
        r = 0,
        o = 0;
      if (a[e].responsiveLevels && a[e].responsiveLevels.length) for (var s in a[e].responsiveLevels) a[e].responsiveLevels.hasOwnProperty(s) && (a.winWAll < a[e].responsiveLevels[s] && (0 == t || t > parseInt(a[e].responsiveLevels[s])) && (i = parseInt(a[e].responsiveLevels[s]), o = parseInt(s), t = parseInt(a[e].responsiveLevels[s])), a.winWAll > a[e].responsiveLevels[s] && t < a[e].responsiveLevels[s] && (t = parseInt(a[e].responsiveLevels[s]), r = parseInt(s)));
      return t < i ? r : o;
    },
    getSizeMultpilicator: function getSizeMultpilicator(e, i, t) {
      var r = {
        h: 0,
        w: 0
      };
      return a[e].justifyCarousel ? r.h = r.w = 1 : (r.w = t.width / a[e].gridwidth[a[e].level], r.h = t.height / a[e].gridheight[a[e].level], r.w = isNaN(r.w) ? 1 : r.w, r.h = isNaN(r.h) ? 1 : r.h, 1 == a[e].enableUpscaling ? r.h = r.w : (r.h > r.w ? r.h = r.w : r.w = r.h, (r.h > 1 || r.w > 1) && (r.w = 1, r.h = 1))), r;
    },
    updateDims: function updateDims(e, t) {
      var r = a[e].pr_processing_key || a[e].pr_active_key || 0,
        o = a[e].pr_active_key || 0,
        s = a[e].modal !== i && a[e].modal.useAsModal,
        n = s ? a.winWAll : a.winW,
        d = !1;
      if (a[e].lastScrollBarWidth = a.scrollBarWidth, a[e].redraw = a[e].redraw === i ? {} : a[e].redraw, a[e].module = a[e].module === i ? {} : a[e].module, a[e].canv = a[e].canv === i ? {} : a[e].canv, a[e].content = a[e].content === i ? {} : a[e].content, a[e].drawUpdates = {
        c: {},
        cpar: {},
        canv: {}
      }, "carousel" == a[e].sliderType ? a[e].module.margins = {
        top: parseInt(a[e].carousel.padding_top || 0, 0),
        bottom: parseInt(a[e].carousel.padding_bottom || 0, 0)
      } : a[e].module.margins = {
        top: 0,
        bottom: 0
      }, a[e].module.paddings === i && (a[e].module.paddings = {
        top: parseInt(a[e].cpar.css("paddingTop"), 0) || 0,
        bottom: parseInt(a[e].cpar.css("paddingBottom"), 0) || 0
      }), a[e].blockSpacing !== i ? (a[e].block = {
        bottom: a[e].blockSpacing.bottom !== i ? parseInt(a[e].blockSpacing.bottom[a[e].level], 0) : 0,
        top: a[e].blockSpacing.top !== i ? parseInt(a[e].blockSpacing.top[a[e].level], 0) : 0,
        left: a[e].blockSpacing.left !== i ? parseInt(a[e].blockSpacing.left[a[e].level], 0) : 0,
        right: a[e].blockSpacing.right !== i ? parseInt(a[e].blockSpacing.right[a[e].level], 0) : 0
      }, a[e].block.hor = a[e].block.left + a[e].block.right, a[e].block.ver = a[e].block.top + a[e].block.bottom) : a[e].block === i && (a[e].block = {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        hor: 0,
        ver: 0
      }), a[e].blockSpacing !== i) {
        var l = {
            paddingLeft: a[e].block.left,
            paddingRight: a[e].block.right,
            marginTop: a[e].block.top,
            marginBottom: a[e].block.bottom
          },
          c = JSON.stringify(l);
        l !== a[e].emptyObject && c !== a[e].caches.setsizeBLOCKOBJ && (tpGS.gsap.set(a[e].blockSpacing.block, l), a[e].caches.setsizeBLOCKOBJ = c, d = !0);
      }
      if (a[e].levelForced = a[e].level = a.getResponsiveLevel(e), a[e].rowHeights = a.getRowHeights(e), a[e].aratio = a[e].gridheight[a[e].level] / a[e].gridwidth[a[e].level], a[e].module.width = "auto" === a[e].sliderLayout || 1 == a[e].disableForceFullWidth ? a[e].cpar.width() : n - a[e].block.hor, a[e].outNavDims = a.getOuterNavDimension(e), a[e].canv.width = a[e].module.width - a[e].outNavDims.horizontal - (s ? a.scrollBarWidth : 0), s && "auto" === a[e].sliderLayout && (a[e].canv.width = Math.min(a[e].gridwidth[a[e].level], n)), "fullscreen" === a[e].sliderLayout || a[e].infullscreenmode) {
        var p = a.getWinH(e) - (!0 === a[e].modal.useAsModal ? 0 : a.getFullscreenOffsets(e));
        a[e].canv.height = Math.max(a[e].rowHeights.cur, Math.max(p - a[e].outNavDims.vertical, a[e].minHeight)), o !== r && (a[e].currentSlideHeight = Math.max(a[e].rowHeights.last, Math.max(p - a[e].outNavDims.vertical, a[e].minHeight)), a[e].redraw.maxHeightOld = !0), a[e].drawUpdates.c.height = "100%";
      } else a[e].canv.height = a[e].keepBPHeight ? a[e].gridheight[a[e].level] : Math.round(a[e].canv.width * a[e].aratio), a[e].canv.height = a[e].autoHeight ? a[e].canv.height : Math.min(a[e].canv.height, a[e].gridheight[a[e].level]), a[e].canv.height = Math.max(Math.max(a[e].rowHeights.cur, a[e].canv.height), a[e].minHeight), a[e].drawUpdates.c.height = a[e].canv.height;
      a[e].module.height = a[e].canv.height, "fullwidth" != a[e].sliderLayout || a[e].fixedOnTop || (a[e].drawUpdates.c.maxHeight = 0 != a[e].maxHeight ? Math.min(a[e].canv.height, a[e].maxHeight) : a[e].canv.height), a[e].CM = a.getSizeMultpilicator(e, a[e].enableUpscaling, {
        width: a[e].canv.width,
        height: a[e].canv.height
      }), a[e].content.width = a[e].gridwidth[a[e].level] * a[e].CM.w, a[e].content.height = Math.round(Math.max(a[e].rowHeights.cur, a[e].gridheight[a[e].level] * a[e].CM.h));
      var g = a[e].module.margins.top + a[e].module.margins.bottom + ("fullscreen" === a[e].sliderLayout ? 0 : a[e].outNavDims.vertical) + a[e].canv.height + a[e].module.paddings.top + a[e].module.paddings.bottom;
      a[e].drawUpdates.cpar.height = g, a[e].drawUpdates.cpar.width = "auto" === a[e].sliderLayout ? "auto" : a[e].module.width, "auto" === a[e].sliderLayout || "fullscreen" === a[e].sliderLayout && !0 === a[e].disableForceFullWidth || a[e].rsFullWidthWrap === i ? "fullscreen" == a[e].sliderLayout && 1 == a[e].disableForceFullWidth && (a[e].drawUpdates.cpar.left = 0) : a[e].drawUpdates.cpar.left = 0 - Math.ceil(a[e].rsFullWidthWrap.offset().left - (a[e].outNavDims.left + a[e].block.left)), a[e].sbtimeline.set && a[e].sbtimeline.fixed ? (a[e].sbtimeline.extended === i && a.updateFixedScrollTimes(e), a[e].forcerHeight = 2 * g + a[e].sbtimeline.extended) : a[e].forcerHeight = g, a[e].forcerHeight !== a[e].caches.setsizeForcerHeight && a[e].forcer !== i && (a[e].caches.setsizeForcerHeight = a[e].forcerHeight, d = !0, a[e].redraw.forcer = !0), a[e].drawUpdates.c.width = a[e].canv.width, "auto" === a[e].sliderLayout && (a[e].drawUpdates.c.left = a[e].outNavDims.left), a[e].drawUpdates.c !== a[e].emptyObject && JSON.stringify(a[e].drawUpdates.c) !== a[e].caches.setsizeCOBJ && (a[e].caches.setsizeCOBJ = JSON.stringify(a[e].drawUpdates.c), d = !0, a[e].redraw.c = !0), a[e].drawUpdates.cpar !== a[e].emptyObject && JSON.stringify(a[e].drawUpdates.cpar) !== a[e].caches.setsizeCPAROBJ && (a[e].caches.setsizeCPAROBJ = JSON.stringify(a[e].drawUpdates.cpar), d = !0, a[e].redraw.cpar = !0), s && "auto" === a[e].sliderLayout && a[e].caches.canWidth !== a[e].canv.width && (a[e].caches.canWidth = a[e].canv.width, d = !0, a[e].redraw.modalcanvas = !0), a[e].slayers && a[e].slayers.length > 0 && a[e].outNavDims.left !== a[e].caches.outNavDimsLeft && "fullwidth" != a[e].sliderLayout && "fullscreen" != a[e].sliderLayout && (a[e].caches.outNavDimsLeft = a[e].outNavDims.left, a[e].redraw.slayers = !0), s && a[e].modal.calibration !== i && "middle" === a[e].modal.vertical && (a[e].modal.calibration.top = a.getWinH(e) < g ? "0%" : "50%", a[e].modal.calibration.y = a.getWinH(e) < g ? "0px" : "-50%", "fullwidth" === a[e].sliderLayout && (d = !0, a[e].redraw.modulewrap = !0)), a[e].gridOffsetWidth = (a[e].module.width - a[e].gridwidth[a[e].level]) / 2, a[e].gridOffsetHeight = (a[e].module.height - a[e].content.height) / 2, a[e].caches.curRowsHeight = a[e].currentRowsHeight = a[e].rowHeights.cur, a[e].caches.moduleWidth = a[e].width = a[e].module.width, a[e].caches.moduleHeight = a[e].height = a[e].module.height, a[e].caches.canWidth = a[e].conw = a[e].canv.width, a[e].caches.canHeight = a[e].conh = a[e].canv.height, a[e].bw = a[e].CM.w, a[e].bh = a[e].CM.h, a[e].caches.outNavDimsLeft = a[e].outNavDims.left, window.requestAnimationFrame(function () {
        a[e].redraw.forcer && tpGS.gsap.set(a[e].forcer, {
          height: a[e].forcerHeight
        }), a[e].redraw.c && tpGS.gsap.set(a[e].c, a[e].drawUpdates.c), a[e].redraw.cpar && tpGS.gsap.set(a[e].cpar, a[e].drawUpdates.cpar), a[e].redraw.modalcanvas && tpGS.gsap.set([a[e].modal.c, a[e].canvas], {
          width: a[e].canv.width
        }), a[e].redraw.maxHeightOld && (a[e].slides[o].style.maxHeight = a[e].currentSlideHeight !== a[e].canv.height ? a[e].currentSlideHeight + "px" : "none"), a[e].redraw.slayers && tpGS.gsap.set(a[e].slayers, {
          left: a[e].outNavDims.left
        }), a[e].redraw.modulewrap && tpGS.gsap.set(a[e].modal.c.find("rs-module-wrap"), a[e].modal.calibration), !0 !== a[e].navigation.initialised && "prepared" === t && ("hero" !== a[e].sliderType && a.createNavigation && a[e].navigation.use && !0 !== a[e].navigation.createNavigationDone && a.createNavigation(e), a.resizeThumbsTabs && a.resizeThumbsTabs && a[e].navigation.use && a.resizeThumbsTabs(e)), a[e].rebuildProgressBar && O(e), a[e].redraw = {};
      });
      var u = a[e].inviewport && (a[e].heightInLayers !== i && a[e].module.height !== a[e].heightInLayers || a[e].widthInLayers !== i && a[e].module.width !== a[e].widthInLayers);
      return "ignore" !== t && u && (a[e].heightInLayers = i, a[e].widthInLayers = i, "carousel" !== a[e].sliderType && (a[e].pr_next_key !== i ? a.animateTheLayers({
        slide: a[e].pr_next_key,
        id: e,
        mode: "rebuild",
        caller: "swapSlideProgress_1"
      }) : a[e].pr_processing_key !== i ? a.animateTheLayers({
        slide: a[e].pr_processing_key,
        id: e,
        mode: "rebuild",
        caller: "swapSlideProgress_2"
      }) : a[e].pr_active_key !== i && a.animateTheLayers({
        slide: a[e].pr_active_key,
        id: e,
        mode: "rebuild",
        caller: "swapSlideProgress_3"
      })), d = !0), d && "ignore" !== t && a.requestLayerUpdates(e, "enterstage"), a[e].module.height !== a[e].module.lastHeight && (a[e].module.lastHeight = a[e].module.height, window.requestAnimationFrame(function () {
        window.innerHeight !== screen.height && Math.round(window.innerHeight * window.devicePixelRatio) !== screen.height && m(e, i, !1);
      })), tpGS.gsap.delayedCall(.1, function () {
        a[e].lastScrollBarWidth !== a.scrollBarWidth ? (a.updateDims(e, "ignore"), m(e)) : a.isModalOpen || a.scrollBarWidth === window.innerWidth - document.documentElement.clientWidth || a.rAfScrollbar === i && (a.rAfScrollbar = requestAnimationFrame(function () {
          a.rAfScrollbar = i, a.getWindowDimension(e, !1);
        }));
      }), d;
    },
    getSlideIndex: function getSlideIndex(e, i) {
      var t = !1;
      for (var r in a[e].slides) {
        if (!a[e].slides.hasOwnProperty(r) || !1 !== t) continue;
        t = a.gA(a[e].slides[r], "key") === i ? r : t;
      }
      return !1 === t ? 0 : t;
    },
    loadUpcomingContent: function loadUpcomingContent(e) {
      if ("smart" == a[e].lazyType) {
        var i = [],
          t = parseInt(a.getSlideIndex(e, a.gA(a[e].pr_next_slide[0], "key")), 0),
          r = t - 1 < 0 ? a[e].realslideamount - 1 : t - 1,
          o = t + 1 == a[e].realslideamount ? 0 : t + 1;
        r !== t && i.push(a[e].slides[r]), o !== t && i.push(a[e].slides[o]), i.length > 0 && (a.loadImages(i, e, 2), a.waitForCurrentImages(i, e, function () {}));
      }
    },
    lazyLoadAllSlides: function lazyLoadAllSlides(e) {
      if ("all" == a[e].lazyType && !0 !== a[e].lazyLoad_AllDone && (a[e].viewPort.enable && a[e].inviewport || !a[e].viewPort.enable)) {
        for (var i in a[e].slides) a[e].slides.hasOwnProperty(i) && (a.loadImages(a[e].slides[i], e, i), a.waitForCurrentImages(a[e].slides[i], e, function () {}));
        a[e].lazyLoad_AllDone = !0;
      }
    },
    getFullscreenOffsets: function getFullscreenOffsets(t) {
      var r = 0;
      if (a[t].fullScreenOffsetContainer != i) {
        var o = ("" + a[t].fullScreenOffsetContainer).split(",");
        for (var s in o) o.hasOwnProperty(s) && (r += e(o[s]).outerHeight(!0) || 0);
      }
      return a[t].fullScreenOffset != i && (!a.isNumeric(a[t].fullScreenOffset) && a[t].fullScreenOffset.split("%").length > 1 ? r += a.getWinH(t) * parseInt(a[t].fullScreenOffset, 0) / 100 : a.isNumeric(parseInt(a[t].fullScreenOffset, 0)) && (r += parseInt(a[t].fullScreenOffset, 0) || 0)), a[t].fullScreenOffsetResult = r, r;
    },
    unToggleState: function unToggleState(e) {
      if (e !== i) for (var t = 0; t < e.length; t++) try {
        document.getElementById(e[t]).classList.remove("rs-tc-active");
      } catch (e) {}
    },
    toggleState: function toggleState(e) {
      if (e !== i) for (var t = 0; t < e.length; t++) try {
        document.getElementById(e[t]).classList.add("rs-tc-active");
      } catch (e) {}
    },
    swaptoggleState: function swaptoggleState(e) {
      if (e != i && e.length > 0) for (var t = 0; t < e.length; t++) {
        var r = document.getElementById(e[t]);
        if (a.gA(r, "toggletimestamp") !== i && new Date().getTime() - a.gA(r, "toggletimestamp") < 250) return;
        a.sA(r, "toggletimestamp", new Date().getTime()), null !== r && (r.className.indexOf("rs-tc-active") >= 0 ? r.classList.remove("rs-tc-active") : r.classList.add("rs-tc-active"));
      }
    },
    lastToggleState: function lastToggleState(e) {
      var t;
      if (e !== i) for (var a = 0; a < e.length; a++) {
        var r = document.getElementById(e[a]);
        t = !0 === t || null !== r && r.className.indexOf("rs-tc-active") >= 0 || t;
      }
      return t;
    },
    revCheckIDS: function revCheckIDS(t, r) {
      if (a.gA(r, "idcheck") === i) {
        var o = r.id,
          s = e.inArray(r.id, window.RSANYID),
          n = -1;
        -1 !== s && (n = e.inArray(r.id, a[t].anyid), window.RSANYID_sliderID[s] === t && -1 === n || (r.id = r.id + "_" + Math.round(9999 * Math.random()), console.log("Warning - ID:" + o + " exists already. New Runtime ID:" + r.id), s = n = -1)), -1 === n && a[t].anyid.push(r.id), -1 === s && (window.RSANYID.push(r.id), window.RSANYID_sliderID.push(t));
      }
      return a.sA(r, "idcheck", !0), r.id;
    },
    buildSpinner: function buildSpinner(t, a, r, o) {
      var s;
      if ("off" !== a) {
        o = o === i ? "" : o, r = r === i ? "#ffffff" : r;
        var n = parseInt(a.replace("spinner", ""), 10);
        if (isNaN(n) || n < 6) {
          var d = 'style="background-color:' + r + '"',
            l = o === i || 3 !== n && 4 != n ? "" : d;
          s = e("<rs-loader " + (o === i || 1 !== n && 2 != n ? "" : d) + ' class="' + a + " " + o + '"><div ' + l + ' class="dot1"></div><div ' + l + ' class="dot2"></div><div ' + l + ' class="bounce1"></div><div ' + l + ' class="bounce2"></div><div ' + l + ' class="bounce3"></div></rs-loader>');
        } else {
          var c,
            p = '<div class="rs-spinner-inner"';
          if (7 === n) -1 !== r.search("#") ? (c = r.replace("#", ""), c = "rgba(" + parseInt(c.substring(0, 2), 16) + ", " + parseInt(c.substring(2, 4), 16) + ", " + parseInt(c.substring(4, 6), 16) + ", ") : -1 !== r.search("rgb") && (c = r.substring(r.indexOf("(") + 1, r.lastIndexOf(")")).split(",")).length > 2 && (c = "rgba(" + c[0].trim() + ", " + c[1].trim() + ", " + c[2].trim() + ", "), c && "string" == typeof c && (p += ' style="border-top-color: ' + c + "0.65); border-bottom-color: " + c + "0.15); border-left-color: " + c + "0.65); border-right-color: " + c + '0.15)"');else 12 === n && (p += ' style="background:' + r + '"');
          p += ">";
          for (var g = [10, 0, 4, 2, 5, 9, 0, 4, 4, 2][n - 6], u = 0; u < g; u++) u > 0 && (p += " "), p += '<span style="background:' + r + '"></span>';
          s = e('<rs-loader class="' + a + " " + o + '">' + (p += "</div>") + "</div></rs-loader>");
        }
        return s;
      }
    },
    addStaticLayerTo: function addStaticLayerTo(e, i, t) {
      if (a[e].slayers.length < 2) {
        var r = document.createElement("rs-static-layers");
        r.className = "rs-stl-" + i, r.appendChild(t[0]), a[e].c[0].appendChild(r), a[e].slayers.push(r);
      } else a[e].slayers[1].appendChild(t[0]);
    }
  });
  var r = function r() {
      return a.isIE11() ? function (e, i) {
        return e.querySelectorAll(i);
      } : function (e, i) {
        return e.getElementsByTagName(i);
      };
    },
    o = function o(e) {
      a[e].responsiveLevels = a.revToResp(a[e].responsiveLevels, a[e].rle), a[e].visibilityLevels = a.revToResp(a[e].visibilityLevels, a[e].rle), a[e].responsiveLevels[0] = 9999, a[e].rle = a[e].responsiveLevels.length || 1, a[e].gridwidth = a.revToResp(a[e].gridwidth, a[e].rle), a[e].gridheight = a.revToResp(a[e].gridheight, a[e].rle), a[e].editorheight !== i && (a[e].editorheight = a.revToResp(a[e].editorheight, a[e].rle)), a.updateDims(e);
    },
    s = function s(i, t) {
      var a = [];
      return e.each(i, function (e, i) {
        e != t && a.push(i);
      }), a;
    },
    n = function n(i, t, r) {
      a[r].c.find(i).each(function () {
        var i = e(this);
        i.data("key") === t && i.remove();
      });
    },
    d = function d(e, t) {
      if (a["rsfont_" + e] == i && (a["rsfont_" + e] = document.createElement("span"), a["rsfont_" + e].innerHTML = Array(100).join("wi"), a["rsfont_" + e].style.cssText = ["position:absolute", "width:auto", "font-size:128px", "left:-99999px"].join(" !important;"), a["rsfont_" + e].style.fontFamily = e, document.body.appendChild(a["rsfont_" + e])), t === i) return a["rsfont_" + e].clientWidth;
      document.body.removeChild(a["rsfont_" + e]);
    },
    l = function l(i, t) {
      var a = 0;
      return i.find(t).each(function () {
        var i = e(this);
        !i.hasClass("tp-forcenotvisible") && a < i.outerWidth() && (a = i.outerWidth());
      }), a;
    },
    c = function c(t) {
      if (t === i || a[t] === i || a[t].c === i) return !1;
      if (a[t].cpar !== i && a[t].cpar.data("aimg") != i && ("enabled" == a[t].cpar.data("aie8") && a.isIE(8) || "enabled" == a[t].cpar.data("amobile") && a.ISM)) a[t].c.html('<img class="tp-slider-alternative-image" src="' + a[t].cpar.data("aimg") + '">');else {
        window._rs_firefox13 = !1, window._rs_firefox = a.isFirefox(), window._rs_ie = window._rs_ie === i ? !e.support.opacity : window._rs_ie, window._rs_ie9 = window._rs_ie9 === i ? 9 == document.documentMode : window._rs_ie9;
        var r = e.fn.jquery.split("."),
          o = parseFloat(r[0]),
          s = parseFloat(r[1]);
        1 == o && s < 7 && a[t].c.html('<div style="text-align:center; padding:40px 0px; font-size:20px; color:#992222;"> The Current Version of jQuery:' + r + " <br>Please update your jQuery Version to min. 1.7 in Case you wish to use the Revolution Slider Plugin</div>"), o > 1 && (window._rs_ie = !1), a[t].realslideamount = a[t].slideamount = 0;
        var n = a.getByTag(a[t].canvas[0], "RS-SLIDE"),
          d = [];
        for (var l in a[t].notInNav = [], a[t].slides = [], n) n.hasOwnProperty(l) && ("on" == a.gA(n[l], "hsom") && a.ISM ? d.push(n[l]) : (a.gA(n[l], "invisible") || 1 == a.gA(n[l], "invisible") ? a[t].notInNav.push(n[l]) : (a[t].slides.push(n[l]), a[t].slideamount++), a[t].realslideamount++, a.sA(n[l], "originalindex", a[t].realslideamount), a.sA(n[l], "origindex", a[t].realslideamount - 1)));
        for (l in d) d.hasOwnProperty(l) && d[l].remove();
        for (l in a[t].notInNav) a[t].notInNav.hasOwnProperty(l) && (a.sA(a[t].notInNav[l], "not_in_nav", !0), a[t].canvas[0].appendChild(a[t].notInNav[l]));
        if (a[t].canvas.css({
          visibility: "visible"
        }), a[t].slayers = a[t].c.find("rs-static-layers"), a[t].slayers.length > 0 && a.sA(a[t].slayers[0], "key", "staticlayers"), !0 === a[t].modal.useAsModal && (a[t].cpar.wrap('<rs-modal id="' + a[t].c[0].id + '_modal"></rs-modal>'), a[t].modal.c = e(a.closestNode(a[t].cpar[0], "RS-MODAL")), a[t].modal.c.appendTo(e("body")), a[t].modal !== i && a[t].modal.alias !== i && a.revModal(t, {
          mode: "init"
        })), 1 == a[t].waitForInit || 1 == a[t].modal.useAsModal) return a.RS_toInit !== i && (a.RS_toInit[t] = !0), a[t].c.trigger("revolution.slide.waitingforinit"), void (a[t].waitingForInit = !0);
        window.requestAnimationFrame(function () {
          u(t);
        }), a[t].initEnded = !0;
      }
    },
    p = function p() {
      e("body").data("rs-fullScreenMode", !e("body").data("rs-fullScreenMode")), e("body").data("rs-fullScreenMode") && setTimeout(function () {
        a.window.trigger("resize");
      }, 200);
    },
    g = function g(e, t, r) {
      return a.gA(e, "lazyload") !== i ? a.gA(e, "lazyload") : a[r].lazyloaddata !== i && a[r].lazyloaddata.length > 0 && a.gA(e, a[r].lazyloaddata) !== i ? a.gA(e, a[r].lazyloaddata) : a.gA(e, "lazy-src") !== i ? a.gA(e, "lazy-src") : a.gA(e, "lazy-wpfc-original-src") !== i ? a.gA(e, "lazy-wpfc-original-src") : a.gA(e, "lazy") !== i ? a.gA(e, "lazy") : t;
    },
    u = function u(t) {
      if (a[t] !== i) {
        if (a[t].sliderisrunning = !0, !0 !== a[t].noDetach && a[t].c.detach(), a[t].shuffle) {
          for (var r = a[t].canvas.find("rs-slide:first-child"), o = a.gA(r[0], "firstanim"), s = 0; s < a[t].slideamount; s++) a[t].canvas.find("rs-slide:eq(" + Math.round(Math.random() * a[t].slideamount) + ")").prependTo(a[t].canvas);
          a.sA(a[t].canvas.find("rs-slide:first-child")[0], "firstanim", o);
        }
        a[t].slides = a.getByTag(a[t].canvas[0], "RS-SLIDE"), a[t].thumbs = new Array(a[t].slides.length), a[t].slots = 1, a[t].firststart = 1, a[t].loadqueue = [], a[t].syncload = 0;
        var n = 0,
          d = "carousel" === a[t].sliderType && a[t].carousel.border_radius !== i ? parseInt(a[t].carousel.border_radius, 0) : 0;
        for (var l in a[t].slides) if (a[t].slides.hasOwnProperty(l) && "length" !== l) {
          var c = a[t].slides[l],
            u = a.getByTag(c, "IMG")[0];
          a.gA(c, "key") === i && a.sA(c, "key", "rs-" + Math.round(999999 * Math.random()));
          var h = {
            params: Array(12),
            id: a.gA(c, "key"),
            src: a.gA(c, "thumb") !== i ? a.gA(c, "thumb") : g(u, u !== i ? u.src : i, t)
          };
          a.gA(c, "title") === i && a.sA(c, "title", ""), a.gA(c, "description") === i && a.sA(c, "description", ""), h.params[0] = {
            from: RegExp("\\{\\{title\\}\\}", "g"),
            to: a.gA(c, "title")
          }, h.params[1] = {
            from: RegExp("\\{\\{description\\}\\}", "g"),
            to: a.gA(c, "description")
          };
          for (var v = 1; v <= 10; v++) a.gA(c, "p" + v) !== i ? h.params[v + 1] = {
            from: RegExp("\\{\\{param" + v + "\\}\\}", "g"),
            to: a.gA(c, "p" + v)
          } : h.params[v + 1] = {
            from: RegExp("\\{\\{param" + v + "\\}\\}", "g"),
            to: ""
          };
          if (a[t].thumbs[n] = e.extend({}, !0, h), d > 0 && tpGS.gsap.set(c, {
            borderRadius: d + "px"
          }), a.gA(c, "link") != i || a.gA(c, "linktoslide") !== i) {
            var y = a.gA(c, "link") !== i ? a.gA(c, "link") : "slide",
              w = "slide" != y ? "no" : a.gA(c, "linktoslide"),
              b = a.gA(c, "seoz");
            if (w != i && "no" != w && "next" != w && "prev" != w) for (var _ in a[t].slides) a[t].slides.hasOwnProperty(_) && parseInt(a.gA(a[t].slides[_], "origindex"), 0) + 1 == a.gA(c, "linktoslide") && (w = a.gA(a[t].slides[_], "key"));
            e(c).prepend('<rs-layer class="rs-layer slidelink" id="rs_slidelink_' + Math.round(1e5 * Math.random()) + '" data-zindex="' + ("back" === b ? 0 : "front" === b ? 95 : b !== i ? parseInt(b, 0) : 100) + '" dataxy="x:c;y:c" data-dim="w:100%;h:100%" data-basealign="slide"' + ("no" == w ? "slide" == y || a.ISM ? "" : "  data-actions='o:click;a:simplelink;target:" + (a.gA(c, "target") || "_self") + ";url:" + y + ";'" : "  data-actions='" + ("scroll_under" === w ? "o:click;a:scrollbelow;offset:100px;" : "prev" === w ? "o:click;a:jumptoslide;slide:prev;d:0.2;" : "next" === w ? "o:click;a:jumptoslide;slide:next;d:0.2;" : "o:click;a:jumptoslide;slide:" + w + ";d:0.2;") + "'") + " data-frame_1='e:power3.inOut;st:100;sp:100' data-frame_999='e:power3.inOut;o:0;st:w;sp:100'>" + (a.ISM ? "<a " + ("slide" != y ? ("_blank" === a.gA(c, "target") ? 'rel="noopener" ' : "") + 'target="' + (a.gA(c, "target") || "_self") + '" href="' + y + '"' : "") + "><span></span></a>" : "") + "</rs-layer>");
          }
          n++;
        }
        if (a[t].simplifyAll && (a.isIE(8) || a.iOSVersion()) && (a[t].c.find(".rs-layer").each(function () {
          var i = e(this);
          i.removeClass("customin customout").addClass("fadein fadeout"), i.data("splitin", ""), i.data("speed", 400);
        }), a[t].c.find("rs-slide").each(function () {
          var i = e(this);
          i.data("transition", "fade"), i.data("masterspeed", 500), i.data("slotamount", 1), (i.find(".rev-slidebg") || i.find(">img").first()).data("panzoom", null);
        })), window._rs_desktop = window._rs_desktop === i ? !navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry|BB10|mobi|tablet|opera mini|nexus 7)/i) : window._rs_desktop, a[t].autoHeight = "fullscreen" == a[t].sliderLayout || a[t].autoHeight, "fullwidth" != a[t].sliderLayout || a[t].autoHeight || a[t].c.css({
          maxHeight: a[t].gridheight[a[t].level] + "px"
        }), "auto" == a[t].sliderLayout || null !== a.closestNode(a[t].c[0], "RS-FULLWIDTH-WRAP") || "fullscreen" === a[t].sliderLayout && 1 == a[t].disableForceFullWidth) a[t].topc = a[t].cpar;else {
          var S = a[t].cpar[0].style.marginTop,
            x = a[t].cpar[0].style.marginBottom;
          S = S === i || "" === S ? "" : "margin-top:" + S + ";", x = x === i || "" === x ? "" : "margin-bottom:" + x + ";", a[t].rsFullWidthWrap = a[t].topc = e('<rs-fullwidth-wrap id="' + a[t].c[0].id + '_forcefullwidth" style="' + S + x + '"></rs-fullwidth-wrap>'), a[t].forcer = e('<rs-fw-forcer style="height:' + (a[t].forcerHeight === i ? a[t].cpar.height() : a[t].forcerHeight) + 'px"></rs-fw-forcer>'), a[t].topc.append(a[t].forcer), a[t].topc.insertBefore(a[t].cpar), a[t].cpar.detach(), a[t].cpar.css({
            marginTop: "0px",
            marginBottom: "0px",
            position: "absolute"
          }), a[t].cpar.prependTo(a[t].topc);
        }
        if (a[t].forceOverflow && a[t].topc[0].classList.add("rs-forceoverflow"), "carousel" === a[t].sliderType && !0 !== a[t].overflowHidden && a[t].c.css({
          overflow: "visible"
        }), 0 !== a[t].maxHeight && tpGS.gsap.set([a[t].cpar, a[t].c, a[t].topc], {
          maxHeight: a[t].maxHeight + "px"
        }), a[t].fixedOnTop && tpGS.gsap.set(a[t].blockSpacing !== i && a[t].blockSpacing.block !== i ? a[t].blockSpacing.block : a[t].topc, {
          position: "fixed",
          top: "0px",
          left: "0px",
          pointerEvents: "none",
          zIndex: 5e3
        }), a[t].shadow !== i && a[t].shadow > 0 && a[t].cpar.addClass("tp-shadow" + a[t].shadow).append('<div class="tp-shadowcover" style="background-color:' + a[t].cpar.css("backgroundColor") + ";background-image:" + a[t].cpar.css("backgroundImage") + '"></div>'), a.updateDims(t, "prepared"), a.observeWraps === i && (a.observeWraps = new a.wrapObserver.init(function (e, t) {
          m(t, i, !0);
        })), !a[t].c.hasClass("revslider-initialised")) {
          a[t].c[0].classList.add("revslider-initialised"), a[t].c[0].id = a[t].c[0].id === i ? "revslider-" + Math.round(1e3 * Math.random() + 5) : a[t].c[0].id, a.revCheckIDS(t, a[t].c[0]), a[t].origcd = parseInt(a[t].duration, 0), a[t].scrolleffect._L = [], a[t].sbas = a[t].sbas === i ? {} : a[t].sbas, a[t].layers = a[t].layers || {}, a[t].sortedLayers = a[t].sortedLayers || {};
          var k = a[t].c[0].querySelectorAll("rs-layer, rs-row, rs-column, rs-group,  rs-bgvideo, .rs-layer");
          for (var L in k) if (k.hasOwnProperty(L)) {
            var R,
              O,
              I = e(k[L]),
              M = I.data();
            if (M.startclasses = k[L].className, M.startclasses = M.startclasses === i || null === M.startclasses ? "" : M.startclasses, M.animationonscroll = !!a[t].sbtimeline.set && a[t].sbtimeline.layers, M.animationonscroll = !0 === M.animationonscroll || "true" == M.animationonscroll, M.filteronscroll = !!a[t].scrolleffect.set && a[t].scrolleffect.layers, M.pxundermask = M.startclasses.indexOf("rs-pxmask") >= 0 && "off" !== a[t].parallax.type && M.startclasses.indexOf("rs-pxl-") >= 0, M.noPevents = M.startclasses.indexOf("rs-noevents") >= 0, M.sba) for (var v in R = M.sba.split(";")) R.hasOwnProperty(v) && ("t" == (O = R[v].split(":"))[0] && (M.animationonscroll = O[1], "false" == O[1] && (M.animOnScrollForceDisable = !0)), "e" == O[0] && (M.filteronscroll = O[1]), "so" == O[0] && (M.scrollBasedOffset = parseInt(O[1]) / 1e3));
            if ("true" != M.animationonscroll && 1 != M.animationonscroll || (M.startclasses += " rs-sba", I[0].className += " rs-sba"), M.startclasses.indexOf("rs-layer-static") >= 0 && a.handleStaticLayers && a.handleStaticLayers(I, t), "RS-BGVIDEO" !== I[0].tagName) {
              if (I[0].classList.add("rs-layer"), "column" === M.type && (M.columnwidth = "33.33%", M.verticalalign = "top", M.column !== i)) for (var T in R = M.column.split(";")) R.hasOwnProperty(T) && ("w" === (O = R[T].split(":"))[0] && (M.columnwidth = O[1]), "a" === O[0] && (M.verticalalign = O[1]));
              var C = M.startclasses.indexOf("slidelink") >= 0 ? "z-index:" + M.zindex + ";width:100% !important;height:100% !important;" : "",
                A = "column" !== M.type ? "" : M.verticalalign === i ? " vertical-align:top;" : " vertical-align:" + M.verticalalign + ";",
                B = "row" === M.type || "column" === M.type ? "position:relative;" : "position:absolute;",
                z = "",
                G = "row" === M.type ? "rs-row-wrap" : "column" === M.type ? "rs-column-wrap" : "group" === M.type ? "rs-group-wrap" : "rs-layer-wrap",
                E = "",
                N = "",
                F = (M.noPevents, ";pointer-events:none");
              "row" === M.type || "column" === M.type || "group" === M.type ? (I[0].classList.remove("tp-resizeme"), "column" === M.type && (M.width = "auto", I[0].group = "row", tpGS.gsap.set(I, {
                width: "auto"
              }), M.filteronscroll = !1)) : (E = "display:" + ("inline-block" === I[0].style.display ? "inline-block" : "block") + ";", null !== a.closestNode(I[0], "RS-COLUMN") ? (I[0].group = "column", M.filteronscroll = !1) : null !== a.closestNode(I[0], "RS-GROUP-WRAP") && (I[0].group = "group", M.filteronscroll = !1)), M.wrpcls !== i && (z = z + " " + M.wrpcls), M.wrpid !== i && (N = 'id="' + M.wrpid + '"'), I.wrap("<" + G + " " + N + ' class="rs-parallax-wrap ' + z + '" style="' + A + " " + C + B + E + F + '"><rs-loop-wrap style="' + C + B + E + '"><rs-mask-wrap style="' + C + B + E + '">' + (M.pxundermask ? "<rs-px-mask></rs-px-mask>" : "") + "</rs-mask-wrap></rs-loop-wrap></" + G + ">"), !0 !== M.filteronscroll && "true" != M.filteronscroll || a[t].scrolleffect._L.push(I.parent()), I[0].id = I[0].id === i ? "layer-" + Math.round(999999999 * Math.random()) : I[0].id, a.revCheckIDS(t, I[0]), M.pxundermask ? a[t]._Lshortcuts[I[0].id] = {
                p: e(I[0].parentNode.parentNode.parentNode.parentNode),
                lp: e(I[0].parentNode.parentNode.parentNode),
                m: e(I[0].parentNode.parentNode)
              } : a[t]._Lshortcuts[I[0].id] = {
                p: e(I[0].parentNode.parentNode.parentNode),
                lp: e(I[0].parentNode.parentNode),
                m: e(I[0].parentNode)
              }, "column" === M.type && a[t]._Lshortcuts[I[0].id].p.append('<rs-cbg-mask-wrap><rs-column-bg id="' + I[0].id + '_rs_cbg"></rs-column-bg></rs-cbg-mask-wrap>'), "text" === M.type && a.getByTag(I[0], "IFRAME").length > 0 && (a[t].slideHasIframe = !0, I[0].classList.add("rs-ii-o")), a[t].BUG_safari_clipPath && "true" != M.animationonscroll && 1 != M.animationonscroll && I[0].classList.add("rs-pelock"), I[0].dataset.staticz !== i && "row" !== M.type && "row" !== I[0].group && "column" !== I[0].group && a.addStaticLayerTo(t, I[0].dataset.staticz, a[t]._Lshortcuts[I[0].id].p);
            }
            a.gA(I[0], "actions") && a.checkActions && a.checkActions(I, t, a[t]), !a.checkVideoApis || window.rs_addedvim && window.rs_addedyt || a[t].youtubeapineeded && a[t].vimeoapineeded || a.checkVideoApis(I, t);
          }
          a.checkActions && a.checkActions(i, t), a[t].c[0].addEventListener("mousedown", function () {
            if (!0 !== a[t].onceClicked && (a[t].onceClicked = !0, !0 !== a[t].onceVideoPlayed && a[t].activeRSSlide !== i && a[t].slides !== i && a[t].slides[a[t].activeRSSlide] !== i)) {
              var r = e(a[t].slides[a[t].activeRSSlide]).find("rs-bgvideo");
              r !== i && null !== r && r.length > 0 && a.playVideo(r, t);
            }
          }), a[t].c[0].addEventListener("mouseenter", function () {
            a[t].c.trigger("tp-mouseenter"), a[t].overcontainer = !0;
          }, {
            passive: !0
          }), a[t].c[0].addEventListener("mouseover", function () {
            a[t].c.trigger("tp-mouseover"), a[t].overcontainer = !0;
          }, {
            passive: !0
          }), a[t].c[0].addEventListener("mouseleave", function () {
            a[t].c.trigger("tp-mouseleft"), a[t].overcontainer = !1;
          }, {
            passive: !0
          }), a[t].c.find(".rs-layer video").each(function (i) {
            var t = e(this);
            t.removeClass("video-js vjs-default-skin"), t.attr("preload", ""), t.css({
              display: "none"
            });
          }), a[t].rs_static_layer = a.getByTag(a[t].c[0], "RS-STATIC-LAYERS"), a.preLoadAudio && a[t].rs_static_layer.length > 0 && a.preLoadAudio(e(a[t].rs_static_layer), t, 1), a[t].rs_static_layer.length > 0 && (a.loadImages(a[t].rs_static_layer[0], t, 0, !0), a.waitForCurrentImages(a[t].rs_static_layer[0], t, function () {
            a[t] !== i && a[t].c.find("rs-static-layers img").each(function () {
              this.src = a.getLoadObj(t, a.gA(this, "src") != i ? a.gA(this, "src") : this.src).src;
            });
          })), a[t].rowzones = [], a[t].rowzonesHeights = [], a[t].topZones = [], a[t].middleZones = [], a[t].bottomZones = [];
          var H = a.deepLink(t, P("#")[0]);
          H !== i && (a[t].startWithSlide = H, a[t].deepLinkListener = !0, window.addEventListener("hashchange", function () {
            if (!0 !== a[t].ignoreDeeplinkChange) {
              var e = a.deepLink(t, P("#")[0]);
              e !== i && a.callingNewSlide(t, e, !0);
            }
            a[t].ignoreDeeplinkChange = !1;
          })), a[t].loader = a.buildSpinner(t, a[t].spinner, a[t].spinnerclr), a[t].loaderVisible = !0, a[t].c.append(a[t].loader), f(t), ("off" !== a[t].parallax.type || a[t].scrolleffect.set || a[t].sbtimeline.set) && a.checkForParallax && a.checkForParallax(t), a[t].fallbacks.disableFocusListener || "true" == a[t].fallbacks.disableFocusListener || !0 === a[t].fallbacks.disableFocusListener || (a[t].c.addClass("rev_redraw_on_blurfocus"), D());
          var j = a[t].viewPort;
          for (var v in "on" === a[t].navigation.mouseScrollNavigation && (j.enable = !0), a[t].slides) if (a[t].slides.hasOwnProperty(v)) {
            var W = e(a[t].slides[v]);
            a[t].rowzones[v] = [], a[t].rowzonesHeights[v] = [], a[t].topZones[v] = [], a[t].middleZones[v] = [], a[t].bottomZones[v] = [], W.find("rs-zone").each(function () {
              a[t].rowzones[v].push(e(this)), this.className.indexOf("rev_row_zone_top") >= 0 && a[t].topZones[v].push(this), this.className.indexOf("rev_row_zone_middle") >= 0 && a[t].middleZones[v].push(this), this.className.indexOf("rev_row_zone_bottom") >= 0 && a[t].bottomZones[v].push(this);
            });
          }
          a.lazyLoadAllSlides(t), a[t].srowzones = [], a[t].smiddleZones = [], a[t].slayers && a[t].slayers.find("rs-zone").each(function () {
            a[t].srowzones.push(e(this)), this.className.indexOf("rev_row_zone_middle") >= 0 && a[t].smiddleZones.push(this);
          }), "carousel" === a[t].sliderType && tpGS.gsap.set(a[t].canvas, {
            scale: 1,
            perspective: 1200,
            transformStyle: "flat",
            opacity: 0
          }), a[t].c.prependTo(a[t].cpar), e("body").data("rs-fullScreenMode", !1), window.addEventListener("fullscreenchange", p, {
            passive: !0
          }), window.addEventListener("mozfullscreenchange", p, {
            passive: !0
          }), window.addEventListener("webkitfullscreenchange", p, {
            passive: !0
          }), a.document.on("updateContainerSizes." + a[t].c.attr("id"), function () {
            if (a[t] !== i) return a[t].c != i && void (a.updateDims(t, "ignore") && window.requestAnimationFrame(function () {
              a.updateDims(t, "ignore"), a[t].fullScreenMode = a.checkfullscreenEnabled(t), a.lastwindowheight = a.getWinH(t), m(t);
            }));
          }), j.presize && (a[t].pr_next_slide = e(a[t].slides[0]), a.loadImages(a[t].pr_next_slide[0], t, 0, !0), a.waitForCurrentImages(a[t].pr_next_slide.find(".tp-layers"), t, function () {
            a.animateTheLayers && a.animateTheLayers({
              slide: a[t].pr_next_key,
              id: t,
              mode: "preset",
              caller: "runSlider"
            });
          })), ("off" != a[t].parallax.type || a[t].sbtimeline.set || !0 === j.enable) && a.scrollTicker(t), !0 !== j.enable && (a[t].inviewport = !0, a.enterViewPort(t)), a.RS_toInit !== i && (a.RS_toInit[t] = !0), a[t].observeWrap && a.observeWraps && a.wrapObserver.observe(a[t].rsFullWidthWrap !== i ? a[t].rsFullWidthWrap[0] : a[t].cpar[0], t);
        }
      }
    },
    h = function h(e, t) {
      a.winW < a[e].hideSliderAtLimit ? (a[e].c.trigger("stoptimer"), !0 !== a[e].sliderIsHidden && (a.sA(a[e].cpar[0], "displaycache", "none" != a[e].cpar.css("display") ? a[e].cpar.css("display") : a.gA(a[e].cpar[0], "displaycache")), a[e].cpar.css({
        display: "none"
      }), a[e].sliderIsHidden = !0)) : (!0 === a[e].sliderIsHidden || a[e].sliderIsHidden === i && a[e].c.is(":hidden")) && t && (a[e].cpar[0].style.display = a.gA(a[e].cpar[0], "displaycache") != i && "none" != a.gA(a[e].cpar[0], "displaycache") ? a.gA(a[e].cpar[0], "displaycache") : "block", a[e].sliderIsHidden = !1, a[e].c.trigger("restarttimer"), window.requestAnimationFrame(function () {
        m(e, !0);
      })), a.hideUnHideNav && a[e].navigation.use && a.hideUnHideNav(e);
    },
    m = function m(e, t, r) {
      if (a[e].c === i) return !1;
      if (a[e].dimensionReCheck = {}, a[e].c.trigger("revolution.slide.beforeredraw"), 1 == a[e].infullscreenmode && (a[e].minHeight = a.getWinH(e)), a.ISM && (a[e].lastMobileHeight = a.getWinH(e)), r && a.updateDims(e), !a.resizeThumbsTabs || !0 === a.resizeThumbsTabs(e)) {
        if (window.requestAnimationFrame(function () {
          h(e, !0 !== t), O(e);
        }), a[e].started) {
          if ("carousel" == a[e].sliderType) for (var o in a.prepareCarousel(e), a[e].sbgs) a[e].sbgs.hasOwnProperty(o) && a[e].sbgs[o].mDIM !== i && a.updateSlideBGs(e, a[e].sbgs[o].key, a[e].sbgs[o]);else a.updateSlideBGs(e);
          if ("carousel" === a[e].sliderType && a[e].carCheckconW != a[e].canv.width) {
            for (var s in clearTimeout(a[e].pcartimer), a[e].sbgs) a[e].sbgs[s].loadobj !== i && a.updateSlideBGs(e, a[e].sbgs[s].key, a[e].sbgs[s]);
            a[e].pcartimer = setTimeout(function () {
              a.prepareCarousel(e), a.animateTheLayers({
                slide: "individual",
                id: e,
                mode: "rebuild",
                caller: "containerResized_1"
              }), a[e].carCheckconW = a[e].canv.width;
            }, 100), a[e].lastconw = a[e].canv.width;
          }
          if (a[e].pr_processing_key !== i ? a.animateTheLayers({
            slide: a[e].pr_processing_key,
            id: e,
            mode: "rebuild",
            caller: "containerResized_2"
          }) : a[e].pr_active_key !== i && a.animateTheLayers({
            slide: a[e].pr_active_key,
            id: e,
            mode: "rebuild",
            caller: "containerResized_3"
          }), "carousel" === a[e].sliderType) {
            for (var s in a[e].panzoomTLs) if (a[e].panzoomTLs.hasOwnProperty(s)) {
              var n = a.gA(a[e].panzoomBGs[s][0], "key");
              a.startPanZoom(a[e].panzoomBGs[s], e, a[e].panzoomTLs[s].progress(), s, a[e].panzoomTLs[s].isActive() ? "play" : "reset", n);
            }
          } else a[e].pr_active_bg !== i && a[e].pr_active_bg[0] !== i && v(e, a[e].pr_active_bg, a[e].pr_active_bg[0].dataset.key), a[e].pr_next_bg !== i && a[e].pr_next_bg[0] !== i && v(e, a[e].pr_next_bg, a[e].pr_next_bg[0].dataset.key);
          clearTimeout(a[e].mNavigTimeout), a.manageNavigation && (a[e].mNavigTimeout = setTimeout(function () {
            a.manageNavigation(e);
          }, 20));
        }
        a.prepareCoveredVideo(e);
      }
      a[e].c.trigger("revolution.slide.afterdraw", [{
        id: e
      }]);
    },
    v = function v(e, t, r) {
      if (a[e].panzoomTLs !== i) {
        var o = a.getSlideIndex(e, r);
        a.startPanZoom(t, e, a[e].panzoomTLs[o] !== i ? a[e].panzoomTLs[o].progress() : 0, o, "play", r);
      }
    },
    f = function f(t) {
      !0 !== a[t].noDetach && a[t].canvas.detach();
      var r = a.isFaceBook() ? "visible" : "hidden";
      if (a[t].autoHeight && tpGS.gsap.set([a[t].c, a[t].cpar], {
        maxHeight: "none"
      }), tpGS.gsap.set(a[t].canvas, a[t].modal !== i && a[t].modal.useAsModal ? {
        overflow: r,
        width: "100%",
        height: "100%"
      } : {
        overflow: r,
        width: "100%",
        height: "100%",
        maxHeight: a[t].autoHeight ? "none" : a[t].cpar.css("maxHeight")
      }), "carousel" === a[t].sliderType) {
        var o = "margin-top:" + parseInt(a[t].carousel.padding_top || 0, 0) + "px;";
        a[t].canvas.css({
          overflow: "visible"
        }).wrap('<rs-carousel-wrap style="' + o + '"></rs-carousel-wrap>'), a[t].cpar.prepend("<rs-carousel-space></rs-carousel-space>").append("<rs-carousel-space></rs-carousel-space>"), a.defineCarouselElements(t);
      }
      a[t].startWithSlide = a[t].startWithSlide === i ? i : Math.max(1, (a[t].sliderType, parseInt(a[t].startWithSlide))), a[t].cpar.css({
        overflow: "visible"
      }), a[t].scrolleffect.bgs = [];
      for (var s = 0; s < a[t].slides.length; s++) {
        var n = e(a[t].slides[s]),
          d = a.gA(n[0], "key"),
          l = n.find(".rev-slidebg") || n.find(">img"),
          c = a[t].sbgs[d] = y(l.data(), t),
          p = n.data("mediafilter");
        if (c.skeyindex = a.getSlideIndex(t, d), c.bgvid = n.find("rs-bgvideo"), l.detach(), c.bgvid.detach(), (a[t].startWithSlide != i && a.gA(a[t].slides[s], "originalindex") == a[t].startWithSlide || a[t].startWithSlide === i && 0 == s) && (a[t].pr_next_key = n.index()), tpGS.gsap.set(n, {
          width: "100%",
          height: "100%",
          overflow: r
        }), l.wrap('<rs-sbg-px><rs-sbg-wrap data-key="' + d + '"></rs-sbg-wrap></rs-sbg-px>'), c.wrap = e(a.closestNode(l[0], "RS-SBG-WRAP")), c.src = l[0].src, c.lazyload = c.lazyload = g(l[0], i, t), c.slidebgimage = !0, c.loadobj = c.loadobj === i ? {} : c.loadobj, c.mediafilter = p = "none" === p || p === i ? "" : p, c.sbg = document.createElement("rs-sbg"), a[t].overlay !== i && "none" != a[t].overlay.type && a[t].overlay.type != i) {
          var u = a.createOverlay(t, a[t].overlay.type, a[t].overlay.size, {
            0: a[t].overlay.colora,
            1: a[t].overlay.colorb
          });
          c.wrap.append('<rs-dotted style="background-image:' + u + '"></rs-dotted>');
        }
        l.data("mediafilter", p), c.canvas = document.createElement("canvas"), c.sbg.appendChild(c.canvas), c.canvas.style.width = "100%", c.canvas.style.height = "100%", c.ctx = c.canvas.getContext("2d"), c.lazyload !== i && (c.sbg.dataset.lazyload = c.lazyload), c.sbg.className = p, c.sbg.src = c.src, c.sbg.dataset.bgcolor = c.bgcolor, c.sbg.style.width = "100%", c.sbg.style.height = "100%", c.key = d, c.wrap[0].dataset.key = d, e(c.sbg).data(c), c.wrap.data(c), c.wrap[0].appendChild(c.sbg);
        var h = document.createComment("Runtime Modification - Img tag is Still Available for SEO Goals in Source - " + l.get(0).outerHTML);
        l.replaceWith(h), a.gA(n[0], "sba") === i && a.sA(n[0], "sba", "");
        var m = {},
          v = a.gA(n[0], "sba").split(";");
        for (var f in v) if (v.hasOwnProperty(f)) {
          var w = v[f].split(":");
          switch (w[0]) {
            case "f":
              m.f = w[1];
              break;
            case "b":
              m.b = w[1];
              break;
            case "g":
              m.g = w[1];
              break;
            case "t":
              m.s = w[1];
          }
        }
        a.sA(n[0], "scroll-based", !!a[t].sbtimeline.set && m.s !== i && m.s), c.bgvid.length > 0 && (c.bgvidid = c.bgvid[0].id, c.animateDirection = "idle", c.bgvid.addClass("defaultvid").css({
          zIndex: 30
        }), p !== i && "" !== p && "none" !== p && c.bgvid.addClass(p), c.bgvid.appendTo(c.wrap), c.parallax != i && (c.bgvid.data("parallax", c.parallax), c.bgvid.data("showcoveronpause", "on"), c.bgvid.data("mediafilter", p)), c.poster = !1, (c.src !== i && -1 == c.src.indexOf("assets/dummy.png") && -1 == c.src.indexOf("assets/transparent.png") || c.lazyload !== i && -1 == c.lazyload.indexOf("assets/transparent.png") && -1 == c.lazyload.indexOf("assets/dummy.png")) && (c.poster = !0), c.bgvid.data("bgvideo", 1), c.bgvid[0].dataset.key = d, 0 == c.bgvid.find(".rs-fullvideo-cover").length && c.bgvid.append('<div class="rs-fullvideo-cover"></div>')), a[t].scrolleffect.set ? (a[t].scrolleffect.bgs.push({
          fade: m.f !== i ? m.f : !!a[t].scrolleffect.slide && a[t].scrolleffect.fade,
          blur: m.b !== i ? m.b : !!a[t].scrolleffect.slide && a[t].scrolleffect.blur,
          grayscale: m.g !== i ? m.g : !!a[t].scrolleffect.slide && a[t].scrolleffect.grayscale,
          c: c.wrap.wrap("<rs-sbg-effectwrap></rs-sbg-effectwrap>").parent()
        }), n.prepend(c.wrap.parent().parent())) : n.prepend(c.wrap.parent());
      }
      "carousel" === a[t].sliderType ? (tpGS.gsap.set(a[t].carousel.wrap, {
        opacity: 0
      }), a[t].c[0].appendChild(a[t].carousel.wrap[0])) : a[t].c[0].appendChild(a[t].canvas[0]);
    },
    y = function y(t, r) {
      t.bg = t.bg === i ? "" : t.bg;
      var o = t.bg.split(";"),
        s = {
          bgposition: "50% 50%",
          bgfit: "cover",
          bgrepeat: "no-repeat",
          bgcolor: "transparent"
        };
      for (var n in o) if (o.hasOwnProperty(n)) {
        var d = o[n].split(":"),
          l = d[0],
          c = d[1],
          p = "";
        switch (l) {
          case "p":
            p = "bgposition";
            break;
          case "f":
            p = "bgfit";
            break;
          case "r":
            p = "bgrepeat";
            break;
          case "c":
            p = "bgcolor";
        }
        p !== i && (s[p] = c);
      }
      return a[r].fallbacks.panZoomDisableOnMobile && a.ISM && (s.panzoom = i, s.bgfit = "cover", t.panzoom = i), e.extend(!0, t, s);
    },
    w = function w(e, t, r) {
      if (a[t] !== i) {
        a[t].syncload--;
        var o = a.gA(e, "reference");
        for (var s in a[t].loadqueue) a[t].loadqueue.hasOwnProperty(s) && "loaded" !== a[t].loadqueue[s].progress && o == a[t].loadqueue[s].src && (a[t].loadqueue[s].img = e, a[t].loadqueue[s].progress = r, a[t].loadqueue[s].width = e.naturalWidth, a[t].loadqueue[s].height = e.naturalHeight);
        b(t);
      }
    },
    b = function b(t) {
      4 != a[t].syncload && a[t].loadqueue && e.each(a[t].loadqueue, function (r, o) {
        if ("prepared" == o.progress && a[t].syncload <= 4) {
          if (a[t].syncload++, "img" == o.type) {
            var s = "IMG" == o.img.tagName ? o.img : new Image();
            a.sA(s, "reference", o.src), /^([\w]+\:)?\/\//.test(o.src) && -1 === o.src.indexOf(location.host) && "" !== a[t].imgCrossOrigin && a[t].imgCrossOrigin !== i && (s.crossOrigin = a[t].imgCrossOrigin), s.onload = function () {
              w(this, t, "loaded"), o.error = !1;
            }, s.onerror = function () {
              w(this, t, "failed"), o.error = !0;
            }, s.src = o.src, o.starttoload = e.now();
          } else e.get(o.src, function (e) {
            o.innerHTML = new XMLSerializer().serializeToString(e.documentElement), o.progress = "loaded", a[t].syncload--, b(t);
          }).fail(function () {
            o.progress = "failed", a[t].syncload--, b(t);
          });
          o.progress = "inload";
        }
      });
    },
    _ = function _(e, i) {
      return console.log("Static Image " + e + "  Could not be loaded in time. Error Exists:" + i), !0;
    },
    S = function S(i, t) {
      if (e.now() - a[t][i + "starttime"] > 5e3 && 1 != a[t][i + "warning"]) {
        a[t][i + "warning"] = !0;
        var r = i + " Api Could not be loaded !";
        "https:" === location.protocol && (r += " Please Check and Renew SSL Certificate !"), console.error(r), a[t].c.append('<div style="position:absolute;top:50%;width:100%;color:#e74c3c;  font-size:16px; text-align:center; padding:15px;background:#000; display:block;"><strong>' + r + "</strong></div>");
      }
      return !0;
    },
    x = function x(t) {
      a[t] !== i && (a[t].pr_active_slide = e(a[t].slides[a[t].pr_active_key]), a[t].pr_next_slide = e(a[t].slides[a[t].pr_processing_key]), a[t].pr_active_bg = a[t].pr_active_slide.find("rs-sbg-wrap"), a[t].pr_next_bg = a[t].pr_next_slide.find("rs-sbg-wrap"), a[t].pr_active_bg !== i && a[t].pr_active_bg.length > 0 && tpGS.gsap.to(a[t].pr_active_bg, .5, {
        opacity: 0
      }), a[t].pr_next_bg !== i && a[t].pr_next_bg.length > 0 && tpGS.gsap.to(a[t].pr_next_bg, .5, {
        opacity: 0
      }), tpGS.gsap.set(a[t].pr_active_slide, {
        zIndex: 18
      }), a[t].pr_next_slide !== i && a[t].pr_next_slide.length > 0 && tpGS.gsap.set(a[t].pr_next_slide, {
        autoAlpha: 0,
        zIndex: 20
      }), a[t].tonpause = !1, a[t].pr_active_key !== i && a.removeTheLayers(a[t].pr_active_slide, t, !0), a[t].firststart = 1, setTimeout(function () {
        delete a[t].pr_active_key, delete a[t].pr_processing_key;
      }, 200));
    },
    k = function k(t, r) {
      if (a[t] !== i) if (clearTimeout(a[t].waitWithSwapSlide), a[t].pr_processing_key === i || !0 !== a[t].firstSlideShown) {
        if (clearTimeout(a[t].waitWithSwapSlide), a[t].startWithSlideKey !== i && (a[t].pr_next_key = a.getComingSlide(t, a[t].startWithSlideKey).nindex, delete a[t].startWithSlideKey), a[t].pr_active_slide = e(a[t].slides[a[t].pr_active_key]), a[t].pr_next_slide = e(a[t].slides[a[t].pr_next_key]), a[t].pr_next_key == a[t].pr_active_key) return delete a[t].pr_next_key;
        var o = a.gA(a[t].pr_next_slide[0], "key");
        a[t].sbgs[o].bgvid && a[t].sbgs[o].bgvid.length > 0 && (a[t].videos == i || a[t].videos[a[t].sbgs[o].bgvid[0].id] === i) && a.manageVideoLayer(a[t].sbgs[o].bgvid, t, o), a[t].pr_processing_key = a[t].pr_next_key, a[t].pr_cache_pr_next_key = a[t].pr_next_key, delete a[t].pr_next_key, a[t].pr_next_slide !== i && a[t].pr_next_slide[0] !== i && a.gA(a[t].pr_next_slide[0], "hal") !== i && a.sA(a[t].pr_next_slide[0], "sofacounter", a.gA(a[t].pr_next_slide[0], "sofacounter") === i ? 1 : parseInt(a.gA(a[t].pr_next_slide[0], "sofacounter"), 0) + 1), a[t].stopLoop && a[t].pr_processing_key == a[t].lastslidetoshow - 1 && (a[t].progressC.css({
          visibility: "hidden"
        }), a[t].c.trigger("revolution.slide.onstop"), a[t].noloopanymore = 1), a[t].pr_next_slide.index() === a[t].slideamount - 1 && a[t].looptogo > 0 && "disabled" !== a[t].looptogo && (a[t].looptogo--, a[t].looptogo <= 0 && (a[t].stopLoop = !0)), a[t].tonpause = !0, a[t].slideInSwapTimer = !0, a[t].c.trigger("stoptimer"), "off" === a[t].spinner ? a[t].loader !== i && !0 === a[t].loaderVisible && (a[t].loader.css({
          display: "none"
        }), a[t].loaderVisible = !1) : a[t].loadertimer = setTimeout(function () {
          a[t].loader !== i && !0 !== a[t].loaderVisible && (a[t].loader.css({
            display: "block"
          }), a[t].loaderVisible = !0);
        }, 100);
        var s = "carousel" === a[t].sliderType && "all" !== a[t].lazyType ? a.loadVisibleCarouselItems(t) : a[t].pr_next_slide[0];
        a.loadImages(s, t, 1), a.preLoadAudio && a.preLoadAudio(a[t].pr_next_slide, t, 1), a.waitForCurrentImages(s, t, function () {
          a[t].firstSlideShown = !0, a[t].pr_next_slide.find("rs-bgvideo").each(function () {
            a.prepareCoveredVideo(t);
          }), a.loadUpcomingContent(t), window.requestAnimationFrame(function () {
            L(a[t].pr_next_slide.find("rs-sbg"), t, r);
          });
        });
      } else a[t].waitWithSwapSlide = setTimeout(function () {
        k(t, r);
      }, 18);
    },
    L = function L(t, r, o) {
      if (a[r] !== i) {
        if (O(r), a[r].pr_active_slide = e(a[r].slides[a[r].pr_active_key]), a[r].pr_next_slide = e(a[r].slides[a[r].pr_processing_key]), a[r].pr_active_bg = a[r].pr_active_slide.find("rs-sbg-wrap"), a[r].pr_next_bg = a[r].pr_next_slide.find("rs-sbg-wrap"), a[r].tonpause = !1, clearTimeout(a[r].loadertimer), a[r].loader !== i && !0 === a[r].loaderVisible && (window.requestAnimationFrame(function () {
          a[r].loader.css({
            display: "none"
          });
        }), a[r].loaderVisible = !1), a[r].onBeforeSwap = {
          slider: r,
          slideIndex: parseInt(a[r].pr_active_key, 0) + 1,
          slideLIIndex: a[r].pr_active_key,
          nextSlideIndex: parseInt(a[r].pr_processing_key, 0) + 1,
          nextSlideLIIndex: a[r].pr_processing_key,
          nextslide: a[r].pr_next_slide,
          slide: a[r].pr_active_slide,
          currentslide: a[r].pr_active_slide,
          prevslide: a[r].pr_lastshown_key !== i ? a[r].slides[a[r].pr_lastshown_key] : ""
        }, a[r].c.trigger("revolution.slide.onbeforeswap", a[r].onBeforeSwap), a[r].transition = 1, a[r].stopByVideo = !1, a[r].pr_next_slide[0] !== i && a.gA(a[r].pr_next_slide[0], "duration") != i && "" != a.gA(a[r].pr_next_slide[0], "duration") ? a[r].duration = parseInt(a.gA(a[r].pr_next_slide[0], "duration"), 0) : a[r].duration = a[r].origcd, a[r].pr_next_slide[0] === i || "true" != a.gA(a[r].pr_next_slide[0], "ssop") && !0 !== a.gA(a[r].pr_next_slide[0], "ssop") ? a[r].ssop = !1 : a[r].ssop = !0, a[r].sbtimeline.set && a[r].sbtimeline.fixed && a.updateFixedScrollTimes(r), a[r].c.trigger("nulltimer"), a[r].sdir = a[r].pr_processing_key < a[r].pr_active_key ? 1 : 0, "arrow" == a[r].sc_indicator && (0 == a[r].pr_active_key && a[r].pr_processing_key == a[r].slideamount - 1 && (a[r].sdir = 1), a[r].pr_active_key == a[r].slideamount - 1 && 0 == a[r].pr_processing_key && (a[r].sdir = 0)), a[r].lsdir = a[r].sdir, a[r].pr_active_key != a[r].pr_processing_key && 1 != a[r].firststart && "carousel" !== a[r].sliderType && a.removeTheLayers && a.removeTheLayers(a[r].pr_active_slide, r), 1 !== a.gA(a[r].pr_next_slide[0], "rspausetimeronce") && 1 !== a.gA(a[r].pr_next_slide[0], "rspausetimeralways") ? a[r].c.trigger("restarttimer") : (a[r].stopByVideo = !0, a.unToggleState(a[r].slidertoggledby)), a.sA(a[r].pr_next_slide[0], "rspausetimeronce", 0), a[r].pr_next_slide[0] !== i && a.sA(a[r].c[0], "slideactive", a.gA(a[r].pr_next_slide[0], "key")), "carousel" == a[r].sliderType) {
          if (a[r].mtl = tpGS.gsap.timeline(), a.prepareCarousel(r), R(r), a.updateSlideBGs(r), !0 !== a[r].carousel.checkFVideo) {
            var s = a.gA(a[r].pr_next_slide[0], "key");
            a[r].sbgs[s] !== i && a[r].sbgs[s].bgvid !== i && 0 !== a[r].sbgs[s].bgvid.length && a.playBGVideo(r, s), a[r].carousel.checkFVideo = !0;
          }
          a[r].transition = 0;
        } else {
          a[r].pr_lastshown_key = a[r].pr_lastshown_key === i ? a[r].pr_next_key !== i ? a[r].pr_next_key : a[r].pr_processing_key !== i ? a[r].pr_processing_key : a[r].pr_active_key !== i ? a[r].pr_active_key : a[r].pr_lastshown_key : a[r].pr_lastshown_key, a[r].mtl = tpGS.gsap.timeline({
            paused: !0,
            onComplete: function onComplete() {
              R(r);
            }
          }), a[r].pr_next_key !== i ? a.animateTheLayers({
            slide: a[r].pr_next_key,
            id: r,
            mode: "preset",
            caller: "swapSlideProgress_1"
          }) : a[r].pr_processing_key !== i ? a.animateTheLayers({
            slide: a[r].pr_processing_key,
            id: r,
            mode: "preset",
            caller: "swapSlideProgress_2"
          }) : a[r].pr_active_key !== i && a.animateTheLayers({
            slide: a[r].pr_active_key,
            id: r,
            mode: "preset",
            caller: "swapSlideProgress_3"
          }), 1 == a[r].firststart && (a[r].pr_active_slide[0] !== i && tpGS.gsap.set(a[r].pr_active_slide, {
            autoAlpha: 0
          }), a[r].firststart = 0), a[r].pr_active_slide[0] !== i && tpGS.gsap.set(a[r].pr_active_slide, {
            zIndex: 18
          }), a[r].pr_next_slide[0] !== i && tpGS.gsap.set(a[r].pr_next_slide, {
            autoAlpha: 0,
            zIndex: 20
          });
          s = a.gA(a[r].pr_next_slide[0], "key");
          a[r].sbgs[s].alt === i && (a[r].sbgs[s].alt = a.gA(a[r].pr_next_slide[0], "alttrans") || !1, a[r].sbgs[s].alt = !1 !== a[r].sbgs[s].alt && a[r].sbgs[s].alt.split(","), a[r].sbgs[s].altIndex = 0, a[r].sbgs[s].altLen = !1 !== a[r].sbgs[s].alt ? a[r].sbgs[s].alt.length : 0);
          a[r].firstSlideAnimDone === i && a[r].fanim !== i && !1 !== a[r].fanim || a[r].sbgs[s].slideanimation === i || a[r].sbgs[s].slideanimationRebuild || a[r].sbgs[s].random !== i && a.SLTR !== i || a[r].sbgs[s].altLen > 0 && a.SLTR;
          a[r].sbgs[s].slideanimation = a[r].firstSlideAnimDone === i && a[r].fanim !== i && !1 !== a[r].fanim ? a.convertSlideAnimVals(e.extend(!0, {}, a.getSlideAnim_EmptyObject(), a[r].fanim)) : a[r].sbgs[s].slideanimation === i || a[r].sbgs[s].slideanimationRebuild ? a.getSlideAnimationObj(r, {
            anim: a.gA(a[r].pr_next_slide[0], "anim"),
            filter: a.gA(a[r].pr_next_slide[0], "filter"),
            in: a.gA(a[r].pr_next_slide[0], "in"),
            out: a.gA(a[r].pr_next_slide[0], "out"),
            d3: a.gA(a[r].pr_next_slide[0], "d3")
          }, s) : a[r].sbgs[s].random !== i && a.SLTR !== i ? a.convertSlideAnimVals(e.extend(!0, {}, a.getSlideAnim_EmptyObject(), a.getAnimObjectByKey(a.getRandomSlideTrans(a[r].sbgs[s].random.rndmain, a[r].sbgs[s].random.rndgrp, a.SLTR), a.SLTR))) : a[r].sbgs[s].altLen > 0 && a.SLTR !== i ? a.convertSlideAnimVals(e.extend(!0, {
            altAnim: a[r].sbgs[s].alt[a[r].sbgs[s].altIndex]
          }, a.getSlideAnim_EmptyObject(), a.getAnimObjectByKey(a[r].sbgs[s].alt[a[r].sbgs[s].altIndex], a.SLTR))) : a[r].sbgs[s].slideanimation, a[r].sbgs[s].altLen > 0 && (a[r].sbgs[s].firstSlideAnimDone !== i ? (a[r].sbgs[s].altIndex++, a[r].sbgs[s].altIndex = a[r].sbgs[s].altIndex >= a[r].sbgs[s].altLen ? 0 : a[r].sbgs[s].altIndex) : (a[r].sbgs[s].firstSlideAnimDone = !0, a.SLTR === i && a.SLTR_loading === i && a.loadSlideAnimLibrary(r))), a[r].sbgs[s].currentState = "animating", a.animateSlide(r, a[r].sbgs[s].slideanimation), a[r].firstSlideAnimDone === i && a[r].fanim !== i && !1 !== a[r].fanim && (a[r].sbgs[s].slideanimationRebuild = !0), a[r].firstSlideAnimDone = !0, a[r].pr_next_bg.data("panzoom") !== i && requestAnimationFrame(function () {
            var e = a.gA(a[r].pr_next_slide[0], "key");
            a.startPanZoom(a[r].pr_next_bg, r, 0, a.getSlideIndex(r, e), "first", e);
          }), a[r].mtl.pause();
        }
        a.animateTheLayers ? "carousel" === a[r].sliderType ? (!1 !== a[r].carousel.showLayersAllTime && (a[r].carousel.allLayersStarted ? a.animateTheLayers({
          slide: "individual",
          id: r,
          mode: "rebuild",
          caller: "swapSlideProgress_5"
        }) : a.animateTheLayers({
          slide: "individual",
          id: r,
          mode: "start",
          caller: "swapSlideProgress_4"
        }), a[r].carousel.allLayersStarted = !0), 0 !== a[r].firststart ? a.animateTheLayers({
          slide: 0,
          id: r,
          mode: "start",
          caller: "swapSlideProgress_6"
        }) : !0 !== o && a.animateTheLayers({
          slide: a[r].pr_next_key !== i ? a[r].pr_next_key : a[r].pr_processing_key !== i ? a[r].pr_processing_key : a[r].pr_active_key,
          id: r,
          mode: "start",
          caller: "swapSlideProgress_7"
        }), a[r].firststart = 0) : a.animateTheLayers({
          slide: a[r].pr_next_key !== i ? a[r].pr_next_key : a[r].pr_processing_key !== i ? a[r].pr_processing_key : a[r].pr_active_key,
          id: r,
          mode: "start",
          caller: "swapSlideProgress_8"
        }) : a[r].mtl != i && setTimeout(function () {
          a[r].mtl.resume();
        }, 18), "carousel" !== a[r].sliderType && tpGS.gsap.to(a[r].pr_next_slide, .001, {
          autoAlpha: 1
        });
      }
    },
    R = function R(t) {
      if (a[t] !== i) {
        if ("done" !== a.RS_swapList[t]) {
          a.RS_swapList[t] = "done";
          var r = e.inArray(t, a.RS_swapping);
          a.RS_swapping.splice(r, 1);
        }
        if (a[t].firstSlideAvailable === i && (a[t].firstSlideAvailable = !0, window.requestAnimationFrame(function () {
          "hero" !== a[t].sliderType && a.createNavigation && a[t].navigation.use && !0 !== a[t].navigation.createNavigationDone && a.createNavigation(t);
        })), "carousel" === a[t].sliderType && tpGS.gsap.to(a[t].carousel.wrap, 1, {
          opacity: 1
        }), a[t].pr_active_key = a[t].pr_processing_key !== i ? a[t].pr_processing_key : a[t].pr_active_key, delete a[t].pr_processing_key, "scroll" != a[t].parallax.type && "scroll+mouse" != a[t].parallax.type && "mouse+scroll" != a[t].parallax.type || (a[t].lastscrolltop = -999, a.generalObserver(a.ISM)), a[t].mtldiff = a[t].mtl.time(), delete a[t].mtl, a[t].pr_active_key !== i) {
          a.gA(a[t].slides[a[t].pr_active_key], "sloop") !== i && function (e) {
            if (a[e] !== i) {
              a[e].sloops = a[e].sloops === i ? {} : a[e].sloops;
              var t = a.gA(a[e].slides[a[e].pr_active_key], "key"),
                r = a[e].sloops[t];
              if (r === i) {
                r = {
                  s: 2500,
                  e: 4500,
                  r: "unlimited"
                };
                var o = a.gA(a[e].slides[a[e].pr_active_key], "sloop").split(";");
                for (var s in o) if (o.hasOwnProperty(s)) {
                  var n = o[s].split(":");
                  switch (n[0]) {
                    case "s":
                      r.s = parseInt(n[1], 0) / 1e3;
                      break;
                    case "e":
                      r.e = parseInt(n[1], 0) / 1e3;
                      break;
                    case "r":
                      r.r = n[1];
                  }
                }
                r.r = "unlimited" === r.r ? -1 : parseInt(r.r, 0), a[e].sloops[t] = r, r.key = t;
              }
              r.ct = {
                time: r.s
              }, r.tl = tpGS.gsap.timeline({}), r.timer = tpGS.gsap.fromTo(r.ct, r.e - r.s, {
                time: r.s
              }, {
                time: r.e,
                ease: "none",
                onRepeat: function onRepeat() {
                  for (var t in a[e].layers[r.key]) a[e].layers[r.key].hasOwnProperty(t) && a[e]._L[t].timeline.play(r.s);
                  var o = a[e].progressC;
                  o !== i && o[0] !== i && o[0].tween !== i && o[0].tween.time(r.s);
                },
                onUpdate: function onUpdate() {},
                onComplete: function onComplete() {}
              }).repeat(r.r), r.tl.add(r.timer, r.s), r.tl.time(a[e].mtldiff);
            }
          }(t), a.sA(a[t].slides[a[t].activeRSSlide], "isactiveslide", !1), a[t].activeRSSlide = a[t].pr_active_key, a.sA(a[t].slides[a[t].activeRSSlide], "isactiveslide", !0);
          var o = a.gA(a[t].slides[a[t].pr_active_key], "key"),
            s = a.gA(a[t].slides[a[t].pr_lastshown_key], "key");
          a.sA(a[t].c[0], "slideactive", o), s !== i && a[t].panzoomTLs !== i && a[t].panzoomTLs[a.getSlideIndex(t, s)] !== i && ("carousel" === a[t].sliderType ? (a[t].panzoomTLs[a.getSlideIndex(t, s)].timeScale(3), a[t].panzoomTLs[a.getSlideIndex(t, s)].reverse()) : a[t].panzoomTLs[a.getSlideIndex(t, s)].pause()), a[t].pr_next_bg.data("panzoom") !== i && (a[t].panzoomTLs !== i && a[t].panzoomTLs[a.getSlideIndex(t, o)] !== i ? (a[t].panzoomTLs[a.getSlideIndex(t, o)].timeScale(1), a[t].panzoomTLs[a.getSlideIndex(t, o)].play()) : a.startPanZoom(a[t].pr_next_bg, t, 0, a.getSlideIndex(t, o), "play", o));
          var n = {
            slider: t,
            slideIndex: parseInt(a[t].pr_active_key, 0) + 1,
            slideLIIndex: a[t].pr_active_key,
            slide: a[t].pr_next_slide,
            currentslide: a[t].pr_next_slide,
            prevSlideIndex: a[t].pr_lastshown_key !== i && parseInt(a[t].pr_lastshown_key, 0) + 1,
            prevSlideLIIndex: a[t].pr_lastshown_key !== i && parseInt(a[t].pr_lastshown_key, 0),
            prevSlide: a[t].pr_lastshown_key !== i && a[t].slides[a[t].pr_lastshown_key]
          };
          if (a[t].c.trigger("revolution.slide.onchange", n), a[t].c.trigger("revolution.slide.onafterswap", n), a[t].deepLinkListener || a[t].enableDeeplinkHash) {
            var d = a.gA(a[t].slides[a[t].pr_active_key], "deeplink");
            d !== i && d.length > 0 && (a[t].ignoreDeeplinkChange = !0, window.location.hash = a.gA(a[t].slides[a[t].pr_active_key], "deeplink"));
          }
          a[t].pr_lastshown_key = a[t].pr_active_key, a[t].startWithSlide !== i && "done" !== a[t].startWithSlide && "carousel" === a[t].sliderType && (a[t].firststart = 0), a[t].duringslidechange = !1, a[t].pr_active_slide.length > 0 && 0 != a.gA(a[t].pr_active_slide[0], "hal") && a.gA(a[t].pr_active_slide[0], "hal") <= a.gA(a[t].pr_active_slide[0], "sofacounter") && a[t].c.revremoveslide(a[t].pr_active_slide.index());
          var l = a[t].pr_processing_key || a[t].pr_active_key || 0;
          a[t].rowzones != i && (l = l > a[t].rowzones.length ? a[t].rowzones.length : l), (a[t].rowzones != i && a[t].rowzones.length > 0 && a[t].rowzones[l] != i && l >= 0 && l <= a[t].rowzones.length && a[t].rowzones[l].length > 0 || a.winH < a[t].module.height) && a.updateDims(t), delete a[t].sc_indicator, delete a[t].sc_indicator_dir, a[t].firstLetItFree === i && (a.generalObserver(a.ISM), a[t].firstLetItFree = !0);
        }
      }
    },
    O = function O(t) {
      var r = a[t].progressBar;
      if (a[t].progressC === i || 0 == a[t].progressC.length) if (a[t].progressC = e('<rs-progress style="visibility:hidden;"></rs-progress>'), "horizontal" === r.style || "vertical" === r.style) {
        if ("module" === r.basedon) {
          for (var o = "", s = 0; s < a[t].slideamount; s++) o += "<rs-progress-bar></rs-progress-bar>";
          o += "<rs-progress-bgs>";
          for (s = 0; s < a[t].slideamount; s++) o += "<rs-progress-bg></rs-progress-bg>";
          if (o += "</rs-progress-bgs>", "nogap" !== r.gaptype) for (s = 0; s < a[t].slideamount; s++) o += "<rs-progress-gap></rs-progress-gap>";
          a[t].progressC[0].innerHTML = o, !0 === a[t].noDetach && a[t].c.append(a[t].progressC), a[t].progressCBarBGS = a.getByTag(a[t].progressC[0], "RS-PROGRESS-BG"), a[t].progressCBarGAPS = a.getByTag(a[t].progressC[0], "RS-PROGRESS-GAP"), "nogap" !== r.gaptype && tpGS.gsap.set(a[t].progressCBarGAPS, {
            backgroundColor: r.gapcolor,
            zIndex: "gapbg" === r.gaptype ? 17 : 27
          }), tpGS.gsap.set(a[t].progressCBarBGS, {
            backgroundColor: r.bgcolor
          });
        } else a[t].progressC[0].innerHTML = "<rs-progress-bar></rs-progress-bar>", !0 === a[t].noDetach && a[t].c.append(a[t].progressC);
        a[t].progressCBarInner = a.getByTag(a[t].progressC[0], "RS-PROGRESS-BAR"), tpGS.gsap.set(a[t].progressCBarInner, {
          background: r.color
        });
      } else a[t].progressC[0].innerHTML = '<canvas width="' + 2 * r.radius + '" height="' + 2 * r.radius + '" style="position:absolute" class="rs-progress-bar"></canvas>', !0 === a[t].noDetach && a[t].c.append(a[t].progressC), a[t].progressCBarInner = a[t].progressC[0].getElementsByClassName("rs-progress-bar")[0], a[t].progressBCanvas = a[t].progressCBarInner.getContext("2d"), a[t].progressBar.degree = "cw" === a[t].progressBar.style ? 360 : 0, I(t);
      if (!0 !== a[t].noDetach && a[t].progressC.detach(), a[t].progressBar.visibility[a[t].level] && 1 != a[t].progressBar.disableProgressBar) {
        if ("horizontal" === r.style || "vertical" === r.style) {
          var n,
            d,
            l = a[t].slideamount - 1;
          if ("horizontal" === r.style) {
            var c = "grid" === r.alignby ? a[t].gridwidth[a[t].level] : a[t].module.width;
            n = Math.ceil(c / a[t].slideamount), d = Math.ceil((c - l * r.gapsize) / a[t].slideamount), tpGS.gsap.set(a[t].progressC, {
              visibility: "visible",
              top: "top" === r.vertical ? r.y + ("grid" === r.alignby && a[t].gridOffsetHeight !== i ? Math.max(0, a[t].gridOffsetHeight) : 0) : "center" === r.vertical ? "50%" : "auto",
              bottom: "top" === r.vertical || "center" === r.vertical ? "auto" : r.y + ("grid" === r.alignby && a[t].gridOffsetHeight !== i ? Math.max(0, a[t].gridOffsetHeight) : 0),
              left: "left" === r.horizontal && "grid" === r.alignby && a[t].gridOffsetWidth !== i ? Math.max(0, a[t].gridOffsetWidth) : "auto",
              right: "right" === r.horizontal && "grid" === r.alignby && a[t].gridOffsetWidth !== i ? Math.max(0, a[t].gridOffsetWidth) : "auto",
              y: "center" === r.vertical ? r.y : 0,
              height: r.size,
              backgroundColor: "module" === r.basedon ? "transparent" : r.bgcolor,
              marginTop: "bottom" === r.vertical ? 0 : "top" === r.vertical ? 0 : parseInt(r.size, 0) / 2,
              width: "grid" === r.alignby ? a[t].gridwidth[a[t].level] : "100%"
            }), tpGS.gsap.set(a[t].progressCBarInner, {
              x: "module" === r.basedon ? r.gap ? function (e) {
                return ("right" === r.horizontal ? l - e : e) * (d + r.gapsize);
              } : function (e) {
                return ("right" === r.horizontal ? l - e : e) * n;
              } : 0,
              width: "module" === r.basedon ? r.gap ? d + "px" : 100 / a[t].slideamount + "%" : "100%"
            }), "module" === r.basedon && (tpGS.gsap.set(a[t].progressCBarBGS, {
              x: "module" === r.basedon ? r.gap ? function (e) {
                return e * (d + r.gapsize);
              } : function (e) {
                return e * n;
              } : 0,
              width: "module" === r.basedon ? r.gap ? d + "px" : 100 / a[t].slideamount + "%" : "100%"
            }), tpGS.gsap.set(a[t].progressCBarGAPS, {
              width: r.gap ? r.gapsize + "px" : 0,
              x: r.gap ? function (e) {
                return (e + 1) * d + parseInt(r.gapsize, 0) * e;
              } : 0
            }));
          } else if ("vertical" === r.style) {
            c = "grid" === r.alignby ? a[t].gridheight[a[t].level] : a[t].module.height;
            n = Math.ceil(c / a[t].slideamount), d = Math.ceil((c - l * r.gapsize) / a[t].slideamount), tpGS.gsap.set(a[t].progressC, {
              visibility: "visible",
              left: "left" === r.horizontal ? r.x + ("grid" === r.alignby && a[t].gridOffsetWidth !== i ? Math.max(0, a[t].gridOffsetWidth) : 0) : "center" === r.horizontal ? "50%" : "auto",
              right: "left" === r.horizontal || "center" === r.horizontal ? "auto" : r.x + ("grid" === r.alignby && a[t].gridOffsetWidth !== i ? Math.max(0, a[t].gridOffsetWidth) : 0),
              x: "center" === r.horizontal ? r.x : 0,
              top: "top" === r.vertical && "grid" === r.alignby && a[t].gridOffsetHeight !== i ? Math.max(a[t].gridOffsetHeight, 0) : "auto",
              bottom: "bottom" === r.vertical && "grid" === r.alignby && a[t].gridOffsetHeight !== i ? Math.max(a[t].gridOffsetHeight, 0) : "auto",
              width: r.size,
              marginLeft: "left" === r.horizontal ? 0 : "right" === r.horizontal ? 0 : parseInt(r.size, 0) / 2,
              backgroundColor: "module" === r.basedon ? "transparent" : r.bgcolor,
              height: "grid" === r.alignby ? a[t].gridheight[a[t].level] : "100%"
            }), tpGS.gsap.set(a[t].progressCBarInner, {
              y: "module" === r.basedon ? r.gap ? function (e) {
                return ("bottom" === r.vertical ? l - e : e) * (d + r.gapsize);
              } : function (e) {
                return ("bottom" === r.vertical ? l - e : e) * n;
              } : 0,
              height: "module" === r.basedon ? r.gap ? d + "px" : 100 / a[t].slideamount + "%" : "100%"
            }), "module" === r.basedon && (tpGS.gsap.set(a[t].progressCBarBGS, {
              y: "module" === r.basedon ? r.gap ? function (e) {
                return e * (d + r.gapsize);
              } : function (e) {
                return e * n;
              } : 0,
              height: "module" === r.basedon ? r.gap ? d + "px" : 100 / a[t].slideamount + "%" : "100%"
            }), tpGS.gsap.set(a[t].progressCBarGAPS, {
              height: r.gap ? r.gapsize + "px" : 0,
              y: r.gap ? function (e) {
                return (e + 1) * d + parseInt(r.gapsize, 0) * e;
              } : 0
            }));
          }
        } else tpGS.gsap.set(a[t].progressC, {
          top: "top" === r.vertical ? r.y + ("grid" === r.alignby && a[t].gridOffsetHeight !== i ? Math.max(0, a[t].gridOffsetHeight) : 0) : "center" === r.vertical ? "50%" : "auto",
          bottom: "top" === r.vertical || "center" === r.vertical ? "auto" : r.y + ("grid" === r.alignby && a[t].gridOffsetHeight !== i ? Math.max(0, a[t].gridOffsetHeight) : 0),
          left: "left" === r.horizontal ? r.x + ("grid" === r.alignby && a[t].gridOffsetWidth !== i ? Math.max(0, a[t].gridOffsetWidth) : 0) : "center" === r.horizontal ? "50%" : "auto",
          right: "left" === r.horizontal || "center" === r.horizontal ? "auto" : r.x + ("grid" === r.alignby && a[t].gridOffsetWidth !== i ? Math.max(0, a[t].gridOffsetWidth) : 0),
          y: "center" === r.vertical ? r.y : 0,
          x: "center" === r.horizontal ? r.x : 0,
          width: 2 * r.radius,
          height: 2 * r.radius,
          marginTop: "center" === r.vertical ? 0 - r.radius : 0,
          marginLeft: "center" === r.horizontal ? 0 - r.radius : 0,
          backgroundColor: "transparent",
          visibility: "visible"
        });
      } else a[t].progressC[0].style.visibility = "hidden";
      !0 !== a[t].noDetach && a[t].c.append(a[t].progressC), a[t].gridOffsetWidth === i && "grid" === r.alignby ? a[t].rebuildProgressBar = !0 : a[t].rebuildProgressBar = !1;
    },
    I = function I(e) {
      var i = a[e].progressBar;
      i.radius - parseInt(i.size, 0) <= 0 && (i.size = i.radius / 4);
      var t = parseInt(i.radius),
        r = parseInt(i.radius);
      a[e].progressBCanvas.lineCap = "round", a[e].progressBCanvas.clearRect(0, 0, 2 * i.radius, 2 * i.radius), a[e].progressBCanvas.beginPath(), a[e].progressBCanvas.arc(t, r, i.radius - parseInt(i.size, 0), Math.PI / 180 * 270, Math.PI / 180 * 630), a[e].progressBCanvas.strokeStyle = i.bgcolor, a[e].progressBCanvas.lineWidth = parseInt(i.size, 0) - 1, a[e].progressBCanvas.stroke(), a[e].progressBCanvas.beginPath(), a[e].progressBCanvas.strokeStyle = i.color, a[e].progressBCanvas.lineWidth = parseInt(i.size, 0), a[e].progressBCanvas.arc(t, r, i.radius - parseInt(i.size, 0), Math.PI / 180 * 270, Math.PI / 180 * (270 + a[e].progressBar.degree), "cw" !== i.style), a[e].progressBCanvas.stroke();
    },
    M = function M(t) {
      var r = function r() {
          t !== i && a !== i && a[t] !== i && (0 == e("body").find(a[t].c).length || null === a[t] || null === a[t].c || a[t].c === i || 0 === a[t].length ? (!function (i) {
            a[i].c.children().each(function () {
              try {
                e(this).die("click");
              } catch (e) {}
              try {
                e(this).die("mouseenter");
              } catch (e) {}
              try {
                e(this).die("mouseleave");
              } catch (e) {}
              try {
                e(this).unbind("hover");
              } catch (e) {}
            });
            try {
              a[i].c.die("click", "mouseenter", "mouseleave");
            } catch (e) {}
            clearInterval(a[i].cdint), a[i].c = null;
          }(t), clearInterval(a[t].cdint)) : (a[t].c.trigger("revolution.slide.slideatend"), 1 == a[t].c.data("conthoverchanged") && (a[t].conthover = a[t].c.data("conthover"), a[t].c.data("conthoverchanged", 0)), a.callingNewSlide(t, 1, !0)));
        },
        o = tpGS.gsap.timeline({
          paused: !0
        }),
        s = "reset" === a[t].progressBar.reset || a[t].progressBar.notnew === i ? 0 : .2,
        n = "slide" === a[t].progressBar.basedon ? 0 : a[t].pr_processing_key !== i ? a[t].pr_processing_key : a[t].pr_active_key;
      if (n = n === i ? 0 : n, "horizontal" === a[t].progressBar.style) {
        if (o.add(tpGS.gsap.to(a[t].progressCBarInner[n], s, {
          scaleX: 0,
          transformOrigin: "right" === a[t].progressBar.horizontal ? "100% 50%" : "0% 50%"
        })), o.add(tpGS.gsap.to(a[t].progressCBarInner[n], a[t].duration / 1e3, {
          transformOrigin: "right" === a[t].progressBar.horizontal ? "100% 50%" : "0% 50%",
          force3D: "auto",
          scaleX: 1,
          onComplete: r,
          delay: .5,
          ease: a[t].progressBar.ease
        })), "module" === a[t].progressBar.basedon) for (var d = 0; d < a[t].slideamount; d++) d !== n && o.add(tpGS.gsap.set(a[t].progressCBarInner[d], {
          scaleX: d < n ? 1 : 0,
          transformOrigin: "right" === a[t].progressBar.horizontal ? "100% 50%" : "0% 50%"
        }), 0);
      } else if ("vertical" === a[t].progressBar.style) {
        if (a[t].progressCBarInner[n] !== i && o.add(tpGS.gsap.to(a[t].progressCBarInner[n], s, {
          scaleY: 0,
          transformOrigin: "bottom" === a[t].progressBar.vertical ? "50% 100%" : "50% 0%"
        })), a[t].progressCBarInner[n] !== i && o.add(tpGS.gsap.to(a[t].progressCBarInner[n], a[t].duration / 1e3, {
          transformOrigin: "bottom" === a[t].progressBar.vertical ? "50% 100%" : "50% 0%",
          force3D: "auto",
          scaleY: 1,
          onComplete: r,
          delay: .5,
          ease: a[t].progressBar.ease
        })), "module" === a[t].progressBar.basedon) for (d = 0; d < a[t].slideamount; d++) d !== n && a[t].progressCBarInner[d] !== i && o.add(tpGS.gsap.set(a[t].progressCBarInner[d], {
          scaleY: d < n ? 1 : 0,
          transformOrigin: "botton" === a[t].progressBar.vertical ? "50% 100%" : "50% 0%"
        }), 0);
      } else {
        var l = "slide" === a[t].progressBar.basedon ? 0 : Math.max(0, 360 / a[t].slideamount * n),
          c = "slide" === a[t].progressBar.basedon ? 360 : 360 / a[t].slideamount * (n + 1);
        "ccw" === a[t].progressBar.style && "slide" !== a[t].progressBar.basedon && (l = 360 - c, c = 360 - 360 / a[t].slideamount * n), o.add(tpGS.gsap.to(a[t].progressBar, s, {
          degree: "cw" === a[t].progressBar.style ? l : c,
          onUpdate: function onUpdate() {
            I(t);
          }
        })), o.add(tpGS.gsap.to(a[t].progressBar, a[t].duration / 1e3, {
          degree: "cw" === a[t].progressBar.style ? c : l,
          onUpdate: function onUpdate() {
            I(t);
          },
          onComplete: r,
          delay: .5,
          ease: a[t].progressBar.ease
        }));
      }
      return a[t].progressBar.notnew = !0, o;
    },
    T = function T(e) {
      a[e].progressC == i && O(e), a[e].loop = 0, a[e].stopAtSlide != i && a[e].stopAtSlide > -1 ? a[e].lastslidetoshow = a[e].stopAtSlide : a[e].lastslidetoshow = 999, a[e].stopLoop = !1, 0 == a[e].looptogo && (a[e].stopLoop = !0), a[e].c.on("stoptimer", function () {
        a[e].progressC != i && (a[e].progressC[0].tween.pause(), a[e].progressBar.disableProgressBar && (a[e].progressC[0].style.visibility = "hidden"), a[e].sliderstatus = "paused", a[e].slideInSwapTimer || a.unToggleState(a[e].slidertoggledby), a[e].slideInSwapTimer = !1);
      }), a[e].c.on("starttimer", function () {
        a[e].progressC != i && (a[e].forcepaused || (1 != a[e].conthover && 1 != a[e].stopByVideo && a[e].module.width > a[e].hideSliderAtLimit && 1 != a[e].tonpause && 1 != a[e].overnav && 1 != a[e].ssop && (1 === a[e].noloopanymore || a[e].viewPort.enable && !a[e].inviewport || (a[e].progressBar.visibility[a[e].level] || (a[e].progressC[0].style.visibility = "visible"), a[e].progressC[0].tween.resume(), a[e].sliderstatus = "playing")), !a[e].progressBar.disableProgressBar && a[e].progressBar.visibility[a[e].level] || (a[e].progressC[0].style.visibility = "hidden"), a.toggleState(a[e].slidertoggledby)));
      }), a[e].c.on("restarttimer", function () {
        if (a[e].progressC != i && !a[e].forcepaused) {
          if (a[e].mouseoncontainer && "on" == a[e].navigation.onHoverStop && !a.ISM) return !1;
          1 === a[e].noloopanymore || a[e].viewPort.enable && !a[e].inviewport || 1 == a[e].ssop ? a.unToggleState(a[e].slidertoggledby) : (a[e].progressBar.visibility[a[e].level] || (a[e].progressC[0].style.visibility = "visible"), a[e].progressC[0].tween !== i && a[e].progressC[0].tween.kill(), a[e].progressC[0].tween = M(e), a[e].progressC[0].tween.play(), a[e].sliderstatus = "playing", a.toggleState(a[e].slidertoggledby)), !a[e].progressBar.disableProgressBar && a[e].progressBar.visibility[a[e].level] || (a[e].progressC[0].style.visibility = "hidden"), a[e].mouseoncontainer && 1 == a[e].navigation.onHoverStop && !a.ISM && (a[e].c.trigger("stoptimer"), a[e].c.trigger("revolution.slide.onpause"));
        }
      }), a[e].c.on("nulltimer", function () {
        a[e].progressC != i && a[e].progressC[0] !== i && (a[e].progressC[0].tween !== i && a[e].progressC[0].tween.kill(), a[e].progressC[0].tween = M(e), a[e].progressC[0].tween.pause(0), !a[e].progressBar.disableProgressBar && a[e].progressBar.visibility[a[e].level] || (a[e].progressC[0].style.visibility = "hidden"), a[e].sliderstatus = "paused");
      }), a[e].progressC !== i && (a[e].progressC[0].tween = M(e)), a[e].slideamount > 1 && (0 != a[e].stopAfterLoops || 1 != a[e].stopAtSlide) ? a[e].c.trigger("starttimer") : (a[e].noloopanymore = 1, a[e].c.trigger("nulltimer")), a[e].c.on("tp-mouseenter", function () {
        a[e].mouseoncontainer = !0, 1 != a[e].navigation.onHoverStop || a.ISM || (a[e].c.trigger("stoptimer"), a[e].c.trigger("revolution.slide.onpause"));
      }), a[e].c.on("tp-mouseleft", function () {
        a[e].mouseoncontainer = !1, 1 != a[e].c.data("conthover") && 1 == a[e].navigation.onHoverStop && (1 == a[e].viewPort.enable && a[e].inviewport || 0 == a[e].viewPort.enable) && (a[e].c.trigger("revolution.slide.onresume"), a[e].c.trigger("starttimer"));
      });
    },
    C = function C() {
      e(".rev_redraw_on_blurfocus").each(function () {
        var e = this.id;
        if (a[e] == i || a[e].c == i || 0 === a[e].c.length) return !1;
        1 != a[e].windowfocused && (a[e].windowfocused = !0, tpGS.gsap.delayedCall(.1, function () {
          a[e].fallbacks.nextSlideOnWindowFocus && a[e].c.revnext(), a[e].c.revredraw(), "playing" == a[e].lastsliderstatus && a[e].c.revresume(), a[e].c.trigger("revolution.slide.tabfocused");
        }));
      });
    },
    A = function A() {
      document.hasFocus() || e(".rev_redraw_on_blurfocus").each(function (e) {
        var i = this.id;
        a[i].windowfocused = !1, a[i].lastsliderstatus = a[i].sliderstatus, a[i].c.revpause(), a[i].c.trigger("revolution.slide.tabblured");
      });
    },
    D = function D() {
      var e = document.documentMode === i,
        t = window.chrome;
      1 !== a.revslider_focus_blur_listener && (a.revslider_focus_blur_listener = 1, e && !t ? a.window.on("focusin", function () {
        !0 !== a.windowIsFocused && C(), a.windowIsFocused = !0;
      }).on("focusout", function () {
        !0 !== a.windowIsFocused && a.windowIsFocused !== i || A(), a.windowIsFocused = !1;
      }) : window.addEventListener ? (window.addEventListener("focus", function (e) {
        !0 !== a.windowIsFocused && C(), a.windowIsFocused = !0;
      }, {
        capture: !1,
        passive: !0
      }), window.addEventListener("blur", function (e) {
        !0 !== a.windowIsFocused && a.windowIsFocused !== i || A(), a.windowIsFocused = !1;
      }, {
        capture: !1,
        passive: !0
      })) : (window.attachEvent("focus", function (e) {
        !0 !== a.windowIsFocused && C(), a.windowIsFocused = !0;
      }), window.attachEvent("blur", function (e) {
        !0 !== a.windowIsFocused && a.windowIsFocused !== i || A(), a.windowIsFocused = !1;
      })));
    },
    P = function P(e) {
      for (var i, t = [], a = window.location.href.slice(window.location.href.indexOf(e) + 1).split("_"), r = 0; r < a.length; r++) a[r] = a[r].replace("%3D", "="), i = a[r].split("="), t.push(i[0]), t[i[0]] = i[1];
      return t;
    },
    B = function B(t) {
      if (a[t].blockSpacing !== i) {
        var r = a[t].blockSpacing.split(";");
        for (var o in a[t].blockSpacing = {}, r) if (r.hasOwnProperty(o)) {
          var s = r[o].split(":");
          switch (s[0]) {
            case "t":
              a[t].blockSpacing.top = a.revToResp(s[1], 4, 0);
              break;
            case "b":
              a[t].blockSpacing.bottom = a.revToResp(s[1], 4, 0);
              break;
            case "l":
              a[t].blockSpacing.left = a.revToResp(s[1], 4, 0);
              break;
            case "r":
              a[t].blockSpacing.right = a.revToResp(s[1], 4, 0);
          }
        }
        a[t].blockSpacing.block = e(a.closestClass(a[t].c[0], "wp-block-themepunch-revslider")), a[t].level !== i && a[t].blockSpacing !== i && tpGS.gsap.set(a[t].blockSpacing.block, {
          paddingLeft: a[t].blockSpacing.left[a[t].level],
          paddingRight: a[t].blockSpacing.right[a[t].level],
          marginTop: a[t].blockSpacing.top[a[t].level],
          marginBottom: a[t].blockSpacing.bottom[a[t].level]
        });
      }
    },
    z = function z(e) {
      return e.charAt(0).toUpperCase() + e.slice(1);
    },
    G = function G(t) {
      return function (e) {
        for (var t in e.minHeight = e.minHeight !== i ? "none" === e.minHeight || "0" === e.minHeight || "0px" === e.minHeight || "" == e.minHeight || " " == e.minHeight ? 0 : parseInt(e.minHeight, 0) : 0, e.maxHeight = "none" === e.maxHeight || "0" === e.maxHeight ? 0 : parseInt(e.maxHeight, 0), e.carousel.maxVisibleItems = e.carousel.maxVisibleItems < 1 ? 999 : e.carousel.maxVisibleItems, e.carousel.vertical_align = "top" === e.carousel.vertical_align ? "0%" : "bottom" === e.carousel.vertical_align ? "100%" : "50%", e.carousel.space = parseInt(e.carousel.space, 0), e.carousel.maxOpacity = parseInt(e.carousel.maxOpacity, 0), e.carousel.maxOpacity = e.carousel.maxOpacity > 1 ? e.carousel.maxOpacity / 100 : e.carousel.maxOpacity, e.carousel.showLayersAllTime = "true" === e.carousel.showLayersAllTime || !0 === e.carousel.showLayersAllTime ? "all" : e.carousel.showLayersAllTime, e.carousel.maxRotation = parseInt(e.carousel.maxRotation, 0), e.carousel.minScale = parseInt(e.carousel.minScale, 0), e.carousel.minScale = e.carousel.minScale > .9 ? e.carousel.minScale / 100 : e.carousel.minScale, e.carousel.speed = parseInt(e.carousel.speed, 0), e.navigation.maintypes = ["arrows", "tabs", "thumbnails", "bullets"], e.perspective = parseInt(e.perspective, 0), e.navigation.maintypes) e.navigation.maintypes.hasOwnProperty(t) && e.navigation[e.navigation.maintypes[t]] !== i && (e.navigation[e.navigation.maintypes[t]].animDelay = e.navigation[e.navigation.maintypes[t]].animDelay === i ? 1e3 : e.navigation[e.navigation.maintypes[t]].animDelay, e.navigation[e.navigation.maintypes[t]].animSpeed = e.navigation[e.navigation.maintypes[t]].animSpeed === i ? 1e3 : e.navigation[e.navigation.maintypes[t]].animSpeed, e.navigation[e.navigation.maintypes[t]].animDelay = parseInt(e.navigation[e.navigation.maintypes[t]].animDelay, 0) / 1e3, e.navigation[e.navigation.maintypes[t]].animSpeed = parseInt(e.navigation[e.navigation.maintypes[t]].animSpeed, 0) / 1e3);
        if (a.isNumeric(e.scrolleffect.tilt) || -1 !== e.scrolleffect.tilt.indexOf("%") && (e.scrolleffect.tilt = parseInt(e.scrolleffect.tilt)), e.scrolleffect.tilt = e.scrolleffect.tilt / 100, e.navigation.thumbnails.position = "outer-horizontal" == e.navigation.thumbnails.position ? "bottom" == e.navigation.thumbnails.v_align ? "outer-bottom" : "outer-top" : "outer-vertical" == e.navigation.thumbnails.position ? "left" == e.navigation.thumbnails.h_align ? "outer-left" : "outer-right" : e.navigation.thumbnails.position, e.navigation.tabs.position = "outer-horizontal" == e.navigation.tabs.position ? "bottom" == e.navigation.tabs.v_align ? "outer-bottom" : "outer-top" : "outer-vertical" == e.navigation.tabs.position ? "left" == e.navigation.tabs.h_align ? "outer-left" : "outer-right" : e.navigation.tabs.position, e.sbtimeline.speed = parseInt(e.sbtimeline.speed, 0) / 1e3 || .5, !0 === e.sbtimeline.set && !0 === e.sbtimeline.fixed && "auto" !== e.sliderLayout ? (e.sbtimeline.fixStart = parseInt(e.sbtimeline.fixStart), e.sbtimeline.fixEnd = parseInt(e.sbtimeline.fixEnd)) : e.sbtimeline.fixed = !1, e.progressBar === i || "true" != e.progressBar.disableProgressBar && 1 != e.progressBar.disableProgressBar || (e.progressBar.disableProgressBar = !0), e.startDelay = parseInt(e.startDelay, 0) || 0, e.navigation !== i && e.navigation.arrows != i && e.navigation.arrows.hide_under != i && (e.navigation.arrows.hide_under = parseInt(e.navigation.arrows.hide_under)), e.navigation !== i && e.navigation.bullets != i && e.navigation.bullets.hide_under != i && (e.navigation.bullets.hide_under = parseInt(e.navigation.bullets.hide_under)), e.navigation !== i && e.navigation.thumbnails != i && e.navigation.thumbnails.hide_under != i && (e.navigation.thumbnails.hide_under = parseInt(e.navigation.thumbnails.hide_under)), e.navigation !== i && e.navigation.tabs != i && e.navigation.tabs.hide_under != i && (e.navigation.tabs.hide_under = parseInt(e.navigation.tabs.hide_under)), e.navigation !== i && e.navigation.arrows != i && e.navigation.arrows.hide_over != i && (e.navigation.arrows.hide_over = parseInt(e.navigation.arrows.hide_over)), e.navigation !== i && e.navigation.bullets != i && e.navigation.bullets.hide_over != i && (e.navigation.bullets.hide_over = parseInt(e.navigation.bullets.hide_over)), e.navigation !== i && e.navigation.thumbnails != i && e.navigation.thumbnails.hide_over != i && (e.navigation.thumbnails.hide_over = parseInt(e.navigation.thumbnails.hide_over)), e.navigation !== i && e.navigation.tabs != i && e.navigation.tabs.hide_over != i && (e.navigation.tabs.hide_over = parseInt(e.navigation.tabs.hide_over)), e.lazyloaddata !== i && e.lazyloaddata.length > 0 && e.lazyloaddata.indexOf("-") > 0) {
          var r = e.lazyloaddata.split("-");
          for (e.lazyloaddata = r[0], t = 1; t < r.length; t++) e.lazyloaddata += z(r[t]);
        }
        return e.duration = parseInt(e.duration), "single" === e.lazyType && "carousel" === e.sliderType && (e.lazyType = "smart"), "carousel" === e.sliderType && e.carousel.justify && (e.justifyCarousel = !0, e.keepBPHeight = !0), e.enableUpscaling = 1 == e.enableUpscaling && "carousel" !== e.sliderType && "fullwidth" === e.sliderLayout, e.useFullScreenHeight = "carousel" === e.sliderType && "fullscreen" === e.sliderLayout && !0 === e.useFullScreenHeight, e.progressBar.y = parseInt(e.progressBar.y, 0), e.progressBar.x = parseInt(e.progressBar.x, 0), /*! Custom Eases */
        "IE" !== window.RSBrowser && e.customEases !== i && (!e.customEases.SFXBounceLite && "true" != e.customEases.SFXBounceLite || tpGS.SFXBounceLite !== i || (tpGS.SFXBounceLite = tpGS.CustomBounce.create("SFXBounceLite", {
          strength: .3,
          squash: 1,
          squashID: "SFXBounceLite-squash"
        })), !e.customEases.SFXBounceSolid && "true" != e.customEases.SFXBounceSolid || tpGS.SFXBounceSolid !== i || (tpGS.SFXBounceSolid = tpGS.CustomBounce.create("SFXBounceSolid", {
          strength: .5,
          squash: 2,
          squashID: "SFXBounceSolid-squash"
        })), !e.customEases.SFXBounceStrong && "true" != e.customEases.SFXBounceStrong || tpGS.SFXBounceStrong !== i || (tpGS.SFXBounceStrong = tpGS.CustomBounce.create("SFXBounceStrong", {
          strength: .7,
          squash: 3,
          squashID: "SFXBounceStrong-squash"
        })), !e.customEases.SFXBounceExtrem && "true" != e.customEases.SFXBounceExtrem || tpGS.SFXBounceExtrem !== i || (tpGS.SFXBounceExtrem = tpGS.CustomBounce.create("SFXBounceExtrem", {
          strength: .9,
          squash: 4,
          squashID: "SFXBounceExtrem-squash"
        })), !e.customEases.BounceLite && "true" != e.customEases.BounceLite || tpGS.BounceLite !== i || (tpGS.BounceLite = tpGS.CustomBounce.create("BounceLite", {
          strength: .3
        })), !e.customEases.BounceSolid && "true" != e.customEases.BounceSolid || tpGS.BounceSolid !== i || (tpGS.BounceSolid = tpGS.CustomBounce.create("BounceSolid", {
          strength: .5
        })), !e.customEases.BounceStrong && "true" != e.customEases.BounceStrong || tpGS.BounceStrong !== i || (tpGS.BounceStrong = tpGS.CustomBounce.create("BounceStrong", {
          strength: .7
        })), !e.customEases.BounceExtrem && "true" != e.customEases.BounceExtrem || tpGS.BounceExtrem !== i || (tpGS.BounceExtrem = tpGS.CustomBounce.create("BounceExtrem", {
          strength: .9
        }))), e.modal.coverSpeed = parseFloat(e.modal.coverSpeed), e.modal.coverSpeed = e.modal.coverSpeed > 200 ? e.modal.coverSpeed / 1e3 : e.modal.coverSpeed, e.modal.coverSpeed = Math.max(Math.min(3, e.modal.coverSpeed), .3), e.navigation.wheelViewPort = e.navigation.wheelViewPort === i ? .5 : e.navigation.wheelViewPort / 100, e.navigation.wheelCallDelay = e.navigation.wheelCallDelay === i ? 1e3 : parseInt(e.navigation.wheelCallDelay), e.autoDPR = "string" == typeof e.DPR && -1 !== e.DPR.indexOf("ax"), e.DPR = e.DPR.replace("ax", ""), e.DPR = parseInt(e.DPR.replace("x", "")), e.DPR = isNaN(e.DPR) ? window.devicePixelRatio : e.autoDPR ? Math.min(window.devicePixelRatio, e.DPR) : e.DPR, e.DPR = 1 != e.onedpronmobile && "true" != e.onedpronmobile || !a.ISM ? e.DPR : 1, !1 === e.viewPort.global ? e.viewPort.enable = !1 : !0 === e.viewPort.global && (e.viewPort.local = e.viewPort.enable, e.viewPort.enable = !0), e;
      }(e.extend(!0, {
        DPR: "dpr",
        sliderType: "standard",
        sliderLayout: "auto",
        overlay: {
          type: "none",
          size: 1,
          colora: "transparent",
          colorb: "#000000"
        },
        duration: 9e3,
        imgCrossOrigin: "",
        modal: {
          useAsModal: !1,
          cover: !0,
          coverColor: "rgba(0,0,0,0.5)",
          horizontal: "center",
          vertical: "middle",
          coverSpeed: 1
        },
        navigation: {
          keyboardNavigation: !1,
          keyboard_direction: "horizontal",
          mouseScrollNavigation: "off",
          wheelViewPort: 50,
          wheelCallDelay: "1000ms",
          onHoverStop: !0,
          mouseScrollReverse: "default",
          touch: {
            touchenabled: !1,
            touchOnDesktop: !1,
            swipe_treshold: 75,
            swipe_min_touches: 1,
            swipe_direction: "horizontal",
            drag_block_vertical: !1,
            mobileCarousel: !0,
            desktopCarousel: !0
          },
          arrows: {
            style: "",
            enable: !1,
            hide_onmobile: !1,
            hide_under: 0,
            hide_onleave: !1,
            hide_delay: 200,
            hide_delay_mobile: 1200,
            hide_over: 9999,
            tmp: "",
            rtl: !1,
            left: {
              h_align: "left",
              v_align: "center",
              h_offset: 20,
              v_offset: 0,
              container: "slider"
            },
            right: {
              h_align: "right",
              v_align: "center",
              h_offset: 20,
              v_offset: 0,
              container: "slider"
            }
          },
          bullets: {
            enable: !1,
            hide_onmobile: !1,
            hide_onleave: !1,
            hide_delay: 200,
            hide_delay_mobile: 1200,
            hide_under: 0,
            hide_over: 9999,
            direction: "horizontal",
            h_align: "center",
            v_align: "bottom",
            space: 5,
            h_offset: 0,
            v_offset: 20,
            tmp: '<span class="tp-bullet-image"></span><span class="tp-bullet-title"></span>',
            container: "slider",
            rtl: !1,
            style: ""
          },
          thumbnails: {
            container: "slider",
            rtl: !1,
            style: "",
            enable: !1,
            width: 100,
            height: 50,
            min_width: 100,
            wrapper_padding: 2,
            wrapper_color: "transparent",
            tmp: '<span class="tp-thumb-image"></span><span class="tp-thumb-title"></span>',
            visibleAmount: 5,
            hide_onmobile: !1,
            hide_onleave: !1,
            hide_delay: 200,
            hide_delay_mobile: 1200,
            hide_under: 0,
            hide_over: 9999,
            direction: "horizontal",
            span: !1,
            position: "inner",
            space: 2,
            h_align: "center",
            v_align: "bottom",
            h_offset: 0,
            v_offset: 20,
            mhoff: 0,
            mvoff: 0
          },
          tabs: {
            container: "slider",
            rtl: !1,
            style: "",
            enable: !1,
            width: 100,
            min_width: 100,
            height: 50,
            wrapper_padding: 10,
            wrapper_color: "transparent",
            tmp: '<span class="tp-tab-image"></span>',
            visibleAmount: 5,
            hide_onmobile: !1,
            hide_onleave: !1,
            hide_delay: 200,
            hide_delay_mobile: 1200,
            hide_under: 0,
            hide_over: 9999,
            direction: "horizontal",
            span: !1,
            space: 0,
            position: "inner",
            h_align: "center",
            v_align: "bottom",
            h_offset: 0,
            v_offset: 20,
            mhoff: 0,
            mvoff: 0
          }
        },
        responsiveLevels: 4064,
        visibilityLevels: [2048, 1024, 778, 480],
        gridwidth: 960,
        gridheight: 500,
        minHeight: 0,
        maxHeight: 0,
        keepBPHeight: !1,
        useFullScreenHeight: !0,
        overflowHidden: !1,
        forceOverflow: !1,
        fixedOnTop: !1,
        autoHeight: !1,
        gridEQModule: !1,
        disableForceFullWidth: !1,
        fullScreenOffsetContainer: "",
        fullScreenOffset: "0",
        hideLayerAtLimit: 0,
        hideAllLayerAtLimit: 0,
        hideSliderAtLimit: 0,
        progressBar: {
          disableProgressBar: !1,
          style: "horizontal",
          size: "5px",
          radius: 10,
          vertical: "bottom",
          horizontal: "left",
          x: 0,
          y: 0,
          color: "rgba(255,255,255,0.5)",
          bgcolor: "transparent",
          basedon: "slide",
          gapsize: 0,
          reset: "reset",
          gaptype: "gapboth",
          gapcolor: "rgba(255,255,255,0.5)",
          ease: "none",
          visibility: {
            0: !0,
            1: !0,
            2: !0,
            3: !0
          }
        },
        stopAtSlide: -1,
        stopAfterLoops: 0,
        shadow: 0,
        startDelay: 0,
        lazyType: "none",
        spinner: "off",
        shuffle: !1,
        perspective: "600px",
        perspectiveType: "local",
        viewPort: {
          enable: !1,
          global: !1,
          globalDist: "-400px",
          outof: "wait",
          visible_area: "200px",
          presize: !1
        },
        fallbacks: {
          isJoomla: !1,
          panZoomDisableOnMobile: !1,
          simplifyAll: !0,
          nextSlideOnWindowFocus: !1,
          disableFocusListener: !1,
          allowHTML5AutoPlayOnAndroid: !0
        },
        fanim: !1,
        parallax: {
          type: "off",
          levels: [10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85],
          origo: "enterpoint",
          disable_onmobile: !1,
          ddd_shadow: !1,
          ddd_bgfreeze: !1,
          ddd_overflow: "visible",
          ddd_layer_overflow: "visible",
          ddd_z_correction: 65,
          speed: 400,
          speedbg: 0,
          speedls: 0
        },
        scrolleffect: {
          set: !1,
          fade: !1,
          blur: !1,
          scale: !1,
          grayscale: !1,
          maxblur: 10,
          layers: !1,
          slide: !1,
          direction: "both",
          multiplicator: 1.35,
          multiplicator_layers: .5,
          tilt: 30,
          disable_onmobile: !1
        },
        sbtimeline: {
          set: !1,
          fixed: !1,
          fixStart: 0,
          fixEnd: 0,
          layers: !1,
          slide: !1,
          ease: "none",
          speed: 500
        },
        carousel: {
          easing: "power3.inOut",
          speed: 800,
          showLayersAllTime: !1,
          horizontal_align: "center",
          vertical_align: "center",
          infinity: !1,
          space: 0,
          maxVisibleItems: 3,
          stretch: !1,
          fadeout: !0,
          maxRotation: 0,
          maxOpacity: 100,
          minScale: 0,
          offsetScale: !1,
          vary_fade: !1,
          vary_rotation: !1,
          vary_scale: !1,
          border_radius: "0px",
          padding_top: 0,
          padding_bottom: 0
        },
        observeWrap: !1,
        extensions: "extensions/",
        extensions_suffix: ".min.js",
        stopLoop: !1,
        waitForInit: !1,
        ignoreHeightChange: !0,
        onedpronmobile: !1
      }, t));
    };
  function E(e) {
    elementorFrontend.hooks.removeAction("frontend/element_ready/global", E), window.RS_MODULES.elementor = {
      loaded: !0,
      version: "6.5.0"
    }, window.RS_MODULES.checkMinimal && window.RS_MODULES.checkMinimal();
  }
  function N() {
    window.elementorFrontend !== i && window.elementorFrontend.hooks !== i && window.elementorFrontend.hooks.addAction !== i ? window.elementorFrontend.config.environmentMode.edit ? elementorFrontend.hooks.addAction("frontend/element_ready/widget", E) : E() : requestAnimationFrame(N);
  }
  function F() {
    document.body && document.body.className.indexOf("elementor-page") >= 0 && (window.RS_MODULES.waiting = window.RS_MODULES.waiting === i ? [] : window.RS_MODULES.waiting, window.RS_MODULES.waiting.push("elementor"), N());
  }
  window.RS_MODULES = window.RS_MODULES || {}, window.RS_MODULES.waiting = window.RS_MODULES.waiting || [], window.RS_MODULES.waiting = window.RS_MODULES.waiting.concat(["DOM", "main", "parallax", "video", "slideanims", "actions", "layeranimation", "navigation", "carousel", "panzoom"]), window.RS_MODULES.main = {
    loaded: !0,
    version: t
  }, window.RS_MODULES.minimal = !1, window.RS_MODULES.callSliders = function () {
    for (var e in RS_MODULES.modules) !0 !== RS_MODULES.modules[e].once && window.RS_MODULES !== i && window.RS_MODULES.minimal && (RS_MODULES.modules[e].once = !0, RS_MODULES.modules[e].init());
  }, "loading" === document.readyState ? document.addEventListener("readystatechange", function () {
    "interactive" !== document.readyState && "complete" !== document.readyState || (F(), window.RS_MODULES.DOM = {
      loaded: !0
    }, window.RS_MODULES.checkMinimal());
  }) : "complete" !== document.readyState && "interactive" !== document.readyState || (F(), window.RS_MODULES.DOM = {
    loaded: !0
  }), window.RS_MODULES.checkMinimal = function () {
    if (0 == window.RS_MODULES.minimal) {
      var t = 1 == window.RS_MODULES.minimal || window.RS_MODULES.waiting !== i && e.fn.revolution !== i && window.tpGS !== i && window.tpGS.gsap !== i;
      if (t) for (var a in window.RS_MODULES.waiting) window.RS_MODULES.waiting.hasOwnProperty(a) && t && window.RS_MODULES[window.RS_MODULES.waiting[a]] === i && (t = !1);
      t && (!0 !== window.RS_MODULES.minimal && e(document).trigger("REVSLIDER_READY_TO_USE"), window.RS_MODULES.minimal = !0);
    } else window.RS_MODULES.minimal = !0;
    !0 === window.RS_MODULES.minimal && window.RS_MODULES.callSliders();
  }, window.RS_MODULES.checkMinimal();
}(jQuery), function ($, undefined) {
  "use strict";

  var version = "6.2.14";
  jQuery.fn.revolution = jQuery.fn.revolution || {};
  var _R = jQuery.fn.revolution;
  jQuery.extend(!0, _R, {
    checkActions: function checkActions(e, i) {
      e === undefined ? moduleEnterLeaveActions(i) : checkActions_intern(e, i);
    },
    delayer: function delayer(e, i, t) {
      _R[e].timeStamps = _R[e].timeStamps === undefined ? {} : _R[e].timeStamps;
      var a = new Date().getTime(),
        r = _R[e].timeStamps[t] === undefined ? parseInt(i) + 100 : a - _R[e].timeStamps[t],
        o = parseInt(r) > i;
      return o && (_R[e].timeStamps[t] = a), o;
    },
    getURLDetails: function getURLDetails(e) {
      (e = e === undefined ? {} : e).url = e.url === undefined ? window.location.href : e.url, e.url = e.url.replace("www", ""), e.protocol = 0 === e.url.indexOf("http://") ? "http://" : 0 === e.url.indexOf("https://") ? "https://" : 0 === e.url.indexOf("//") ? "//" : "relative";
      var i = e.url.replace("https://", "");
      i = i.replace("http://", ""), "relative" === e.protocol && (i = i.replace("//", "")), i = i.split("#"), e.anchor = (e.anchor === undefined || "" == e.anchor || 0 == e.anchor.length) && i.length > 1 ? i[1] : e.anchor === undefined ? "" : e.anchor.replace("#", ""), e.anchor = e.anchor.split("?"), e.queries = i[0].split("?"), e.queries = e.queries.length > 1 ? e.queries[1] : "", e.queries = e.queries.length > 1 ? e.queries[1] : e.anchor.length > 1 ? e.anchor[1] : e.queries, e.anchor = e.anchor[0];
      (i = i[0]).split("/");
      var t = i.split("/");
      return e.host = t[0], t.splice(0, 1), e.path = "/" + t.join("/"), "/" == e.path[e.path.length - 1] && (e.path = e.path.slice(0, -1)), e.origin = "relative" !== e.protocol ? e.protocol + e.host : window.location.origin.replace("www", "") + window.location.pathname, e.hash = ("" !== e.queries && e.queries !== undefined ? "?" + e.queries : "") + ("" !== e.anchor && e.anchor !== undefined ? "#" + e.anchor : ""), e;
    },
    scrollToId: function scrollToId(e) {
      var i = "scrollbelow" === e.action ? (getOffContH(_R[e.id].fullScreenOffsetContainer) || 0) - (parseInt(e.offset, 0) || 0) || 0 : 0 - (parseInt(e.offset, 0) || 0),
        t = "scrollbelow" === e.action ? _R[e.id].c : jQuery("#" + e.anchor),
        a = t.length > 0 ? t.offset().top : 0,
        r = {
          _y: _R[e.id].modal.useAsModal ? _R[e.id].cpar[0].scrollTop : window.pageYOffset !== document.documentElement.scrollTop ? 0 !== window.pageYOffset ? window.pageYOffset : document.documentElement.scrollTop : window.pageYOffset
        };
      a += "scrollbelow" === e.action ? _R[e.id].sbtimeline.fixed ? _R[e.id].cpar.parent().height() + _R[e.id].fullScreenOffsetResult : jQuery(_R[e.id].slides[0]).height() : 0, tpGS.gsap.to(r, e.speed / 1e3, {
        _y: a - i,
        ease: e.ease,
        onUpdate: function onUpdate() {
          _R[e.id].modal.useAsModal ? _R[e.id].cpar.scrollTop(r._y) : _R.document.scrollTop(r._y);
        },
        onComplete: function onComplete() {
          e.hash !== undefined && (window.location.hash = e.hash);
        }
      });
    }
  });
  var moduleEnterLeaveActions = function moduleEnterLeaveActions(e) {
      !_R[e].moduleActionsPrepared && _R[e].c[0].getElementsByClassName("rs-on-sh").length > 0 && (_R[e].c.on("tp-mouseenter", function () {
        _R[e].mouseoncontainer = !0;
        var i,
          t = _R[e].pr_next_key !== undefined ? _R[e].pr_next_key : _R[e].pr_processing_key !== undefined ? _R[e].pr_processing_key : _R[e].pr_active_key !== undefined ? _R[e].pr_active_key : _R[e].pr_next_key;
        if ("none" !== t && t !== undefined) {
          if ((t = _R.gA(_R[e].slides[t], "key")) !== undefined && _R[e].layers[t]) for (i in _R[e].layers[t]) _R[e].layers[t][i].className.indexOf("rs-on-sh") >= 0 && _R.renderLayerAnimation({
            layer: jQuery(_R[e].layers[t][i]),
            frame: "frame_1",
            mode: "trigger",
            id: e
          });
          for (i in _R[e].layers.static) _R[e].layers.static[i].className.indexOf("rs-on-sh") >= 0 && _R.renderLayerAnimation({
            layer: jQuery(_R[e].layers.static[i]),
            frame: "frame_1",
            mode: "trigger",
            id: e
          });
        }
      }), _R[e].c.on("tp-mouseleft", function () {
        _R[e].mouseoncontainer = !0;
        var i,
          t = _R[e].pr_next_key !== undefined ? _R[e].pr_next_key : _R[e].pr_processing_key !== undefined ? _R[e].pr_processing_key : _R[e].pr_active_key !== undefined ? _R[e].pr_active_key : _R[e].pr_next_key;
        if ("none" !== t && t !== undefined) {
          if ((t = _R.gA(_R[e].slides[t], "key")) !== undefined && _R[e].layers[t]) for (i in _R[e].layers[t]) _R[e].layers[t][i].className.indexOf("rs-on-sh") >= 0 && _R.renderLayerAnimation({
            layer: jQuery(_R[e].layers[t][i]),
            frame: "frame_999",
            mode: "trigger",
            id: e
          });
          for (i in _R[e].layers.static) _R[e].layers.static[i].className.indexOf("rs-on-sh") >= 0 && _R.renderLayerAnimation({
            layer: jQuery(_R[e].layers.static[i]),
            frame: "frame_999",
            mode: "trigger",
            id: e
          });
        }
      })), _R[e].moduleActionsPrepared = !0;
    },
    checkActions_intern = function checkActions_intern(layer, id) {
      var actions = _R.gA(layer[0], "actions"),
        _L = layer.data();
      for (var ei in actions = actions.split("||"), layer.addClass("rs-waction"), _L.events = _L.events === undefined ? [] : _L.events, _R[id].lastMouseDown = {}, actions) if (actions.hasOwnProperty(ei)) {
        var event = getEventParams(actions[ei].split(";"));
        _L.events.push(event), "click" === event.on && layer[0].classList.add("rs-wclickaction"), _R[id].fullscreen_esclistener || "exitfullscreen" != event.action && "togglefullscreen" != event.action || (_R.document.keyup(function (e) {
          27 == e.keyCode && jQuery("#rs-go-fullscreen").length > 0 && layer.trigger(event.on);
        }), _R[id].fullscreen_esclistener = !0);
        var targetlayer = "backgroundvideo" == event.layer ? jQuery("rs-bgvideo") : "firstvideo" == event.layer ? jQuery("rs-slide").find(".rs-layer-video") : jQuery("#" + event.layer);
        switch (-1 != jQuery.inArray(event.action, ["toggleslider", "toggle_mute_video", "toggle_global_mute_video", "togglefullscreen"]) && (_L._togglelisteners = !0), event.action) {
          case "togglevideo":
            jQuery.each(targetlayer, function () {
              updateToggleByList(jQuery(this), "videotoggledby", layer[0].id);
            });
            break;
          case "togglelayer":
            jQuery.each(targetlayer, function () {
              updateToggleByList(jQuery(this), "layertoggledby", layer[0].id), jQuery(this).data("triggered_startstatus", event.togglestate);
            });
            break;
          case "toggle_global_mute_video":
          case "toggle_mute_video":
            jQuery.each(targetlayer, function () {
              updateToggleByList(jQuery(this), "videomutetoggledby", layer[0].id);
            });
            break;
          case "toggleslider":
            _R[id].slidertoggledby == undefined && (_R[id].slidertoggledby = []), _R[id].slidertoggledby.push(layer[0].id);
            break;
          case "togglefullscreen":
            _R[id].fullscreentoggledby == undefined && (_R[id].fullscreentoggledby = []), _R[id].fullscreentoggledby.push(layer[0].id);
        }
      }
      _R[id].actionsPrepared = !0, layer.on("mousedown", function (e) {
        e.touches && (e = e.touches[0]), _R[id].lastMouseDown.pageX = e.pageX, _R[id].lastMouseDown.pageY = e.pageY;
      }), layer.on("click mouseenter mouseleave", function (e) {
        if ("click" === e.type) {
          var evt = e.touches ? e.touches[0] : e;
          if (Math.abs(evt.pageX - _R[id].lastMouseDown.pageX) > 5 || Math.abs(evt.pageY - _R[id].lastMouseDown.pageY) > 5) return;
        }
        for (var i in _L.events) if (_L.events.hasOwnProperty(i) && _L.events[i].on === e.type) {
          var event = _L.events[i];
          if (!(event.repeat !== undefined && event.repeat > 0) || _R.delayer(id, 1e3 * event.repeat, _L.c[0].id + "_" + event.action)) {
            if ("click" === event.on && layer.hasClass("tp-temporarydisabled")) return !1;
            var targetlayer = "backgroundvideo" == event.layer ? jQuery(_R[id].slides[_R[id].pr_active_key]).find("rs-sbg-wrap rs-bgvideo") : "firstvideo" == event.layer ? jQuery(_R[id].slides[_R[id].pr_active_key]).find(".rs-layer-video").first() : jQuery("#" + event.layer),
              tex = targetlayer.length > 0;
            switch (event.action) {
              case "menulink":
                var linkto = _R.getURLDetails({
                    url: event.url,
                    anchor: event.anchor
                  }),
                  linkfrom = _R.getURLDetails();
                linkto.host == linkfrom.host && linkto.path == linkfrom.path && "_self" === event.target ? _R.scrollToId({
                  id: id,
                  offset: event.offset,
                  action: event.action,
                  anchor: event.anchor,
                  hash: linkto.hash,
                  speed: event.speed,
                  ease: event.ease
                }) : "_self" === event.target ? window.location = linkto.url + (linkto.anchor !== undefined && "" !== linkto.anchor ? "#" + linkto.anchor : "") : window.open(linkto.url + (linkto.anchor !== undefined && "" !== linkto.anchor ? "#" + linkto.anchor : "")), e.preventDefault();
                break;
              case "nextframe":
              case "prevframe":
              case "gotoframe":
              case "togglelayer":
              case "toggleframes":
              case "startlayer":
              case "stoplayer":
                if (targetlayer[0] === undefined) continue;
                var _ = _R[id]._L[targetlayer[0].id],
                  frame = event.frame,
                  tou = "triggerdelay";
                if ("click" === e.type && _.clicked_time_stamp !== undefined && new Date().getTime() - _.clicked_time_stamp < 300) return;
                if ("mouseenter" === e.type && _.mouseentered_time_stamp !== undefined && new Date().getTime() - _.mouseentered_time_stamp < 300) return;
                if (clearTimeout(_.triggerdelayIn), clearTimeout(_.triggerdelayOut), clearTimeout(_.triggerdelay), "click" === e.type && (_.clicked_time_stamp = new Date().getTime()), "mouseenter" === e.type && (_.mouseentered_time_stamp = new Date().getTime()), "mouseleave" === e.type && (_.mouseentered_time_stamp = undefined), "nextframe" === event.action || "prevframe" === event.action) {
                  _.forda = _.forda === undefined ? getFordWithAction(_) : _.forda;
                  var inx = jQuery.inArray(_.currentframe, _.ford);
                  for ("nextframe" === event.action && inx++, "prevframe" === event.action && inx--; "skip" !== _.forda[inx] && inx > 0 && inx < _.forda.length - 1;) "nextframe" === event.action && inx++, "prevframe" === event.action && inx--, inx = Math.min(Math.max(0, inx), _.forda.length - 1);
                  frame = _.ford[inx];
                }
                jQuery.inArray(event.action, ["toggleframes", "togglelayer", "startlayer", "stoplayer"]) >= 0 && (_.triggeredstate = "startlayer" === event.action || "togglelayer" === event.action && "frame_1" !== _.currentframe || "toggleframes" === event.action && _.currentframe !== event.frameN, "togglelayer" === event.action && !0 === _.triggeredstate && _.currentframe !== undefined && "frame_999" !== _.currentframe && (_.triggeredstate = !1), frame = _.triggeredstate ? "toggleframes" === event.action ? event.frameN : "frame_1" : "toggleframes" === event.action ? event.frameM : "frame_999", tou = _.triggeredstate ? "triggerdelayIn" : "triggerdelayOut", _.triggeredstate ? _R.toggleState(_.layertoggledby) : (_R.stopVideo && _R.stopVideo(targetlayer, id), _R.unToggleState(_.layertoggledby)));
                var pars = {
                  layer: targetlayer,
                  frame: frame,
                  mode: "trigger",
                  id: id
                };
                !0 === event.children && (pars.updateChildren = !0, pars.fastforward = !0), _R.renderLayerAnimation && (clearTimeout(_[tou]), _[tou] = setTimeout(function (e) {
                  _R.renderLayerAnimation(e);
                }, 1e3 * event.delay, pars));
                break;
              case "playvideo":
                tex && _R.playVideo(targetlayer, id);
                break;
              case "stopvideo":
                tex && _R.stopVideo && _R.stopVideo(targetlayer, id);
                break;
              case "togglevideo":
                tex && (_R.isVideoPlaying(targetlayer, id) ? _R.stopVideo && _R.stopVideo(targetlayer, id) : _R.playVideo(targetlayer, id));
                break;
              case "mutevideo":
                tex && _R.Mute(targetlayer, id, !0);
                break;
              case "unmutevideo":
                tex && _R.Mute && _R.Mute(targetlayer, id, !1);
                break;
              case "toggle_mute_video":
                tex && (_R.Mute(targetlayer, id) ? _R.Mute(targetlayer, id, !1) : _R.Mute && _R.Mute(targetlayer, id, !0));
                break;
              case "toggle_global_mute_video":
                var pvl = _R[id].playingvideos != undefined && _R[id].playingvideos.length > 0;
                pvl && (_R[id].globalmute ? jQuery.each(_R[id].playingvideos, function (e, i) {
                  _R.Mute && _R.Mute(i, id, !1);
                }) : jQuery.each(_R[id].playingvideos, function (e, i) {
                  _R.Mute && _R.Mute(i, id, !0);
                })), _R[id].globalmute = !_R[id].globalmute;
                break;
              default:
                tpGS.gsap.delayedCall(event.delay, function (targetlayer, id, event, layer) {
                  switch (event.action) {
                    case "openmodal":
                      _R.openModalAPI(event.modal, event.modalslide === undefined ? 0 : event.modalslide, _R[id].ajaxUrl, !0, id, event);
                      break;
                    case "closemodal":
                      _R.revModal(id, {
                        mode: "close"
                      });
                      break;
                    case "callback":
                      eval(event.callback);
                      break;
                    case "simplelink":
                      window.open(event.url, event.target);
                      break;
                    case "simulateclick":
                      targetlayer.length > 0 && targetlayer.trigger("click");
                      break;
                    case "toggleclass":
                      targetlayer.length > 0 && targetlayer.toggleClass(event.classname);
                      break;
                    case "scrollbelow":
                    case "scrollto":
                      "scrollbelow" === event.action && layer.addClass("tp-scrollbelowslider"), _R.scrollToId({
                        id: id,
                        offset: event.offset,
                        action: event.action,
                        anchor: event.id,
                        speed: event.speed,
                        ease: event.ease
                      });
                      break;
                    case "jumptoslide":
                      switch (event.slide.toLowerCase()) {
                        case "rs-random":
                          var ts = Math.min(Math.max(0, Math.ceil(Math.random() * _R[id].realslideamount) - 1));
                          ts = _R[id].activeRSSlide == ts ? ts > 0 ? ts - 1 : ts + 1 : ts, _R.callingNewSlide(id, _R[id].slides[ts].dataset.key, "carousel" === _R[id].sliderType);
                          break;
                        case "+1":
                        case "next":
                        case "rs-next":
                          _R[id].sc_indicator = "arrow", _R[id].sc_indicator_dir = 0, _R.callingNewSlide(id, 1, "carousel" === _R[id].sliderType);
                          break;
                        case "rs-previous":
                        case "rs-prev":
                        case "previous":
                        case "prev":
                        case "-1":
                          _R[id].sc_indicator = "arrow", _R[id].sc_indicator_dir = 1, _R.callingNewSlide(id, -1, "carousel" === _R[id].sliderType);
                          break;
                        case "first":
                        case "rs-first":
                          _R[id].sc_indicator = "arrow", _R[id].sc_indicator_dir = 1, _R.callingNewSlide(id, 0, "carousel" === _R[id].sliderType);
                          break;
                        case "last":
                        case "rs-last":
                          _R[id].sc_indicator = "arrow", _R[id].sc_indicator_dir = 0, _R.callingNewSlide(id, _R[id].slideamount - 1, "carousel" === _R[id].sliderType);
                          break;
                        default:
                          var ts = _R.isNumeric(event.slide) ? parseInt(event.slide, 0) : event.slide;
                          _R.callingNewSlide(id, ts, "carousel" === _R[id].sliderType);
                      }
                      break;
                    case "toggleslider":
                      _R[id].noloopanymore = 0, "playing" == _R[id].sliderstatus ? (_R[id].c.revpause(), _R[id].forcepaused = !0, _R.unToggleState(_R[id].slidertoggledby)) : (_R[id].forcepaused = !1, _R[id].c.revresume(), _R.toggleState(_R[id].slidertoggledby));
                      break;
                    case "pauseslider":
                      _R[id].c.revpause(), _R.unToggleState(_R[id].slidertoggledby);
                      break;
                    case "playslider":
                      _R[id].noloopanymore = 0, _R[id].c.revresume(), _R.toggleState(_R[id].slidertoggledby);
                      break;
                    case "gofullscreen":
                    case "exitfullscreen":
                    case "togglefullscreen":
                      var gf;
                      jQuery(".rs-go-fullscreen").length > 0 && ("togglefullscreen" == event.action || "exitfullscreen" == event.action) ? (jQuery(".rs-go-fullscreen").removeClass("rs-go-fullscreen"), gf = _R[id].c.closest("rs-fullwidth-wrap").length > 0 ? _R[id].c.closest("rs-fullwidth-wrap") : _R[id].c.closest("rs-module-wrap"), _R[id].minHeight = _R[id].oldminheight, _R[id].infullscreenmode = !1, _R[id].c.revredraw(), _R[id].c.revredraw(), jQuery(window).trigger("resize"), _R.unToggleState(_R[id].fullscreentoggledby)) : 0 != jQuery(".rs-go-fullscreen").length || "togglefullscreen" != event.action && "gofullscreen" != event.action || (gf = _R[id].c.closest("rs-fullwidth-wrap").length > 0 ? _R[id].c.closest("rs-fullwidth-wrap") : _R[id].c.closest("rs-module-wrap"), gf.addClass("rs-go-fullscreen"), _R[id].oldminheight = _R[id].minHeight, _R[id].minHeight = _R.getWinH(id), _R[id].infullscreenmode = !0, jQuery(window).trigger("resize"), _R.toggleState(_R[id].fullscreentoggledby), _R[id].c.revredraw());
                      break;
                    default:
                      _R[id].c.trigger("layeraction", [event.action, layer, event]);
                  }
                }, [targetlayer, id, event, layer]);
            }
          }
        }
      });
    };
  function getFordWithAction(e) {
    var i = [];
    for (var t in e.ford) e.frames[e.ford[t]].timeline.waitoncall ? i.push(e.ford[t]) : i.push("skip");
    return i;
  }
  function updateToggleByList(e, i, t) {
    var a = e.data(i);
    a === undefined && (a = []), a.push(t), e.data(i, a);
  }
  function getEventParams(e) {
    var i = {
      on: "click",
      delay: 0,
      ease: "power2.out",
      speed: 400
    };
    for (var t in e) if (e.hasOwnProperty(t)) {
      var a = e[t].split(":");
      switch (a.length > 2 && "call" === a[0] && (a[1] = a.join(":").replace(a[0] + ":", "")), a[0]) {
        case "modal":
          i.modal = a[1];
          break;
        case "ms":
          i.modalslide = a[1];
          break;
        case "m":
          i.frameM = a[1];
          break;
        case "n":
          i.frameN = a[1];
          break;
        case "o":
          i.on = "click" === a[1] || "c" === a[1] ? "click" : "ml" === a[1] || "mouseleave" === a[1] ? "mouseleave" : "mouseenter" === a[1] || "me" === a[1] ? "mouseenter" : a[1];
          break;
        case "d":
          i.delay = parseInt(a[1], 0) / 1e3, i.delay = "NaN" === i.delay || isNaN(i.delay) ? 0 : i.delay;
          break;
        case "rd":
          i.repeat = parseInt(a[1], 0) / 1e3, i.repeat = "NaN" === i.repeat || isNaN(i.repeat) ? 0 : i.repeat;
          break;
        case "a":
          i.action = a[1];
          break;
        case "f":
          i.frame = a[1];
          break;
        case "slide":
          i.slide = a[1];
          break;
        case "layer":
          i.layer = a[1];
          break;
        case "sp":
          i.speed = parseInt(a[1], 0);
          break;
        case "e":
          i.ease = a[1];
          break;
        case "ls":
          i.togglestate = a[1];
          break;
        case "offset":
          i.offset = a[1];
          break;
        case "call":
          i.callback = a[1];
          break;
        case "url":
          i.url = "";
          for (var r = 1; r < a.length; r++) i.url += a[r] + (r === a.length - 1 ? "" : ":");
          break;
        case "target":
          i.target = a[1];
          break;
        case "class":
          i.classname = a[1];
          break;
        case "ch":
          i.children = "true" == a[1] || 1 == a[1] || "t" == a[1];
          break;
        default:
          a[0].length > 0 && "" !== a[0] && (i[a[0]] = a[1]);
      }
    }
    return i;
  }
  var getOffContH = function getOffContH(e) {
    if (e == undefined) return 0;
    if (e.split(",").length > 1) {
      var i = e.split(","),
        t = 0;
      return i && jQuery.each(i, function (e, i) {
        jQuery(i).length > 0 && (t += jQuery(i).outerHeight(!0));
      }), t;
    }
    return jQuery(e).height();
  };
  window.RS_MODULES = window.RS_MODULES || {}, window.RS_MODULES.actions = {
    loaded: !0,
    version: version
  }, window.RS_MODULES.checkMinimal && window.RS_MODULES.checkMinimal();
}(jQuery), function (e) {
  "use strict";

  jQuery.fn.revolution = jQuery.fn.revolution || {};
  var i = jQuery.fn.revolution;
  jQuery.extend(!0, i, {
    prepareCarousel: function prepareCarousel(e, t, a) {
      if (void 0 !== e) {
        var o = i[e].carousel;
        o.slidepositions = void 0 === o.slidepositions ? [] : o.slidepositions, o.slideFakePositions = void 0 === o.slideFakePositions ? [] : o.slideFakePositions, t = o.lastdirection = r(t, o.lastdirection), i.setCarouselDefaults(e), void 0 === o.slidepositions[0] && (o.slideAnims = [], i.organiseCarousel(e, "right", !0, !1, !1), o.focused = 0, o.keepFocusedFirst = !0), o.slide_offset = void 0 !== o.slide_offset && i.isNumeric(o.slide_offset) ? o.slide_offset : 0, o.swipeTo = o.slide_offset + s(e), o.swipeToDistance = Math.abs(o.slide_offset) + Math.abs(s(e)), void 0 !== o.swipeTo && i.isNumeric(o.swipeTo) ? void 0 !== a ? i.swipeAnimate({
          id: e,
          to: o.swipeTo,
          distance: o.swipeToDistance,
          direction: t,
          fix: !0,
          speed: a
        }) : i.swipeAnimate({
          id: e,
          to: o.swipeTo,
          distance: o.swipeToDistance,
          direction: t,
          fix: !0
        }) : i.swipeAnimate({
          id: e,
          to: 0,
          direction: t,
          speed: 0
        });
      }
    },
    carouselToEvalPosition: function carouselToEvalPosition(e, a, o) {
      var s = i[e].carousel;
      if (s.justify) s.focused = void 0 === s.focused ? 0 : s.focused, s.slidepositions[s.focused] = void 0 === s.slidepositions[s.focused] ? 0 : s.slidepositions[s.focused], s.slide_offset_target = t(e, s.focused);else {
        a = s.lastdirection = r(a, s.lastdirection);
        var n = "center" === s.horizontal_align ? (s.wrapwidth / 2 - s.slide_width / 2 - s.slide_offset) / s.slide_width : (0 - s.slide_offset) / s.slide_width,
          d = n % i[e].slideamount,
          l = d - Math.floor(d),
          c = -1 * (Math.ceil(d) - d),
          p = -1 * (Math.floor(d) - d),
          g = l * s.slide_width,
          u = g >= 20 && "left" === a ? 1 : g >= s.slide_width - 20 && "right" === a ? 2 : g < 20 && "left" === a ? 3 : g < s.slide_width - 20 && "right" === a ? 4 : 5,
          h = 1 === u || 2 === u ? c : 3 === u || 4 === u ? p : 0;
        s.slide_offset_target = (s.infinity ? h : d < 0 ? d : n > i[e].slideamount - 1 ? n - (i[e].slideamount - 1) : h) * s.slide_width;
      }
      return s.slide_offset_target !== s.slide_offset_targetCACHE && !0 !== o && (0 !== Math.abs(s.slide_offset_target) ? i.animateCarousel(e, a, !0) : i.organiseCarousel(e, a), s.slide_offset_targetCACHE = s.slide_offset_target), s.slide_offset_target;
    },
    loadVisibleCarouselItems: function loadVisibleCarouselItems(e, t) {
      var a = [];
      i[e].carousel.focused = parseInt(i[e].carousel.focused, 0), i[e].carousel.focused = i.isNumeric(i[e].carousel.focused) ? i[e].carousel.focused : 0;
      for (var r = 0; r < Math.ceil(i[e].carousel.maxVisibleItems / 2); r++) {
        var o = "right" === i[e].carousel.horizontal_align ? i[e].carousel.focused - r : i[e].carousel.focused + r,
          s = "center" === i[e].carousel.horizontal_align ? i[e].carousel.focused - r : "left" === i[e].carousel.horizontal_align ? i[e].carousel.maxVisibleItems + o - 1 : o - i[e].carousel.maxVisibleItems + 1;
        o = o >= i[e].slideamount ? o - i[e].slideamount + 0 : o, s = s >= i[e].slideamount ? s - i[e].slideamount + 0 : s, o = o < 0 ? i[e].slideamount + o : o, s = s < 0 ? i[e].slideamount + s : s, a.push(i[e].slides[o]), o !== s && a.push(i[e].slides[s]);
      }
      return t && (i.loadImages(a, e, 1), i.waitForCurrentImages(a, e)), a;
    },
    organiseCarousel: function organiseCarousel(e, t, a, r, o) {
      Math.round(1e5 * Math.random());
      var s = i[e].carousel,
        n = "center" === s.horizontal_align ? 2 : 1,
        d = Math.ceil(s.maxVisibleItems / n),
        l = "center" === s.horizontal_align ? s.wrapwidth / 2 + s.maxwidth / 2 : s.maxwidth - s.slide_width,
        c = "center" === s.horizontal_align ? s.wrapwidth / 2 - s.maxwidth / 2 : 0 - s.slide_width,
        p = 0,
        g = 0,
        u = 0;
      if (s.ocfirsttun = !0, t = s.slide_offset < s.cached_slide_offset ? "left" : "right", s.cached_slide_offset = s.slide_offset, !0 !== s.justify && "center" === s.horizontal_align) {
        var h = 2 * (s.windhalf - s.wrapoffset) + s.slide_width;
        h >= s.maxwidth && ("left" === t && (l = 2 * s.windhalf, c = 0 - (s.slide_width - (h - s.maxwidth))), "right" === t && (l = 2 * s.windhalf - (h - s.maxwidth), c = 0 - s.slide_width));
      }
      for (var m = 2 * s.windhalf, v = 0, f = -1, y = 0; y < s.len; y++) !0 === s.justify ? (p += y > 0 ? s.slide_widths[y - 1] + s.space : s.slide_offset, s.wrapwidth >= s.maxwidth && "center" !== s.horizontal_align && (s.slideFakePositions[y] = p - s.slide_offset), c = 0 - s.slide_widths[y], l = s.maxwidth - s.slide_widths[y], s.inneroffset = 0) : (p = y * s.slide_width + s.slide_offset, s.wrapwidth >= s.maxwidth && "left" === s.horizontal_align && (s.slideFakePositions[y] = y * s.slide_width), s.wrapwidth >= s.maxwidth && "right" === s.horizontal_align && (s.slideFakePositions[y] = s.wrapwidth - (y + 1) * s.slide_width)), u = g = p, s.infinity && (g = g >= l - s.inneroffset ? g - s.maxwidth : g <= c - s.inneroffset ? g + s.maxwidth : g), m > g && (m = g, y), v < g && (v = g, f = y), s.slidepositions[y] = u > s.maxwidth + l ? g - s.maxwidth : u < c - s.maxwidth ? g + s.maxwidth : g;
      s.infinity && m > 0 && v > s.wrapwidth && (s.slidepositions[f] -= s.maxwidth);
      var w = 999,
        b = 0,
        _ = (i[e].module.width, !1),
        S = "right" === s.horizontal_align ? 0 : s.wrapwidth;
      if (i[e].slides) for (y = 0; y < i[e].slides.length; y++) {
        var x = {
            left: (g = s.slidepositions[y]) + s.inneroffset,
            width: !0 === s.justify ? s.slide_widths[y] : s.slide_width,
            x: 0
          },
          k = 0;
        if (void 0 === s.slideAnims[y] && (x.transformOrigin = "50% " + s.vertical_align, x.scale = 1, x.force3D = !0, x.transformStyle = "3D" != i[e].parallax.type && "3d" != i[e].parallax.type ? "flat" : "preserve-3d"), s.justify) x.autoAlpha = 1, s.wrapwidth >= s.maxwidth && "center" !== s.horizontal_align || ("center" === s.horizontal_align && s.slidepositions[y] < s.windhalf && s.slidepositions[y] + s.slide_widths[y] > s.windhalf ? s.focused = y : "left" === s.horizontal_align && s.slidepositions[y] >= -25 && s.slidepositions[y] < s.windhalf && (!_ || s.slidepositions[y] < S) ? (s.focused = y, _ = !0, S = s.slidepositions[y]) : "right" === s.horizontal_align && s.slidepositions[y] + s.slide_widths[y] <= s.wrapwidth + 25 && (s.slide_widths[y] < s.windhalf && s.slidepositions[y] > s.windhalf || s.slidepositions[y] > s.wrapwidth - s.slide_widths[y]) && (!_ || s.slidepositions[y] > S) && (s.focused = y, _ = !0, S = s.slidepositions[y]), s.focused = s.focused >= s.len ? s.infinity ? 0 : s.len - 1 : s.focused < 0 ? s.infinity ? s.len - 1 : 0 : s.focused);else {
          k = "center" === s.horizontal_align ? (Math.abs(s.wrapwidth / 2) - (x.left + s.slide_width / 2)) / s.slide_width : (s.inneroffset - x.left) / s.slide_width, (Math.abs(k) < w || 0 === k) && (w = Math.abs(k), s.focused = y), void 0 !== s.minScale && s.minScale > 0 && (s.vary_scale ? x.scale = 1 - Math.abs((1 - s.minScale) / d * k) : x.scale = k >= 1 || k <= -1 ? s.minScale : s.minScale + (1 - s.minScale) * (1 - Math.abs(k)), b = k * (x.width - x.width * x.scale) / 2), s.fadeout && (s.vary_fade ? x.autoAlpha = 1 - Math.abs(s.maxOpacity / d * k) : x.autoAlpha = k >= 1 || k <= -1 ? s.maxOpacity : s.maxOpacity + (1 - s.maxOpacity) * (1 - Math.abs(k)));
          var L = Math.ceil(s.maxVisibleItems / n) - Math.abs(k);
          x.autoAlpha = void 0 === x.autoAlpha ? 1 : x.autoAlpha, x.autoAlpha = Math.max(0, Math.min(L, x.autoAlpha)), void 0 !== s.maxRotation && 0 != Math.abs(s.maxRotation) && (s.vary_rotation ? (x.rotationY = Math.abs(s.maxRotation) - Math.abs((1 - Math.abs(1 / d * k)) * s.maxRotation), x.autoAlpha = Math.abs(x.rotationY) > 90 ? 0 : x.autoAlpha) : x.rotationY = k >= 1 || k <= -1 ? s.maxRotation : Math.abs(k) * s.maxRotation, x.rotationY = k < 0 ? -1 * x.rotationY : x.rotationY, i.isSafari11() && (x.z = 0 !== k ? 0 - Math.abs(x.rotationY) : 0)), x.x = Math.floor(-1 * s.space * k * (s.offsetScale ? x.scale : 1)), void 0 !== x.scale && (x.x = x.x + b);
        }
        x.x += s.wrapwidth >= s.maxwidth && ("left" === s.horizontal_align || "right" === s.horizontal_align) ? s.slideFakePositions[y] : Math.floor(x.left), delete x.left, x.zIndex = s.justify ? 95 : Math.round(100 - Math.abs(5 * k)), !0 !== o && (void 0 !== s.slideAnims[y] && (x.width === s.slideAnims[y].width && delete x.width, x.x === s.slideAnims[y].x && delete x.x, x.autoAlpha === s.slideAnims[y].autoAlpha && delete x.autoAlpha, x.scale === s.slideAnims[y].scale && delete x.scale, x.zIndex === s.slideAnims[y].zIndex && delete x.zIndex, x.rotationY === s.slideAnims[y].rotationY && delete x.rotationY), tpGS.gsap.set(i[e].slides[y], x), s.slideAnims[y] = jQuery.extend(!0, s.slideAnims[y], x));
      }
      if (i.loadVisibleCarouselItems(e, !0), r && !0 !== o) {
        if (s.focused = void 0 === s.focused ? 0 : s.focused, s.oldfocused = void 0 === s.oldfocused ? 0 : s.oldfocused, i[e].pr_next_key = s.focused, s.focused !== s.oldfocused) for (var R in void 0 !== s.oldfocused && i.removeTheLayers(jQuery(i[e].slides[s.oldfocused]), e), i.animateTheLayers({
          slide: s.focused,
          id: e,
          mode: "start"
        }), i.animateTheLayers({
          slide: "individual",
          id: e,
          mode: i[e].carousel.allLayersStarted ? "rebuild" : "start"
        }), i[e].sbgs) i[e].sbgs.hasOwnProperty(R) && void 0 !== i[e].sbgs[R].bgvid && 0 !== i[e].sbgs[R].bgvid.length && ("" + i[e].sbgs[R].skeyindex == "" + s.focused ? i.playBGVideo(e, i.gA(i[e].pr_next_slide[0], "key")) : i.stopBGVideo(e, i[e].sbgs[R].key));
        s.oldfocused = s.focused, i[e].c.trigger("revolution.nextslide.waiting");
      }
    },
    swipeAnimate: function swipeAnimate(e) {
      var t = i[e.id].carousel,
        r = {
          from: t.slide_offset,
          to: e.to
        },
        o = void 0 === e.speed ? .5 : e.speed;
      if (t.distance = void 0 !== e.distance ? e.distance : e.to, void 0 !== t.positionanim && t.positionanim.pause(), e.fix) {
        if (!1 !== t.snap) {
          var s = t.slide_offset,
            n = "end" === e.phase ? t.focusedBeforeSwipe : t.focused;
          t.slide_offset = e.to, i.organiseCarousel(e.id, e.direction, !0, !1, !1), Math.abs(t.swipeDistance) > 40 && n == t.focused && (t.focused = "right" === e.direction ? t.focused - 1 : t.focused + 1, t.focused = t.focused >= t.len ? t.infinity ? 0 : t.len - 1 : t.focused < 0 ? t.infinity ? t.len - 1 : 0 : t.focused), r.to += i.carouselToEvalPosition(e.id, e.direction, !0), t.slide_offset = s, i.organiseCarousel(e.id, e.direction, !0, !1, !1), t.keepFocusedFirst && (t.keepFocusedFirst = !1, t.focused = 0);
        } else !0 !== t.infinity ? (r.to > 0 && (r.to = 0), r.to < t.wrapwidth - t.maxwidth && (r.to = t.wrapwidth - t.maxwidth)) : "end" === e.phase ? t.dragModeJustEnded = !0 : !0 !== t.dragModeJustEnded ? r.to += i.carouselToEvalPosition(e.id, e.direction, !0) : t.dragModeJustEnded = !1;
        0 !== (o = t.speed / 1e3 * a(Math.abs(Math.abs(r.from) - Math.abs(t.distance)) / t.wrapwidth)) && o < .1 && Math.abs(r.to) > 25 && (o = .3);
      }
      t.swipeDistance = 0, o = !0 !== t.firstSwipedDone ? 0 : o, t.firstSwipedDone = !0, t.positionanim = tpGS.gsap.to(r, o, {
        from: r.to,
        onUpdate: function onUpdate() {
          t.slide_offset = r.from % t.maxwidth, i.organiseCarousel(e.id, e.direction, !0 !== e.fix, !0 !== e.fix), t.slide_offset = r.from;
        },
        onComplete: function onComplete() {
          t.slide_offset = r.from % t.maxwidth, "carousel" !== i[e.id].sliderType || t.fadein || (tpGS.gsap.to(i[e.id].canvas, 1, {
            scale: 1,
            opacity: 1
          }), t.fadein = !0), t.lastNotSimplifedSlideOffset = t.slide_offset, t.justDragged = !1, e.fix && (t.focusedAfterAnimation = t.focused, e.newSlide && t.focusedBeforeSwipe !== t.focused && i.callingNewSlide(e.id, jQuery(i[e.id].slides[t.focused]).data("key"), !0), i.organiseCarousel(e.id, e.direction, !0, !0), i[e.id].c.trigger("revolution.slide.carouselchange", {
            slider: e.id,
            slideIndex: parseInt(i[e.id].pr_active_key, 0) + 1,
            slideLIIndex: i[e.id].pr_active_key,
            slide: i[e.id].pr_next_slide,
            currentslide: i[e.id].pr_next_slide,
            prevSlideIndex: void 0 !== i[e.id].pr_lastshown_key && parseInt(i[e.id].pr_lastshown_key, 0) + 1,
            prevSlideLIIndex: void 0 !== i[e.id].pr_lastshown_key && parseInt(i[e.id].pr_lastshown_key, 0),
            prevSlide: void 0 !== i[e.id].pr_lastshown_key && i[e.id].slides[i[e.id].pr_lastshown_key]
          }));
        },
        ease: e.easing ? e.easing : t.easing
      });
    },
    defineCarouselElements: function defineCarouselElements(e) {
      var t = i[e].carousel;
      t.infbackup = t.infinity, t.maxVisiblebackup = t.maxVisibleItems, t.slide_offset = "none", t.slide_offset = 0, t.cached_slide_offset = 0, t.wrap = jQuery(i[e].canvas[0].parentNode), 0 !== t.maxRotation && ("3D" !== i[e].parallax.type && "3d" !== i[e].parallax.type || tpGS.gsap.set(t.wrap, {
        perspective: "1600px",
        transformStyle: "preserve-3d"
      }));
    },
    setCarouselDefaults: function setCarouselDefaults(e, t) {
      var a = i[e].carousel;
      if (a.slide_width = !0 !== a.stretch ? i[e].gridwidth[i[e].level] * (0 === i[e].CM.w ? 1 : i[e].CM.w) : i[e].canv.width, a.slide_height = !0 !== a.stretch ? i[e].infullscreenmode ? i.getWinH(e) - i.getFullscreenOffsets(e) : i[e].gridheight[i[e].level] * (0 === i[e].CM.w ? 1 : i[e].CM.w) : i[e].canv.height, a.ratio = a.slide_width / a.slide_height, a.len = i[e].slides.length, a.maxwidth = i[e].slideamount * a.slide_width, 1 != a.justify && a.maxVisiblebackup > a.len && (a.maxVisibleItems = a.len % 2 ? a.len : a.len + 1), a.wrapwidth = a.maxVisibleItems * a.slide_width + (a.maxVisibleItems - 1) * a.space, a.wrapwidth = "auto" != i[e].sliderLayout ? a.wrapwidth > i[e].canv.width ? i[e].canv.width : a.wrapwidth : a.wrapwidth > i[e].module.width ? i[e].module.width : a.wrapwidth, !0 === a.justify) {
        a.slide_height = "fullscreen" === i[e].sliderLayout ? i[e].module.height : i[e].gridheight[i[e].level], a.slide_widths = [], a.slide_widthsCache = void 0 === a.slide_widthsCache ? [] : a.slide_widthsCache, a.maxwidth = 0;
        for (var r = 0; r < a.len; r++) if (i[e].slides.hasOwnProperty(r)) {
          var o = i.gA(i[e].slides[r], "iratio");
          o = void 0 === o || 0 === o || null === o ? a.ratio : o, a.slide_widths[r] = Math.round(a.slide_height * o), !1 !== a.justifyMaxWidth && (a.slide_widths[r] = Math.min(a.wrapwidth, a.slide_widths[r])), a.slide_widths[r] !== a.slide_widthsCache[r] && (a.slide_widthsCache[r] = a.slide_widths[r], !0 !== t && tpGS.gsap.set(i[e].slides[r], {
            width: a.slide_widths[r]
          })), a.maxwidth += a.slide_widths[r] + a.space;
        }
      }
      if (a.infinity = !(a.wrapwidth >= a.maxwidth) && a.infbackup, !0 !== a.quickmode) {
        a.wrapoffset = "center" === a.horizontal_align ? (i[e].canv.width - i[e].outNavDims.right - i[e].outNavDims.left - a.wrapwidth) / 2 : 0, a.wrapoffset = "auto" != i[e].sliderLayout && i[e].outernav ? 0 : a.wrapoffset < i[e].outNavDims.left ? i[e].outNavDims.left : a.wrapoffset;
        var s = "3D" == i[e].parallax.type || "3d" == i[e].parallax.type ? "visible" : "hidden",
          n = "right" === a.horizontal_align ? {
            left: "auto",
            right: a.wrapoffset + "px",
            width: a.wrapwidth,
            overflow: s
          } : "left" === a.horizontal_align || a.wrapwidth < i.winW ? {
            right: "auto",
            left: a.wrapoffset + "px",
            width: a.wrapwidth,
            overflow: s
          } : {
            right: "auto",
            left: "auto",
            width: "100%",
            overflow: s
          };
        void 0 !== a.cacheWrapObj && n.left === a.cacheWrapObj.left && n.right === a.cacheWrapObj.right && n.width === a.cacheWrapObj.width || (window.requestAnimationFrame(function () {
          tpGS.gsap.set(a.wrap, n), i[e].carousel.wrapoffset > 0 && tpGS.gsap.set(i[e].canvas, {
            left: 0
          });
        }), a.cacheWrapObj = jQuery.extend(!0, {}, n)), a.inneroffset = "right" === a.horizontal_align ? a.wrapwidth - a.slide_width : 0, a.windhalf = "auto" === i[e].sliderLayout ? i[e].module.width / 2 : i.winW / 2;
      }
    }
  });
  var t = function t(e, _t2) {
      var a = i[e].carousel;
      return "center" === a.horizontal_align ? a.windhalf - a.slide_widths[_t2] / 2 - a.slidepositions[_t2] : "left" === a.horizontal_align ? 0 - a.slidepositions[_t2] : a.wrapwidth - a.slide_widths[_t2] - a.slidepositions[_t2];
    },
    a = function a(e) {
      return e < 1 ? Math.sqrt(1 - (e -= 1) * e) : Math.sqrt(e);
    },
    r = function r(e, i) {
      return null === e || jQuery.isEmptyObject(e) ? i : void 0 === e ? "right" : e;
    },
    o = function o(e, i) {
      return Math.abs(e) > Math.abs(i) ? e > 0 ? e - Math.abs(Math.floor(e / i) * i) : e + Math.abs(Math.floor(e / i) * i) : e;
    },
    s = function s(e) {
      var t,
        a,
        r,
        s,
        n,
        d = 0,
        l = i[e].carousel;
      if (void 0 !== l.positionanim && l.positionanim.pause(), l.justify) "center" === l.horizontal_align ? d = l.windhalf - l.slide_widths[l.focused] / 2 - l.slidepositions[l.focused] : "left" === l.horizontal_align ? d = 0 - l.slidepositions[l.focused] : "right" === l.horizontal_align && (d = l.wrapwidth - l.slide_widths[l.focused] - l.slidepositions[l.focused]), d = d > l.maxwidth / 2 ? l.maxwidth - d : d < 0 - l.maxwidth / 2 ? d + l.maxwidth : d;else {
        var c = i[e].pr_processing_key >= 0 ? i[e].pr_processing_key : i[e].pr_active_key >= 0 ? i[e].pr_active_key : 0,
          p = ("center" === l.horizontal_align ? (l.wrapwidth / 2 - l.slide_width / 2 - l.slide_offset) / l.slide_width : (0 - l.slide_offset) / l.slide_width) % i[e].slideamount;
        d = (l.infinity ? (t = p, a = c, r = i[e].slideamount, n = a - r - t, s = o(s = a - t, r), n = o(n, r), -(Math.abs(s) > Math.abs(n) ? n : s)) : p - c) * l.slide_width;
      }
      return !1 === l.snap && l.justDragged && (d = 0), l.justDragged = !1, d;
    };
  window.RS_MODULES = window.RS_MODULES || {}, window.RS_MODULES.carousel = {
    loaded: !0,
    version: "6.2.0"
  }, window.RS_MODULES.checkMinimal && window.RS_MODULES.checkMinimal();
}(jQuery), function (e) {
  "use strict";

  var i = ["chars", "words", "lines"],
    t = ["Top", "Right", "Bottom", "Left"],
    a = ["TopLeft", "TopRight", "BottomRight", "BottomLeft"],
    r = ["top", "right", "bottom", "left"];
  jQuery.fn.revolution = jQuery.fn.revolution || {};
  var o = jQuery.fn.revolution;
  jQuery.extend(!0, o, {
    checkLayerDimensions: function checkLayerDimensions(e) {
      var i = !1;
      for (var t in o[e.id].layers[e.skey]) if (o[e.id].layers[e.skey].hasOwnProperty(t)) {
        var a = o[e.id].layers[e.skey][t],
          r = o[e.id]._L[a.id];
        r.eow !== a.offsetWidth && "true" !== o.gA(a, "vary-layer-dims") && (i = !0), r.lastknownwidth = r.eow, r.lastknownheight = r.eoh, r._slidelink || o[e.id].caches.calcResponsiveLayersList.push({
          a: o[e.id]._L[a.id].c,
          b: e.id,
          c: 0,
          d: r.rsp_bd,
          e: e.slideIndex
        });
      }
      return i;
    },
    requestLayerUpdates: function requestLayerUpdates(e, i, t, a) {
      var r, s, n, d;
      if (void 0 !== t) r = t, o[e]._L[r].pVisRequest !== o[e]._L[r].pVisStatus && (void 0 === o[e]._L[r]._ligid || !0 !== o[e]._L[o[e]._L[r]._ligid].childrenAtStartNotVisible ? (o[e]._L[r].pVisStatus = o[e]._L[r].pVisRequest, d = ("row" === o[e]._L[r].type || "column" === o[e]._L[r].type || "group" === o[e]._L[r].type) && void 0 !== o[e]._L[r].frames && void 0 !== o[e]._L[r].frames.frame_999 && void 0 !== o[e]._L[r].frames.frame_999.transform && "" + o[e]._L[r].frames.frame_999.transform.opacity != "0", n = 1 === o[e]._L[r].pVisRequest ? "remove" : d ? n : "add", s = 1 === o[e]._L[r].pVisRequest ? "remove" : d ? "add" : s) : (n = "add", s = "remove"), void 0 !== s && o[e]._L[r].p[0].classList[s]("rs-forceuntouchable"), void 0 !== n && o[e]._L[r].p[0].classList[n]("rs-forcehidden")), o[e]._L[r].pPointerStatus !== o[e]._L[r].pPeventsRequest && (o[e]._L[r].pPointerStatus = o[e]._L[r].pPeventsRequest, tpGS.gsap.set(o[e]._L[r].p[0], {
        pointerEvents: o[e]._L[r].pPointerStatus,
        visibility: 1 === o[e]._L[r].pVisStatus ? "visible" : 0 === o[e]._L[r].pVisStatus ? "hidden" : o[e]._L[r].pVisStatus
      })), void 0 !== a && "ignore" !== a && 0 !== a && (a++, "enterstage" === i || "leavestage" === i || "framestarted" === i ? o.isFirefox(e) ? -1 === o[e]._L[r].p[0].style.transform.indexOf("perspective") && (o[e]._L[r].p[0].style.transform += (0 === o[e]._L[r].p[0].style.transform.length ? " " : "") + "perspective(" + a + "px)") : (!window.isSafari11 && !0 !== o[e]._L[r].maskHasPerspective && 0 === o[e]._L[r].p[0].style.perspective.length || "none" == o[e]._L[r].p[0].style.perspective) && (o[e]._L[r].p[0].style.perspective = a + "px") : "frameended" === i && (o.isFirefox(e) ? o[e]._L[r].p[0].style.transform = o[e]._L[r].p[0].style.transform.replace("perspective(" + a + "px)", "") : window.isSafari11 || (o[e]._L[r].p[0].style.perspective = o[e]._L[r].p[0].style.perspective.replace(a - 1 + "px", ""))));else for (r in o[e]._L) o[e]._L.hasOwnProperty(r) && (o[e]._L[r].pVisRequest !== o[e]._L[r].pVisStatus && (o[e]._L[r].pVisStatus = o[e]._L[r].pVisRequest, 0 === o[e]._L[r].pVisStatus ? o[e]._L[r].p[0].classList.add("rs-forcehidden") : o[e]._L[r].p[0].classList.remove("rs-forcehidden")), o[e]._L[r].pPointerStatus !== o[e]._L[r].pPeventsRequest && (o[e]._L[r].pPointerStatus = o[e]._L[r].pPeventsRequest, tpGS.gsap.set(o[e]._L[r].p[0], {
        pointerEvents: o[e]._L[r].pPointerStatus,
        visibility: o[e]._L[r].pVisStatus
      })));
      "enterstage" === i && void 0 !== t && void 0 !== o[e]._L[t].esginside && o[e]._L[t].esginside.length > 0 && void 0 !== o[e]._L[t].esginside.esredraw && o[e]._L[t].esginside.esredraw();
    },
    updateMiddleZonesAndESG: function updateMiddleZonesAndESG(e) {
      var i,
        t = o[e].pr_processing_key || o[e].pr_active_key || 0;
      if (o[e].middleZones && o[e].middleZones.length > 0 && void 0 !== o[e].middleZones[t]) for (i = 0; i < o[e].middleZones[t].length; i++) tpGS.gsap.set(o[e].middleZones[t][i], {
        y: Math.round(o[e].module.height / 2 - o[e].middleZones[t][i].offsetHeight / 2) + "px"
      });
      if (o[e].smiddleZones && o[e].smiddleZones.length > 0) for (i = 0; i < o[e].smiddleZones.length; i++) tpGS.gsap.set(o[e].smiddleZones[i], {
        y: Math.round(o[e].module.height / 2 - o[e].smiddleZones[i].offsetHeight / 2) + "px"
      });
    },
    getRowHeights: function getRowHeights(e) {
      var i = 0,
        t = 0,
        a = 0,
        r = o[e].pr_processing_key || o[e].pr_active_key || 0,
        s = o[e].pr_active_key || 0;
      if (o[e].rowzones && o[e].rowzones.length > 0) {
        if (void 0 !== o[e].rowzones[r]) for (var n = 0; n < o[e].rowzones[r].length; n++) o[e].rowzonesHeights[r][n] = o[e].rowzones[r][n][0].offsetHeight, i += o[e].rowzonesHeights[r][n];
        if (s !== r) for (n = 0; n < o[e].rowzones[s].length; n++) o[e].rowzonesHeights[s][n] = o[e].rowzones[s][n][0].offsetHeight, t += o[e].rowzonesHeights[s][n];
      }
      if (o[e].srowzones && o[e].srowzones.length > 0) for (n = 0; n < o[e].srowzones.length; n++) a += o[e].srowzones[n][0].offsetHeight;
      return {
        cur: i = i < a ? a : i,
        last: t
      };
    },
    getGridOffset: function getGridOffset(e, i, t, a) {
      var r = "grid" === t ? o[e].canv.width : "carousel" !== o[e].sliderType || a ? o[e].canv.width : o[e].carousel.slide_width,
        s = o[e].useFullScreenHeight ? o[e].module.height : "grid" === t ? o[e].content.height : "carousel" !== o[e].sliderType || a ? o[e].module.height : o[e].canv.height,
        n = "slide" === t ? 0 : Math.max(0, "fullscreen" == o[e].sliderLayout ? o[e].module.height / 2 - o.iHE(e) * (o[e].keepBPHeight ? 1 : o[e].CM.h) / 2 : o[e].autoHeight || null != o[e].minHeight && o[e].minHeight > 0 || o[e].keepBPHeight ? o[e].canv.height / 2 - o.iHE(e) * o[e].CM.h / 2 : 0),
        d = "slide" === t ? 0 : Math.max(0, "carousel" === o[e].sliderType ? 0 : o[e].canv.width / 2 - o.iWA(e, i) * o[e].CM.w / 2);
      return "slide" !== t && "carousel" === o[e].sliderType && a && void 0 !== o[e].carousel && void 0 !== o[e].carousel.horizontal_align && (d = Math.max(0, "center" === o[e].carousel.horizontal_align ? 0 + (o[e].module.width - o.iWA(e, "static") * o[e].CM.w) / 2 : "right" === o[e].carousel.horizontal_align ? o[e].module.width - o[e].gridwidth[o[e].level] * o[e].CM.w : d)), [r, s, d, n];
    },
    initLayer: function initLayer(e) {
      var i,
        t,
        a,
        r = e.id,
        s = e.skey;
      for (var n in o[r].layers[e.skey]) if (o[r].layers[e.skey].hasOwnProperty(n)) {
        var d = o[r].layers[e.skey][n],
          l = jQuery(d),
          c = o.gA(d, "initialised"),
          p = c ? o[r]._L[d.id] : l.data();
        if ("individual" === e.skey && (p.slideKey = void 0 === p.slideKey ? o.gA(l.closest("rs-slide")[0], "key") : p.slideKey, p.slideIndex = void 0 === p.slideIndex ? o.getSlideIndex(r, p.slideKey) : p.slideIndex, e.slideIndex = p.slideIndex, s = p.slideKey), void 0 === c) {
          if (o.revCheckIDS(r, d), o[r]._L[d.id] = p, p.ford = void 0 === p.ford ? "frame_0;frame_1;frame_999" : p.ford, p.ford = ";" == p.ford[p.ford.length - 1] ? p.ford.substring(0, p.ford.length - 1) : p.ford, p.ford = p.ford.split(";"), void 0 !== p.clip) for (i in p.clipPath = {
            use: !1,
            origin: "l",
            type: "rectangle"
          }, p.clip = p.clip.split(";"), p.clip) p.clip.hasOwnProperty(i) && ("u" == (t = p.clip[i].split(":"))[0] && (p.clipPath.use = "true" == t[1]), "o" == t[0] && (p.clipPath.origin = t[1]), "t" == t[0] && (p.clipPath.type = t[1]));
          if (p.frames = k(p, r), p.caches = {}, p.OBJUPD = {}, p.c = l, p.p = o[r]._Lshortcuts[d.id].p, p.lp = o[r]._Lshortcuts[d.id].lp, p.m = o[r]._Lshortcuts[d.id].m, p.triggercache = void 0 === p.triggercache ? "reset" : p.triggercache, p.rsp_bd = void 0 === p.rsp_bd ? "column" === p.type || "row" === p.type ? "off" : "on" : p.rsp_bd, p.rsp_o = void 0 === p.rsp_o ? "on" : p.rsp_o, p.basealign = void 0 === p.basealign ? "grid" : p.basealign, p.group = "group" !== p.type && null !== o.closestNode(l[0], "RS-GROUP-WRAP") ? "group" : "column" !== p.type && null !== o.closestNode(l[0], "RS-COLUMN") ? "column" : "row" !== p.type && null !== o.closestNode(l[0], "RS-ROW") ? "row" : void 0, p._lig = "group" === p.group ? jQuery(o.closestNode(l[0], "RS-GROUP")) : "column" === p.group ? jQuery(o.closestNode(l[0], "RS-COLUMN")) : "row" === p.group ? jQuery(o.closestNode(l[0], "RS-ROW")) : void 0, p._ligid = void 0 !== p._lig ? p._lig[0].id : void 0, p._column = "RS-COLUMN" === l[0].tagName ? jQuery(o.closestNode(l[0], "RS-COLUMN-WRAP")) : "none", p._row = "RS-COLUMN" === l[0].tagName && jQuery(o.closestNode(l[0], "RS-ROW")), p._ingroup = "group" === p.group, p._incolumn = "column" === p.group, p._inrow = "row" === p.group, p.fsom = "true" == p.fsom || 1 == p.fsom, (p._ingroup || p._incolumn) && p._lig[0].className.indexOf("rs-sba") >= 0 && (!1 !== p.animationonscroll || void 0 === p.frames.loop) && !0 !== p.animOnScrollForceDisable && (p.animationonscroll = !0, l[0].className += " rs-sba", o[r].sbas[s][d.id] = l[0]), p.animOnScrollRepeats = 0, p._isgroup = "RS-GROUP" === l[0].tagName, p.type = p.type || "none", "row" === p.type && (void 0 === p.cbreak && (p.cbreak = 2), void 0 === p.zone && (p.zone = o.closestNode(l[0], "RS-ZONE"), p.zone = null !== p.zone && void 0 !== p.zone ? p.zone.className : "")), p.esginside = jQuery(l[0].getElementsByClassName("esg-grid")[0]), p._isnotext = -1 !== jQuery.inArray(p.type, ["video", "image", "audio", "shape", "row", "group"]), p._mediatag = "html5" == p.audio ? "audio" : "video", p.img = l.find("img"), p.deepiframe = o.getByTag(l[0], "iframe"), p.deepmedia = o.getByTag(l[0], p._mediatag), p.layertype = "image" === p.type ? "image" : l[0].className.indexOf("rs-layer-video") >= 0 || l[0].className.indexOf("rs-layer-audio") >= 0 || p.deepiframe.length > 0 && (p.deepiframe[0].src.toLowerCase().indexOf("youtube") > 0 || p.deepiframe[0].src.toLowerCase().indexOf("vimeo") > 0) || p.deepmedia.length > 0 ? "video" : "html", p.deepiframe.length > 0 && o.sA(p.deepiframe[0], "layertype", p.layertype), "column" === p.type && (p.cbg = jQuery(o.getByTag(p.p[0], "RS-COLUMN-BG")[0]), p.cbgmask = jQuery(o.getByTag(p.p[0], "RS-CBG-MASK-WRAP")[0])), p._slidelink = l[0].className.indexOf("slidelink") >= 0, p._isstatic = l[0].className.indexOf("rs-layer-static") >= 0, p.slidekey = p._isstatic ? "staticlayers" : s, p._togglelisteners = l[0].getElementsByClassName("rs-toggled-content").length > 0, "text" === p.type && (p.c[0].innerHTML = p.c[0].innerHTML.replace("{{total_slide_count}}", o[r].realslideamount), p.c[0].innerHTML.indexOf("{{current_slide_index}}") >= 0)) if (p._isstatic) p.metas = p.metas || {}, p.metas.csi = {}, p.c[0].innerHTML = p.c[0].innerHTML.replace("{{current_slide_index}}", "<cusli>" + o[r].realslideamount + "</cusli>"), p.metas.csi.c = p.c[0].getElementsByTagName("CUSLI")[0];else {
            var g = parseInt(e.slideIndex) + 1;
            p.c[0].innerHTML = p.c[0].innerHTML.replace("{{current_slide_index}}", (g < 10 && o[r].realslideamount > 9 ? "0" : "") + g);
          }
          if (p.bgcol = void 0 === p.bgcol ? l[0].style.background.indexOf("gradient") >= 0 ? l[0].style.background : l[0].style.backgroundColor : p.bgcol, p.bgcol = "" === p.bgcol ? "rgba(0, 0, 0, 0)" : p.bgcol, p.bgcol = 0 === p.bgcol.indexOf("rgba(0, 0, 0, 0)") && p.bgcol.length > 18 ? p.bgcol.replace("rgba(0, 0, 0, 0)", "") : p.bgcol, p.zindex = void 0 === p.zindex ? l[0].style.zIndex : p.zindex, p._isgroup && (p.frames.frame_1.timeline.waitoncall && (p.childrenAtStartNotVisible = !0), p.pVisRequest = 0), p._togglelisteners && l.on("click", function () {
            o.swaptoggleState([this.id]);
          }), void 0 !== p.border) for (i in p.border = p.border.split(";"), p.bordercolor = "transparent", p.border) if (p.border.hasOwnProperty(i)) switch ((t = p.border[i].split(":"))[0]) {
            case "boc":
              p.bordercolor = t[1];
              break;
            case "bow":
              p.borderwidth = o.revToResp(t[1], 4, 0);
              break;
            case "bos":
              p.borderstyle = o.revToResp(t[1], 4, 0);
              break;
            case "bor":
              p.borderradius = o.revToResp(t[1], 4, 0);
          }
          if ("svg" === p.type && (p.svg = l.find("svg"), p.svgI = f(p.svgi, r), p.svgPath = p.svg.find(p.svgI.svgAll ? "path, circle, ellipse, line, polygon, polyline, rect" : "path"), p.svgH = void 0 !== p.svgi && -1 === p.svgi.indexOf("oc:t") ? f(p.svgh, r) : {}), void 0 !== p.btrans) {
            var u = p.btrans;
            for (i in p.btrans = {
              rX: 0,
              rY: 0,
              rZ: 0,
              o: 1
            }, u = u.split(";")) if (u.hasOwnProperty(i)) switch ((t = u[i].split(":"))[0]) {
              case "rX":
                p.btrans.rX = t[1];
                break;
              case "rY":
                p.btrans.rY = t[1];
                break;
              case "rZ":
                p.btrans.rZ = t[1];
                break;
              case "o":
                p.btrans.o = t[1];
            }
          }
          if (void 0 !== p.tsh) for (i in p.tshadow = {
            c: "rgba(0,0,0,0.25)",
            v: 0,
            h: 0,
            b: 0
          }, p.tsh = p.tsh.split(";"), p.tsh) if (p.tsh.hasOwnProperty(i)) switch ((t = p.tsh[i].split(":"))[0]) {
            case "c":
              p.tshadow.c = t[1];
              break;
            case "h":
              p.tshadow.h = t[1];
              break;
            case "v":
              p.tshadow.v = t[1];
              break;
            case "b":
              p.tshadow.b = t[1];
          }
          if (void 0 !== p.tst) for (i in p.tstroke = {
            c: "rgba(0,0,0,0.25)",
            w: 1
          }, p.tst = p.tst.split(";"), p.tst) if (p.tst.hasOwnProperty(i)) switch ((t = p.tst[i].split(":"))[0]) {
            case "c":
              p.tstroke.c = t[1];
              break;
            case "w":
              p.tstroke.w = t[1];
          }
          if (void 0 !== p.bsh) for (i in p.bshadow = {
            e: "c",
            c: "rgba(0,0,0,0.25)",
            v: 0,
            h: 0,
            b: 0,
            s: 0
          }, p.bsh = p.bsh.split(";"), p.bsh) if (p.bsh.hasOwnProperty(i)) switch ((t = p.bsh[i].split(":"))[0]) {
            case "c":
              p.bshadow.c = t[1];
              break;
            case "h":
              p.bshadow.h = t[1];
              break;
            case "v":
              p.bshadow.v = t[1];
              break;
            case "b":
              p.bshadow.b = t[1];
              break;
            case "s":
              p.bshadow.s = t[1];
              break;
            case "e":
              p.bshadow.e = t[1];
          }
          if (void 0 !== p.dim) for (i in p.dim = p.dim.split(";"), p.dim) if (p.dim.hasOwnProperty(i)) switch ((t = p.dim[i].split(":"))[0]) {
            case "w":
              p.width = t[1];
              break;
            case "h":
              p.height = t[1];
              break;
            case "maxw":
              p.maxwidth = t[1];
              break;
            case "maxh":
              p.maxheight = t[1];
              break;
            case "minw":
              p.minwidth = t[1];
              break;
            case "minh":
              p.minheight = t[1];
          }
          if (void 0 !== p.xy && "row" !== p.type && "column" !== p.type) for (i in p.xy = p.xy.split(";"), p.xy) if (p.xy.hasOwnProperty(i)) switch ((t = p.xy[i].split(":"))[0]) {
            case "x":
              p.x = t[1].replace("px", "");
              break;
            case "y":
              p.y = t[1].replace("px", "");
              break;
            case "xo":
              p.hoffset = t[1].replace("px", "");
              break;
            case "yo":
              p.voffset = t[1].replace("px", "");
          }
          if (!p._isnotext && void 0 !== p.text) for (i in p.text = p.text.split(";"), p.text) if (p.text.hasOwnProperty(i)) switch ((t = p.text[i].split(":"))[0]) {
            case "w":
              p.whitespace = t[1];
              break;
            case "td":
              p.textDecoration = t[1];
              break;
            case "c":
              p.clear = t[1];
              break;
            case "f":
              p.float = t[1];
              break;
            case "s":
              p.fontsize = t[1];
              break;
            case "l":
              p.lineheight = t[1];
              break;
            case "ls":
              p.letterspacing = t[1];
              break;
            case "fw":
              p.fontweight = t[1];
              break;
            case "a":
              p.textalign = t[1];
          }
          if ("column" === p.type && void 0 !== p.textDecoration && delete p.textDecoration, void 0 !== p.flcr) for (i in p.flcr = p.flcr.split(";"), p.flcr) if (p.flcr.hasOwnProperty(i)) switch ((t = p.flcr[i].split(":"))[0]) {
            case "c":
              p.clear = t[1];
              break;
            case "f":
              p.float = t[1];
          }
          if (void 0 !== p.padding) for (i in p.padding = p.padding.split(";"), p.padding) if (p.padding.hasOwnProperty(i)) switch ((t = p.padding[i].split(":"))[0]) {
            case "t":
              p.paddingtop = t[1];
              break;
            case "b":
              p.paddingbottom = t[1];
              break;
            case "l":
              p.paddingleft = t[1];
              break;
            case "r":
              p.paddingright = t[1];
          }
          if (void 0 !== p.margin) for (i in p.margin = p.margin.split(";"), p.margin) if (p.margin.hasOwnProperty(i)) switch ((t = p.margin[i].split(":"))[0]) {
            case "t":
              p.margintop = t[1];
              break;
            case "b":
              p.marginbottom = t[1];
              break;
            case "l":
              p.marginleft = t[1];
              break;
            case "r":
              p.marginright = t[1];
          }
          if (void 0 !== p.spike && (p.spike = z(p.spike)), void 0 !== p.corners) for (i in a = p.corners.split(";"), p.corners = {}, a) a.hasOwnProperty(i) && a[i].length > 0 && (p.corners[a[i]] = jQuery("<" + a[i] + "></" + a[i] + ">"), p.c.append(p.corners[a[i]]));
          p.textalign = y(p.textalign), p.vbility = o.revToResp(p.vbility, o[r].rle, !0), p.hoffset = o.revToResp(p.hoffset, o[r].rle, 0), p.voffset = o.revToResp(p.voffset, o[r].rle, 0), p.x = o.revToResp(p.x, o[r].rle, "l"), p.y = o.revToResp(p.y, o[r].rle, "t"), C(l, 0, r), o.sA(d, "initialised", !0), o[r].c.trigger("layerinitialised", {
            layer: l[0].id,
            slider: r
          });
        }
        var h = p.x[o[r].level],
          m = p.y[o[r].level],
          v = o.getGridOffset(r, e.slideIndex, p.basealign, p._isstatic),
          w = v[0],
          b = v[1],
          _ = v[2],
          S = v[3];
        if (p.slideIndex = e.slideIndex, "updateposition" !== e.mode) {
          if (0 == p.vbility[o[r].levelForced] || "f" == p.vbility[o[r].levelForced] || w < o[r].hideLayerAtLimit && "on" == p.layeronlimit || w < o[r].hideAllLayerAtLimit ? (!0 !== p.layerIsHidden && p.p[0].classList.add("rs-layer-hidden"), p.layerIsHidden = !0) : (p.layerIsHidden && p.p[0].classList.remove("rs-layer-hidden"), p.layerIsHidden = !1), p.poster = null == p.poster && void 0 !== p.thumbimage ? p.thumbimage : p.poster, "image" === p.layertype) {
            if (p.imgOBJ = {}, "cover-proportional" === p.img.data("c")) {
              o.sA(p.img[0], "owidth", o.gA(p.img[0], "owidth", p.img[0].width)), o.sA(p.img[0], "oheight", o.gA(p.img[0], "oheight", p.img[0].height));
              var x = o.gA(p.img[0], "owidth") / o.gA(p.img[0], "oheight"),
                L = w / b;
              p.imgOBJ = x > L && x <= 1 || x < L && x > 1 ? {
                width: "100%",
                height: "auto",
                left: "c" === h || "center" === h ? "50%" : "left" === h || "l" === h ? "0" : "auto",
                right: "r" === h || "right" === h ? "0" : "auto",
                top: "c" === m || "center" === m ? "50%" : "top" === m || "t" === m ? "0" : "auto",
                bottom: "b" === m || "bottom" === m ? "0" : "auto",
                x: "c" === h || "center" === h ? "-50%" : "0",
                y: "c" === m || "center" === h ? "-50%" : "0"
              } : {
                height: "100%",
                width: "auto",
                left: "c" === h || "center" === h ? "50%" : "left" === h || "l" === h ? "0" : "auto",
                right: "r" === h || "right" === h ? "0" : "auto",
                top: "c" === m || "center" === m ? "50%" : "top" === m || "t" === m ? "0" : "auto",
                bottom: "b" === m || "bottom" === m ? "0" : "auto",
                x: "c" === h || "center" === h ? "-50%" : "0",
                y: "c" === m || "center" === h ? "-50%" : "0"
              };
            } else void 0 === p.group && "auto" === p.width[o[r].level] && "auto" === p.height[o[r].level] && (p.width[o[r].level] = o.gA(p.img[0], "owidth", p.img[0].width), p.height[o[r].level] = o.gA(p.img[0], "owidth", p.img[0].height)), p.imgOBJ = {
              width: "auto" !== p.width[o[r].level] || isNaN(p.width[o[r].level]) && p.width[o[r].level].indexOf("%") >= 0 ? "100%" : "auto",
              height: "auto" !== p.height[o[r].level] || isNaN(p.height[o[r].level]) && p.height[o[r].level].indexOf("%") >= 0 ? "100%" : "auto"
            };
          } else if ("video" === p.layertype) {
            o.manageVideoLayer(l, r, s), "rebuild" !== e.mode && o.resetVideo(l, r, e.mode), null != p.aspectratio && p.aspectratio.split(":").length > 1 && 1 == p.bgvideo && o.prepareCoveredVideo(r, l), p.media = void 0 === p.media ? p.deepiframe.length > 0 ? jQuery(p.deepiframe[0]) : jQuery(p.deepmedia[0]) : p.media, p.html5vid = void 0 === p.html5vid ? !(p.deepiframe.length > 0) : p.html5vid, p.mediaOBJ = {
              display: "block"
            };
            var R = p.width[o[r].level],
              O = p.height[o[r].level];
            if (R = "auto" === R ? R : !o.isNumeric(R) && R.indexOf("%") > 0 ? p._incolumn || p._ingroup ? "100%" : "grid" === p.basealign ? o.iWA(r, e.slideIndex) * o[r].CM.w : w : "off" !== p.rsp_bd ? parseFloat(R) * o[r].CM.w + "px" : parseFloat(R) + "px", O = "auto" === O ? O : !o.isNumeric(O) && O.indexOf("%") > 0 ? "grid" === p.basealign ? o.iHE(r) * o[r].CM.w : b : "off" !== p.rsp_bd ? parseFloat(O) * o[r].CM.h + "px" : parseFloat(O) + "px", p.vd = void 0 === p.vd ? o[r].videos[l[0].id].ratio.split(":").length > 1 ? o[r].videos[l[0].id].ratio.split(":")[0] / o[r].videos[l[0].id].ratio.split(":")[1] : 1 : p.vd, !p._incolumn || "100%" !== R && "auto" !== O || void 0 === p.ytid) -1 == l[0].className.indexOf("rs-fsv") ? (O = "auto" === O && void 0 !== p.vd && "auto" !== R ? "100%" === R ? l.width() / p.vd : R / p.vd : O, p.vidOBJ = {
              width: R,
              height: O
            }) : ("grid" !== p.basealign && (_ = 0, S = 0), p.x = o.revToResp(0, o[r].rle, 0), p.y = o.revToResp(0, o[r].rle, 0), p.vidOBJ = {
              width: R,
              height: o[r].autoHeight ? o[r].canv.height : O
            }), 0 != p.html5vid && l.hasClass("rs-fsv") || (p.mediaOBJ = {
              width: R,
              height: O,
              display: "block"
            }), p._ingroup && null !== p.vidOBJ.width && void 0 !== p.vidOBJ.width && !o.isNumeric(p.vidOBJ.width) && p.vidOBJ.width.indexOf("%") > 0 && (p.OBJUPD.lppmOBJ = {
              minWidth: R
            });else {
              var I = l.width(),
                M = "auto" === O ? I / p.vd : O;
              p.vidOBJ = {
                width: "auto",
                height: M
              }, p.heightSetByVideo = !0;
            }
          }
          p._slidelink || o[r].caches.calcResponsiveLayersList.push({
            a: l,
            b: r,
            c: 0,
            d: p.rsp_bd,
            e: e.slideIndex
          }), "on" === p.rsp_ch && "row" !== p.type && "column" !== p.type && "group" !== p.type && "image" !== p.type && "video" !== p.type && "shape" !== p.type && l.find("*").each(function () {
            var i = jQuery(this);
            "true" !== o.gA(this, "stylerecorder") && !0 !== o.gA(this, "stylerecorder") && C(i, "rekursive", r), o[r].caches.calcResponsiveLayersList.push({
              a: i,
              b: r,
              c: "rekursive",
              d: p.rsp_bd,
              e: e.slideIndex,
              RSL: l
            });
          });
        }
        if ("preset" !== e.mode) {
          if (p.oldeow = p.eow, p.oldeoh = p.eoh, p.eow = l.outerWidth(!0), p.eoh = l.outerHeight(!0), void 0 !== p.metas && void 0 !== p.metas.csi && p.metas.csi.change !== o[r].focusedSlideIndex) {
            p.metas.csi.change = o[r].focusedSlideIndex;
            g = parseInt(p.metas.csi.change) + 1;
            p.metas.csi.c.innerHTML = (o[r].realslideamount > 9 && g < 10 ? "0" : "") + g;
          }
          if (p.imgInFirefox = "image" == p.type && "auto" == p.width[o[r].level] && "100%" == p.height[o[r].level] && o.isFirefox(r), p.imgInFirefox) {
            var T = p.img.width();
            p.eow = 0 !== T ? T : p.eow;
          }
          if (p.eow <= 0 && void 0 !== p.lastknownwidth && (p.eow = p.lastknownwidth), p.eoh <= 0 && void 0 !== p.lastknownheight && (p.eoh = p.lastknownheight), void 0 !== p.corners && ("text" === p.type || "button" === p.type || "shape" === p.type)) {
            for (a in p.corners) if (p.corners.hasOwnProperty(a)) {
              p.corners[a].css("borderWidth", p.eoh + "px");
              var A = "rs-fcrt" === a || "rs-fcr" === a;
              p.corners[a].css("border" + (A ? "Right" : "Left"), "0px solid transparent"), p.corners[a].css("border" + ("rs-fcrt" == a || "rs-bcr" == a ? "Bottom" : "Top") + "Color", p.bgcol);
            }
            p.eow = l.outerWidth(!0);
          }
          0 == p.eow && 0 == p.eoh && (p.eow = "grid" === p.basealign ? o[r].content.width : o[r].module.width, p.eoh = "grid" === p.basealign ? o[r].content.height : o[r].module.height), p.basealign = o[r].justifyCarousel ? "grid" : p.basealign;
          var D = "on" === p.rsp_o ? parseInt(p.voffset[o[r].level], 0) * o[r].CM.w : parseInt(p.voffset[o[r].level], 0),
            P = "on" === p.rsp_o ? parseInt(p.hoffset[o[r].level], 0) * o[r].CM.h : parseInt(p.hoffset[o[r].level], 0),
            B = "grid" === p.basealign ? o.iWA(r, e.slideIndex) * o[r].CM.w : w,
            G = "grid" === p.basealign ? o.iHE(r) * (o[r].keepBPHeight || o[r].currentRowsHeight > o[r].gridheight[o[r].level] ? 1 : o[r].CM.h) : b;
          (1 == o[r].gridEQModule || void 0 !== p._lig && "row" !== p.type && "column" !== p.type && "group" !== p.type) && (B = void 0 !== p._lig ? p._lig.width() : o[r].module.width, G = void 0 !== p._lig ? p._lig.height() : o[r].module.height, _ = 0, S = 0), "video" === p.type && null != p.vidOBJ && (p.vidOBJ.height >= 0 && 0 === p.eoh && (p.eoh = p.vidOBJ.height), p.vidOBJ.width >= 0 && 0 === p.eow && (p.eow = p.vidOBJ.width)), h = "c" === h || "m" === h || "center" === h || "middle" === h ? B / 2 - p.eow / 2 + P : "l" === h || "left" === h ? P : "r" === h || "right" === h ? B - p.eow - P : "off" !== p.rsp_o ? h * o[r].CM.w : h, m = "m" === m || "c" === m || "center" === m || "middle" === m ? G / 2 - p.eoh / 2 + D : "t" === m || "top" == m ? D : "b" === m || "bottom" == m ? G - p.eoh - D : "off" !== p.rsp_o ? m * o[r].CM.w : m, h = p._slidelink ? 0 : o[r].rtl && -1 == ("" + p.width[o[r].level]).indexOf("%") ? parseInt(h) + p.eow : h, p.calcx = parseInt(h, 0) + _, p.calcy = parseInt(m, 0) + S, "row" !== p.type && "column" !== p.type ? p.OBJUPD.POBJ = {
            zIndex: p.zindex,
            top: p.calcy,
            left: p.calcx,
            overwrite: "auto"
          } : "row" !== p.type ? p.OBJUPD.POBJ = {
            zIndex: p.zindex,
            width: p.columnwidth,
            top: 0,
            left: 0,
            overwrite: "auto"
          } : "row" === p.type && (p.OBJUPD.POBJ = {
            zIndex: p.zindex,
            width: "grid" === p.basealign ? B + "px" : "100%",
            top: 0,
            left: o[r].rtl ? -1 * _ : _,
            overwrite: "auto"
          }, p.cbreak <= o[r].level ? -1 === l[0].className.indexOf("rev_break_columns") && l[0].classList.add("rev_break_columns") : l[0].className.indexOf("rev_break_columns") > 0 && l[0].classList.remove("rev_break_columns"), p.rowcalcx = p.OBJUPD.POBJ.left, p.pow = p.p.outerWidth(!0)), void 0 !== p.blendmode && (p.OBJUPD.POBJ.mixBlendMode = p.blendmode), (void 0 !== p.frames.loop || p.imgInFirefox) && (p.OBJUPD.LPOBJ = {
            width: p.eow,
            height: p.eoh
          }), p._ingroup && (void 0 !== p._groupw && !o.isNumeric(p._groupw) && p._groupw.indexOf("%") > 0 && (p.OBJUPD.lppmOBJ.minWidth = p._groupw), void 0 !== p._grouph && !o.isNumeric(p._grouph) && p._grouph.indexOf("%") > 0 && (p.OBJUPD.lppmOBJ.minHeight = p._grouph)), "updateposition" === e.mode && (p.caches.POBJ_LEFT === p.OBJUPD.POBJ.left && p.caches.POBJ_TOP === p.OBJUPD.POBJ.top || (tpGS.gsap.set(p.p, p.OBJUPD.POBJ), p.caches.POBJ_LEFT = p.OBJUPD.POBJ.left, p.caches.POBJ_TOP = p.OBJUPD.POBJ.top)), e.animcompleted && o.animcompleted(l, r);
        }
      }
    },
    hoverReverseDone: function hoverReverseDone(e) {
      o[e.id]._L[e.L[0].id].textDecoration && tpGS.gsap.set(o[e.id]._L[e.L[0].id].c, {
        textDecoration: o[e.id]._L[e.L[0].id].textDecoration
      });
    },
    animcompleted: function animcompleted(e, i, t) {
      if (void 0 !== o[i].videos) {
        var a = o[i].videos[e[0].id];
        null != a && null != a.type && "none" != a.type && (1 == a.aplay || "true" == a.aplay || "on" == a.aplay || "1sttime" == a.aplay ? (("static" === a.slideid || "carousel" !== o[i].sliderType || e.closest("rs-slide").index() == o[i].carousel.focused || e.closest("rs-slide").index() == o[i].activeRSSlide && o[i].carousel.oldfocused == o[i].carousel.focused || t) && o.playVideo(e, i), o.toggleState(e.data("videotoggledby")), (a.aplay1 || "1sttime" == a.aplay) && (a.aplay1 = !1, a.aplay = !1)) : ("no1sttime" == a.aplay && (a.aplay = !0), o.unToggleState(e.data("videotoggledby"))));
      }
    },
    handleStaticLayers: function handleStaticLayers(e, i) {
      var t = 0,
        a = o[i].realslideamount + 1;
      if (void 0 !== o.gA(e[0], "onslides")) {
        var r = o.gA(e[0], "onslides").split(";");
        for (var s in r) if (r.hasOwnProperty(s)) {
          var n = r[s].split(":");
          "s" === n[0] && (t = parseInt(n[1], 0)), "e" === n[0] && (a = parseInt(n[1], 0));
        }
      }
      t = Math.max(0, t), a = Math.min(o[i].realslideamount, a < 0 ? o[i].realslideamount : a), a = 1 !== t && 0 !== t || a !== o[i].realslideamount ? a : o[i].realslideamount + 1, e.data("startslide", t), e.data("endslide", a), o.sA(e[0], "startslide", t), o.sA(e[0], "endslide", a);
    },
    updateLayersOnFullStage: function updateLayersOnFullStage(e) {
      if (o[e].caches.calcResponsiveLayersList.length > 0) {
        !0 !== o[e].slideHasIframe && !0 !== o[e].fullScreenMode && ("carousel" === o[e].sliderType ? o[e].carousel.wrap.detach() : o[e].canvas.detach());
        for (var i = 0; i < o[e].caches.calcResponsiveLayersList.length; i++) void 0 !== o[e].caches.calcResponsiveLayersList[i] && B(o[e].caches.calcResponsiveLayersList[i]);
        !0 !== o[e].slideHasIframe && !0 !== o[e].fullScreenMode && ("carousel" === o[e].sliderType ? o[e].c[0].appendChild(o[e].carousel.wrap[0]) : o[e].c[0].appendChild(o[e].canvas[0]));
      }
    },
    animateTheLayers: function animateTheLayers(e) {
      if (void 0 === e.slide) return !1;
      var i = e.id;
      if (void 0 === o[i].slides[e.slide] && "individual" !== e.slide) return !1;
      if ("carousel" === o[i].sliderType) {
        if ("start" === e.mode && "start" === o[i].lastATLmode) {
          if (e.slide === o[i].lastATLslide && new Date().getTime() - o[i].lastATLtime < 1500) return;
          o[i].lastATLtime = new Date().getTime();
        }
        o[i].lastATLmode = e.mode, o[i].lastATLslide = e.slide;
      }
      var t = "individual" !== e.slide ? o.gA(o[i].slides[e.slide], "key") : "individual",
        a = o[i].pr_processing_key || o[i].pr_active_key || 0;
      o[i].focusedSlideIndex = a, o[i].caches.calcResponsiveLayersList = [], o[i].layers = o[i].layers || {}, "individual" === t ? o[i].layers.individual = void 0 === o[i].layers.individual ? "all" === o[i].carousel.showLayersAllTime ? M(jQuery(o[i].c), "rs-layer", "rs-layer-static") : M(jQuery(o[i].c), "rs-on-car") : o[i].layers.individual : (o[i].layers[t] = void 0 === o[i].layers[t] ? "all" === o[i].carousel.showLayersAllTime ? [] : M(jQuery(o[i].slides[e.slide]), "rs-layer", "carousel" === o[i].sliderType ? "rs-on-car" : void 0) : o[i].layers[t], o[i].layers.static = void 0 === o[i].layers.static ? M(jQuery(o[i].c.find("rs-static-layers")), "rs-layer", "rs-on-car") : o[i].layers.static, o[i].sbas[t] = void 0 === o[i].sbas[t] ? M(jQuery(o[i].slides[e.slide]), "rs-sba") : o[i].sbas[t]);
      var r = "rebuild" === e.mode && "carousel" === o[i].sliderType && "individual" === t;
      void 0 !== t && o[i].layers[t] && o.initLayer({
        id: i,
        slideIndex: e.slide,
        skey: t,
        mode: e.mode,
        animcompleted: r
      }), o[i].layers.static && o.initLayer({
        id: i,
        skey: "static",
        slideIndex: "static",
        mode: e.mode,
        animcompleted: r
      }), o.updateLayersOnFullStage(i), "preset" !== e.mode || void 0 !== o[i].slidePresets && void 0 !== o[i].slidePresets[e.slide] || (o[i].slidePresets = void 0 === o[i].slidePresets ? {} : o[i].slidePresets, o[i].slidePresets[e.slide] = !0, o[i].c.trigger("revolution.slideprepared", {
        slide: e.slide,
        key: t
      })), o[i].heightInLayers = o[i].module.height, o[i].widthInLayers = o[i].module.width, o[i].levelInLayers = o[i].level;
      var s = {
        id: i,
        skey: t,
        slide: e.slide,
        key: t,
        mode: e.mode,
        index: a
      };
      window.requestAnimationFrame(function () {
        if (void 0 === o[i].dimensionReCheck[t] ? (o.updateLayerDimensions(s), !0 !== o[i].doubleDimensionCheck ? setTimeout(function () {
          o.updateLayerDimensions(s), o.updateRowZones(s);
        }, 150) : o.updateRowZones(s), o[i].doubleDimensionCheck = !0, o[i].dimensionReCheck[t] = !0) : o.updateRowZones(s), void 0 !== t && o[i].layers[t]) for (var a in o[i].layers[t]) o[i].layers[t].hasOwnProperty(a) && o.renderLayerAnimation({
          layer: jQuery(o[i].layers[t][a]),
          id: i,
          mode: e.mode,
          caller: e.caller
        });
        if (o[i].layers.static) for (var a in o[i].layers.static) o[i].layers.static.hasOwnProperty(a) && o.renderLayerAnimation({
          layer: jQuery(o[i].layers.static[a]),
          id: i,
          mode: e.mode,
          caller: e.caller
        });
        null != o[i].mtl && o[i].mtl.resume();
      });
    },
    updateRowZones: function updateRowZones(e) {
      (void 0 !== o[e.id].rowzones && o[e.id].rowzones.length > 0 && e.index >= 0 && o[e.id].rowzones[Math.min(e.index, o[e.id].rowzones.length)] && o[e.id].rowzones[Math.min(e.index, o[e.id].rowzones.length)].length > 0 || void 0 !== o[e.id].srowzones && o[e.id].srowzones.length > 0 || void 0 !== o[e.id].smiddleZones && o[e.id].smiddleZones.length > 0) && (o.updateDims(e.id), o.initLayer({
        id: e.id,
        skey: e.key,
        slideIndex: e.slide,
        mode: "updateposition"
      }), o.initLayer({
        id: e.id,
        skey: "static",
        slideIndex: "static",
        mode: "updateposition"
      }), "start" !== e.mode && "preset" !== e.mode || o.manageNavigation(e.id));
    },
    updateLayerDimensions: function updateLayerDimensions(e) {
      var i = !1;
      o[e.id].caches.calcResponsiveLayersList = [], void 0 === e.key || "individual" != e.key && void 0 === o[e.id].layers[e.key] || !o.checkLayerDimensions({
        id: e.id,
        skey: e.key,
        slideIndex: e.slide
      }) || (i = !0), o.initLayer({
        id: e.id,
        skey: e.key,
        slideIndex: e.slide,
        mode: "updateAndResize"
      }), o[e.id].layers.static && o.checkLayerDimensions({
        id: e.id,
        skey: "static",
        slideIndex: "static"
      }) && (i = !0, o.initLayer({
        id: e.id,
        skey: "static",
        slideIndex: "static",
        mode: "updateAndResize"
      })), i && o.updateLayersOnFullStage(e.id);
    },
    updateAnimatingLayerPositions: function updateAnimatingLayerPositions(e) {
      o.initLayer({
        id: e.id,
        skey: e.key,
        slideIndex: e.slide,
        mode: "updateposition"
      });
    },
    removeTheLayers: function removeTheLayers(e, i, t) {
      var a = o.gA(e[0], "key");
      for (var r in o[i].sloops && o[i].sloops[a] && o[i].sloops[a].tl && o[i].sloops[a].tl.pause(), o[i].layers[a]) o[i].layers[a].hasOwnProperty(r) && o.renderLayerAnimation({
        layer: jQuery(o[i].layers[a][r]),
        frame: "frame_999",
        mode: "continue",
        remove: !0,
        id: i,
        allforce: t
      });
      for (var r in o[i].layers.static) o[i].layers.static.hasOwnProperty(r) && o.renderLayerAnimation({
        layer: jQuery(o[i].layers.static[r]),
        frame: "frame_999",
        mode: "continue",
        remove: !0,
        id: i,
        allforce: t
      });
    },
    renderLayerAnimation: function renderLayerAnimation(e) {
      var t,
        a = e.layer,
        r = e.id,
        u = o[r].level,
        m = o[r]._L[a[0].id],
        v = void 0 !== m.timeline ? m.timeline.time() : void 0,
        f = !1,
        y = !1,
        _ = "none";
      if (("containerResized_2" !== e.caller && "swapSlideProgress_2" !== e.caller || !0 === m.animationRendered) && (m.animationRendered = !0, "preset" !== e.mode || !0 === m.frames.frame_1.timeline.waitoncall || void 0 !== m.scrollBasedOffset)) {
        if ("trigger" == e.mode && (m.triggeredFrame = e.frame), m._isstatic) {
          var x = "carousel" === o[r].sliderType && void 0 !== o[r].carousel.oldfocused ? o[r].carousel.oldfocused : void 0 === o[r].pr_lastshown_key ? 1 : parseInt(o[r].pr_lastshown_key, 0) + 1,
            k = "carousel" === o[r].sliderType ? void 0 === o[r].pr_next_key ? 0 === x ? 1 : x : parseInt(o[r].pr_next_key, 0) + 1 : void 0 === o[r].pr_processing_key ? x : parseInt(o[r].pr_processing_key, 0) + 1,
            L = x >= m.startslide && x <= m.endslide,
            R = k >= m.startslide && k <= m.endslide;
          if (_ = x === m.endslide && "continue" === e.mode || ("continue" === e.mode || x === m.endslide) && "none", !0 === e.allforce || !0 === _) {
            if ("continue" === e.mode && "frame_999" === e.frame && (R || void 0 === m.lastRequestedMainFrame)) return;
          } else {
            if ("preset" === e.mode && (m.elementHovered || !R)) return;
            if ("rebuild" === e.mode && !L && !R) return;
            if ("start" === e.mode && R && "frame_1" === m.lastRequestedMainFrame) return;
            if (("start" === e.mode || "preset" === e.mode) && "frame_999" === m.lastRequestedMainFrame && !0 !== m.leftstage) return;
            if ("continue" === e.mode && "frame_999" === e.frame && (R || void 0 === m.lastRequestedMainFrame)) return;
            if ("start" === e.mode && !R) return;
          }
        } else "start" === e.mode && "keep" !== m.triggercache && (m.triggeredFrame = void 0);
        for (var O in "start" === e.mode && (void 0 !== m.layerLoop && (m.layerLoop.count = 0), e.frame = void 0 === m.triggeredFrame ? 0 : m.triggeredFrame), "continue" === e.mode || "trigger" === e.mode || void 0 === m.timeline || m._isstatic && !0 === m.leftstage || m.timeline.pause(0), "continue" !== e.mode && "trigger" !== e.mode || void 0 === m.timeline || m.timeline.pause(), m.timeline = tpGS.gsap.timeline({
          paused: !0
        }), "text" !== m.type && "button" !== m.type || void 0 !== m.splitText && (void 0 !== m.splitTextFix || "start" !== e.mode && "preset" !== e.mode) || (w({
          layer: a,
          id: r
        }), "start" === e.mode && (m.splitTextFix = !0)), m.ford) if (m.ford.hasOwnProperty(O)) {
          var I = m.ford[O],
            M = !1;
          if ("frame_0" !== I && "frame_hover" !== I && "loop" !== I) {
            if ("frame_999" === I && !m.frames[I].timeline.waitoncall && m.frames[I].timeline.start >= o[r].duration && !0 !== e.remove && (m.frames[I].timeline.waitoncall = !0), "start" === e.mode && "keep" !== m.triggercache && (m.frames[I].timeline.callstate = m.frames[I].timeline.waitoncall ? "waiting" : ""), "trigger" === e.mode && m.frames[I].timeline.waitoncall && (I === e.frame ? (m.frames[I].timeline.triggered = !0, m.frames[I].timeline.callstate = "called") : m.frames[I].timeline.triggered = !1), "rebuild" === e.mode || m.frames[I].timeline.triggered || (m.frames[I].timeline.callstate = m.frames[I].timeline.waitoncall ? "waiting" : ""), !1 !== e.fastforward) {
              if (("continue" === e.mode || "trigger" === e.mode) && !1 === y && I !== e.frame) continue;
              if (("rebuild" === e.mode || "preset" === e.mode) && !1 === y && void 0 !== m.triggeredFrame && I !== m.triggeredFrame) continue;
              (I === e.frame || "rebuild" === e.mode && I === m.triggeredFrame) && (y = !0);
            } else I === e.frame && (y = !0);
            if (I !== e.frame && m.frames[I].timeline.waitoncall && "called" !== m.frames[I].timeline.callstate && (f = !0), I !== e.frame && y && (f = !0 === f && m.frames[I].timeline.waitoncall ? "skiprest" : !0 !== f && f), void 0 === m.hideonfirststart && "frame_1" === I && m.frames[I].timeline.waitoncall && (m.hideonfirststart = !0), f && "waiting" === m.frames[I].timeline.callstate && "preset" === e.mode && 1 != m.firstTimeRendered) {
              if (m._isstatic && void 0 === m.currentframe) continue;
              M = !0, m.firstTimeRendered = !0;
            } else if ("skiprest" === f || "called" !== m.frames[I].timeline.callstate && f && e.toframe !== I) continue;
            if ("frame_999" !== I || !1 !== _ || "continue" !== e.mode && "start" !== e.mode && "rebuild" !== e.mode) {
              m.fff = "frame_1" === I && ("trigger" !== e.mode || "frame_999" === m.currentframe || "frame_0" === m.currentframe || void 0 === m.currentframe), "trigger" === e.mode && "frame_1" === e.frame && !1 === m.leftstage && (m.fff = !1), M || (m.frames[I].timeline.callstate = "called", m.currentframe = I);
              var T = m.frames[I],
                C = m.fff ? m.frames.frame_0 : void 0,
                A = tpGS.gsap.timeline(),
                D = tpGS.gsap.timeline(),
                P = m.c,
                B = void 0 !== T.sfx && b(T.sfx.effect, m.m, T.timeline.ease),
                z = T.timeline.speed / 1e3,
                G = 0,
                E = S({
                  id: r,
                  frame: T,
                  layer: a,
                  ease: T.timeline.ease,
                  splitAmount: P.length,
                  target: I,
                  forcefilter: void 0 !== m.frames.frame_hover && void 0 !== m.frames.frame_hover.filter
                }),
                N = m.fff ? S({
                  id: r,
                  frame: C,
                  layer: a,
                  ease: T.timeline.ease,
                  splitAmount: P.length,
                  target: "frame_0"
                }) : void 0,
                F = void 0 !== T.mask ? S({
                  id: r,
                  frame: {
                    transform: {
                      x: T.mask.x,
                      y: T.mask.y
                    }
                  },
                  layer: a,
                  ease: E.ease,
                  target: "mask"
                }) : void 0,
                H = void 0 !== F && m.fff ? S({
                  id: r,
                  frame: {
                    transform: {
                      x: C.mask.x,
                      y: C.mask.y
                    }
                  },
                  layer: a,
                  ease: E.ease,
                  target: "frommask"
                }) : void 0,
                j = E.ease;
              if (E.force3D = !0, "block" === B.type && (B.ft[0].background = T.sfx.fxc, B.ft[0].visibility = "visible", B.ft[1].visibility = "visible", A.add(tpGS.gsap.fromTo(B.bmask_in, z / 2, B.ft[0], B.ft[1], 0)), A.add(tpGS.gsap.fromTo(B.bmask_in, z / 2, B.ft[1], B.t, z / 2)), "frame_0" !== I && "frame_1" !== I || (N.opacity = 0)), void 0 !== T.color ? E.color = T.color : void 0 !== m.color && "npc" !== m.color[u] && (E.color = m.color[u]), void 0 !== C && void 0 !== C.color ? N.color = C.color : void 0 !== C && void 0 !== m.color && "npc" !== m.color[u] && (N.color = m.color[u]), void 0 !== T.bgcolor ? T.bgcolor.indexOf("gradient") >= 0 ? E.background = T.bgcolor : E.backgroundColor = T.bgcolor : !0 === m.bgcolinuse && (m.bgcol.indexOf("gradient") >= 0 ? E.background = m.bgcol : E.backgroundColor = m.bgcol), void 0 !== C && (void 0 !== C.bgcolor ? C.bgcolor.indexOf("gradient") >= 0 ? N.background = C.bgcolor : N.backgroundColor = C.bgcolor : !0 === m.bgcolinuse && (m.bgcol.indexOf("gradient") >= 0 ? N.background = m.bgcol : N.backgroundColor = m.bgcol)), void 0 !== m.splitText && !1 !== m.splitText) for (var W in i) if (void 0 !== T[i[W]] && !m.quickRendering) {
                var V = m.splitText[i[W]],
                  U = S({
                    id: r,
                    frame: T,
                    source: i[W],
                    ease: j,
                    layer: a,
                    splitAmount: V.length,
                    target: I + "_" + i[W]
                  }),
                  X = m.fff ? S({
                    id: r,
                    frame: C,
                    ease: U.ease,
                    source: i[W],
                    layer: a,
                    splitAmount: V.length,
                    target: "frame_0_" + i[W]
                  }) : void 0,
                  Y = m.frames[I].dosplit ? void 0 === T[i[W]].delay ? .05 : T[i[W]].delay / 100 : 0;
                m.color[u] === E.color && "frame_1" === I || (U.color = E.color), void 0 !== N && m.color[u] !== N.color && (X.color = N.color), void 0 !== X && X.color !== E.color && (U.color = E.color);
                var Q = o.clone(U),
                  J = m.fff ? o.clone(X) : void 0,
                  q = T[i[W]].dir;
                delete Q.dir, Q.data = {
                  splitted: !0
                }, Q.stagger = "center" === q || "edge" === q ? l({
                  each: Y,
                  offset: Y / 2,
                  from: q
                }) : {
                  each: Y,
                  from: q
                }, Q.duration = z, void 0 !== J && (void 0 !== J.opacity && (o.ISM || window.isSafari11) && (J.opacity = Math.max(.001, parseFloat(J.opacity))), delete J.dir), m.fff ? A.add(D.fromTo(V, J, Q), 0) : A.add(D.to(V, Q), 0), G = Math.max(G, V.length * Y);
              }
              if (z += G, void 0 === t && (t = "isometric" === o[r].perspectiveType ? 0 : "local" === o[r].perspectiveType ? void 0 !== E.transformPerspective ? E.transformPerspective : m.fff && void 0 !== N.transfromPerspective ? N.transfromPerspective : o[r].perspective : o[r].perspective), m.knowTransformPerspective = t, m.fsom && (void 0 !== E.filter || m.fff && void 0 !== N.filter) ? (F.filter = E.filter, F["-webkit-filter"] = E.filter, delete E.filter, delete E["-webkit-filter"], m.fff && void 0 !== N.filter && ((H = H || {}).filter = N.filter, H["-webkit-filter"] = N.filter, delete N.filter, delete N["-webkit-filter"]), m.forceFsom = !0) : m.forceFsom = !1, m.useMaskAnimation = m.pxundermask || void 0 !== F && (void 0 !== C && "hidden" === C.mask.overflow || "hidden" === T.mask.overflow), m.useMaskAnimation || m.forceFsom) m.useMaskAnimation ? A.add(tpGS.gsap.to(m.m, .001, {
                overflow: "hidden"
              }), 0) : A.add(tpGS.gsap.to(m.m, .001, {
                overflow: "visible"
              }), 0), "column" === m.type && m.useMaskAnimation && A.add(tpGS.gsap.to(m.cbgmask, .001, {
                overflow: "hidden"
              }), 0), m.btrans && (H && (H.rotationX = m.btrans.rX, H.rotationY = m.btrans.rY, H.rotationZ = m.btrans.rZ, H.opacity = m.btrans.o), F.rotationX = m.btrans.rX, F.rotationY = m.btrans.rY, F.rotationZ = m.btrans.rZ, F.opacity = m.btrans.o), m.fff ? A.add(tpGS.gsap.fromTo([m.m, m.cbgmask], z, o.clone(H), o.clone(F)), .001) : A.add(tpGS.gsap.to([m.m, m.cbgmask], z, o.clone(F)), .001);else if (void 0 !== m.btrans) {
                var Z = {
                  x: 0,
                  y: 0,
                  filter: "none",
                  opacity: m.btrans.o,
                  rotationX: m.btrans.rX,
                  rotationY: m.btrans.rY,
                  rotationZ: m.btrans.rZ,
                  overflow: "visible"
                };
                0 === m.btrans.rX && 0 == m.btrans.rY || (m.maskHasPerspective = !0, Z.transformPerspective = t), A.add(tpGS.gsap.to(m.m, .001, Z), 0);
              } else A.add(tpGS.gsap.to(m.m, .001, {
                clearProps: "transform",
                overflow: "visible"
              }), 0);
              E.force3D = "auto", m.fff ? (E.visibility = "visible", void 0 !== m.cbg && A.fromTo(m.cbg, z, N, E, 0), o[r].BUG_safari_clipPath && (N.clipPath || E.clipPath || m.spike) && (N.z && parseInt(N.z, 10) || (N.z = -1e-4), E.z && parseInt(E.z, 10) || (E.z = 0)), void 0 !== m.cbg && "column" === m.type ? A.fromTo(P, z, s(N), s(E), 0) : A.fromTo(P, z, N, E, 0), A.invalidate()) : ("frame_999" !== m.frame && (E.visibility = "visible"), void 0 !== m.cbg && A.to(m.cbg, z, E, 0), !o[r].BUG_safari_clipPath || !E.clipPath && !m.spike || E.z && parseInt(E.z, 10) || (E.z = 0 - .01 * Math.random()), void 0 !== m.cbg && "column" === m.type ? A.to(P, z, s(E), 0) : A.to(P, z, E, 0)), void 0 !== j && "object" != _typeof(j) && "function" != typeof j && j.indexOf("SFXBounce") >= 0 && A.to(P, z, {
                scaleY: .5,
                scaleX: 1.3,
                ease: E.ease + "-squash",
                transformOrigin: "bottom"
              }, 1e-4);
              var K = "trigger" !== e.mode && (!0 !== f && "skiprest" !== f || "rebuild" !== e.mode) || e.frame === I || void 0 === T.timeline.start || !o.isNumeric(T.timeline.start) ? "+=0" === T.timeline.start || void 0 === T.timeline.start ? "+=0.05" : parseInt(T.timeline.start, 0) / 1e3 : "+=" + parseInt(T.timeline.startRelative, 0) / 1e3;
              m.timeline.addLabel(I, K), m.timeline.add(A, K), m.timeline.addLabel(I + "_end", "+=0.01"), A.eventCallback("onStart", c, [{
                id: r,
                frame: I,
                L: a,
                tPE: t
              }]), "true" == m.animationonscroll || 1 == m.animationonscroll ? (A.eventCallback("onUpdate", p, [{
                id: r,
                frame: I,
                L: a
              }]), A.smoothChildTiming = !0) : A.eventCallback("onUpdate", p, [{
                id: r,
                frame: I,
                L: a
              }]), A.eventCallback("onComplete", g, [{
                id: r,
                frame: I,
                L: a,
                tPE: t
              }]);
            }
          }
        }
        if (void 0 !== m.frames.loop) {
          var $ = parseInt(m.frames.loop.timeline.speed, 0) / 1e3,
            ee = parseInt(m.frames.loop.timeline.start) / 1e3 || 0,
            ie = "trigger" !== e.mode && "frame_999" !== e.frame || "frame_999" !== e.frame ? .2 : 0,
            te = ee + ie;
          m.loop = {
            root: tpGS.gsap.timeline({}),
            preset: tpGS.gsap.timeline({}),
            move: tpGS.gsap.timeline({
              repeat: -1,
              yoyo: m.frames.loop.timeline.yoyo_move
            }),
            rotate: tpGS.gsap.timeline({
              repeat: -1,
              yoyo: m.frames.loop.timeline.yoyo_rotate
            }),
            scale: tpGS.gsap.timeline({
              repeat: -1,
              yoyo: m.frames.loop.timeline.yoyo_scale
            }),
            filter: tpGS.gsap.timeline({
              repeat: -1,
              yoyo: m.frames.loop.timeline.yoyo_filter
            })
          };
          var ae = m.frames.loop.frame_0,
            re = m.frames.loop.frame_999,
            oe = "blur(" + parseInt(ae.blur || 0, 0) + "px) grayscale(" + parseInt(ae.grayscale || 0, 0) + "%) brightness(" + parseInt(ae.brightness || 100, 0) + "%)",
            se = "blur(" + (re.blur || 0) + "px) grayscale(" + (re.grayscale || 0) + "%) brightness(" + (re.brightness || 100) + "%)";
          if (m.loop.root.add(m.loop.preset, 0), m.loop.root.add(m.loop.move, ie), m.loop.root.add(m.loop.rotate, ie), m.loop.root.add(m.loop.scale, ie), m.loop.root.add(m.loop.filter, ie), "blur(0px) grayscale(0%) brightness(100%)" === oe && "blur(0px) grayscale(0%) brightness(100%)" === se && (oe = "none", se = "none"), re.originX = ae.originX, re.originY = ae.originY, re.originZ = ae.originZ, void 0 === t && (t = "isometric" === o[r].perspectiveType ? 0 : "local" === o[r].perspectiveType && void 0 !== E ? void 0 !== E.transformPerspective ? E.transformPerspective : m.fff && void 0 !== N.transfromPerspective ? N.transfromPerspective : o[r].perspective : o[r].perspective), m.frames.loop.timeline.curved) {
            var ne = parseInt(m.frames.loop.timeline.radiusAngle, 0) || 0,
              de = [{
                x: (ae.x - ae.xr) * o[r].CM.w,
                y: 0,
                z: (ae.z - ae.zr) * o[r].CM.w
              }, {
                x: 0,
                y: (ae.y + ae.yr) * o[r].CM.w,
                z: 0
              }, {
                x: (re.x + re.xr) * o[r].CM.w,
                y: 0,
                z: (re.z + re.zr) * o[r].CM.w
              }, {
                x: 0,
                y: (re.y - re.yr) * o[r].CM.w,
                z: 0
              }],
              le = {
                type: "thru",
                curviness: m.frames.loop.timeline.curviness,
                path: [],
                autoRotate: m.frames.loop.timeline.autoRotate
              };
            for (var ce in de) de.hasOwnProperty(ce) && (le.path[ce] = de[ne], ne = ++ne == de.length ? 0 : ne);
            ("trigger" !== e.mode && "frame_999" !== e.frame || "frame_999" !== e.frame) && m.loop.preset.fromTo(m.lp, ie, {
              "-webkit-filter": oe,
              filter: oe,
              x: 0,
              y: 0,
              z: 0,
              minWidth: m._incolumn || m._ingroup ? "100%" : void 0 === m.eow ? 0 : m.eow,
              minHeight: m._incolumn || m._ingroup ? "100%" : void 0 === m.eoh ? 0 : m.eoh,
              scaleX: 1,
              scaleY: 1,
              skewX: 0,
              skewY: 0,
              rotationX: 0,
              rotationY: 0,
              rotationZ: 0,
              transformPerspective: t,
              transformOrigin: re.originX + " " + re.originY + " " + re.originZ,
              opacity: 1
            }, d({
              x: le.path[3].x,
              y: le.path[3].y,
              z: le.path[3].z,
              scaleX: ae.scaleX,
              skewX: ae.skewX,
              skewY: ae.skewY,
              scaleY: ae.scaleY,
              rotationX: ae.rotationX,
              rotationY: ae.rotationY,
              rotationZ: ae.rotationZ,
              "-webkit-filter": oe,
              filter: oe,
              ease: "sine.inOut",
              opacity: ae.opacity
            }), 0), n(le) && m.loop.move.to(m.lp, m.frames.loop.timeline.yoyo_move ? $ / 2 : $, {
              motionPath: le,
              ease: m.frames.loop.timeline.ease
            });
          } else ("trigger" !== e.mode && "frame_999" !== e.frame || "frame_999" !== e.frame) && m.loop.preset.fromTo(m.lp, ie, {
            "-webkit-filter": oe,
            filter: oe,
            x: 0,
            y: 0,
            z: 0,
            minWidth: m._incolumn || m._ingroup ? "100%" : void 0 === m.eow ? 0 : m.eow,
            minHeight: m._incolumn || m._ingroup ? "100%" : void 0 === m.eoh ? 0 : m.eoh,
            scaleX: 1,
            scaleY: 1,
            skewX: 0,
            skewY: 0,
            rotationX: 0,
            rotationY: 0,
            rotationZ: 0,
            transformPerspective: t,
            transformOrigin: re.originX + " " + re.originY + " " + re.originZ,
            opacity: 1
          }, d({
            x: ae.x * o[r].CM.w,
            y: ae.y * o[r].CM.w,
            z: ae.z * o[r].CM.w,
            scaleX: ae.scaleX,
            skewX: ae.skewX,
            skewY: ae.skewY,
            scaleY: ae.scaleY,
            rotationX: ae.rotationX,
            rotationY: ae.rotationY,
            rotationZ: ae.rotationZ,
            ease: "sine.out",
            opacity: ae.opacity,
            "-webkit-filter": oe,
            filter: oe
          }), 0), m.loop.move.to(m.lp, m.frames.loop.timeline.yoyo_move ? $ / 2 : $, {
            x: re.x * o[r].CM.w,
            y: re.y * o[r].CM.w,
            z: re.z * o[r].CM.w,
            ease: m.frames.loop.timeline.ease
          });
          m.loop.rotate.to(m.lp, m.frames.loop.timeline.yoyo_rotate ? $ / 2 : $, {
            rotationX: re.rotationX,
            rotationY: re.rotationY,
            rotationZ: re.rotationZ,
            ease: m.frames.loop.timeline.ease
          }), m.loop.scale.to(m.lp, m.frames.loop.timeline.yoyo_scale ? $ / 2 : $, d({
            scaleX: re.scaleX,
            scaleY: re.scaleY,
            skewX: re.skewX,
            skewY: re.skewY,
            ease: m.frames.loop.timeline.ease
          }));
          var pe = {
            opacity: re.opacity || 1,
            ease: m.frames.loop.timeline.ease,
            "-webkit-filter": se,
            filter: se
          };
          m.loop.filter.to(m.lp, m.frames.loop.timeline.yoyo_filter ? $ / 2 : $, pe), m.timeline.add(m.loop.root, te);
        }
        if (void 0 !== m.frames.frame_hover && ("start" === e.mode || void 0 === m.hoverframeadded)) {
          m.hoverframeadded = !0;
          var ge = m.frames.frame_hover.timeline.speed / 1e3;
          ge = 0 === ge ? 1e-5 : ge, m.hoverlistener || (m.hoverlistener = !0, o.document.on("mouseenter mousemove", ("column" === m.type ? "#" + m.cbg[0].id + "," : "") + "#" + m.c[0].id, function (e) {
            if ("mousemove" !== e.type || !0 !== m.ignoremousemove) {
              if (m.animationonscroll || m.readyForHover) {
                if (m.elementHovered = !0, m.hovertimeline || (m.hovertimeline = tpGS.gsap.timeline({
                  paused: !0
                })), 0 == m.hovertimeline.progress() && (void 0 === m.lastHoveredTimeStamp || new Date().getTime() - m.lastHoveredTimeStamp > 150) && (m.ignoremousemove = !0, m.hovertimeline.to([m.m, m.cbgmask], ge, {
                  overflow: m.frames.frame_hover.mask ? "hidden" : "visible"
                }, 0), "column" === m.type && m.hovertimeline.to(m.cbg, ge, o.clone(h(m.frames.frame_hover, m.cbg, {
                  bgCol: m.bgcol,
                  bg: m.styleProps.background
                })), 0), "text" !== m.type && "button" !== m.type || void 0 === m.splitText || !1 === m.splitText || m.hovertimeline.to([m.splitText.lines, m.splitText.words, m.splitText.chars], ge, {
                  color: m.frames.frame_hover.color,
                  ease: m.frames.frame_hover.transform.ease
                }, 0), "column" === m.type ? m.hovertimeline.to(m.c, ge, s(o.clone(h(m.frames.frame_hover, m.c, {
                  bgCol: m.bgcol,
                  bg: m.styleProps.background
                }))), 0) : m.hovertimeline.to(m.c, ge, o.clone(h(m.frames.frame_hover, m.c, {
                  bgCol: m.bgcol,
                  bg: m.styleProps.background
                })), 0), "svg" === m.type)) {
                  m.svgHTemp = o.clone(m.svgH);
                  var i = Array.isArray(m.svgHTemp.fill) ? m.svgHTemp.fill[o[r].level] : m.svgHTemp.fill;
                  m.svgHTemp.fill = i, m.hovertimeline.to(m.svg, ge, m.svgHTemp, 0), m.hovertimeline.to(m.svgPath, ge, {
                    fill: i
                  }, 0);
                }
                m.hovertimeline.play();
              }
              m.lastHoveredTimeStamp = new Date().getTime();
            }
          }), o.document.on("mouseleave", ("column" === m.type ? "#" + m.cbg[0].id + "," : "") + "#" + m.c[0].id, function () {
            m.elementHovered = !1, (m.animationonscroll || m.readyForHover) && void 0 !== m.hovertimeline && (m.hovertimeline.reverse(), m.hovertimeline.eventCallback("onReverseComplete", o.hoverReverseDone, [{
              id: r,
              L: a
            }]));
          }));
        }
        if (M || (m.lastRequestedMainFrame = "start" === e.mode ? "frame_1" : "continue" === e.mode ? void 0 === e.frame ? m.currentframe : e.frame : m.lastRequestedMainFrame), void 0 !== e.totime ? m.tSTART = e.totime : void 0 !== v && void 0 === e.frame ? m.tSTART = v : void 0 !== e.frame ? m.tSTART = e.frame : m.tSTART = 0, 0 === m.tSTART && void 0 === m.startedAnimOnce && void 0 === m.leftstage && void 0 === m.startedAnimOnce && !0 === m.hideonfirststart && "preset" === e.mode && (o[r]._L[a[0].id].pVisRequest = 0, m.hideonfirststart = !1), "frame_999" !== m.tSTART && "frame_999" !== m.triggeredFrame || !m.leftstage && void 0 !== m.startedAnimOnce) {
          if ("true" != m.animationonscroll && 1 != m.animationonscroll ? m.timeline.play(m.tSTART) : m.timeline.time(m.tSTART), jQuery.inArray(m.type, ["group", "row", "column"]) >= 0 && void 0 !== e.frame) {
            if (void 0 === m.childrenJS) for (var W in m.childrenJS = {}, o[r]._L) void 0 !== o[r]._L[W]._lig && void 0 !== o[r]._L[W]._lig[0] && o[r]._L[W]._lig[0].id === a[0].id && o[r]._L[W]._lig[0].id !== o[r]._L[W].c[0].id && (m.childrenJS[o[r]._L[W].c[0].id] = o[r]._L[W].c);
            e.frame = "0" == e.frame ? "frame_0" : e.frame, e.frame = "1" == e.frame ? "frame_1" : e.frame, e.frame = "999" == e.frame ? "frame_999" : e.frame;
            var ue = void 0 === e.totime ? void 0 !== m.frames[e.frame].timeline.startAbsolute ? parseInt(m.frames[e.frame].timeline.startAbsolute, 0) / 1e3 : void 0 !== m.frames[e.frame].timeline.start ? o.isNumeric(m.frames[e.frame].timeline.start) ? parseInt(m.frames[e.frame].timeline.start, 0) / 1e3 : 0 : .001 : e.totime;
            if (!0 === e.updateChildren) for (var W in m.childrenJS) m.childrenJS.hasOwnProperty(W) && o.renderLayerAnimation({
              layer: m.childrenJS[W],
              fastforward: !1,
              id: r,
              mode: "continue",
              updateChildren: !0,
              totime: ue
            });else for (var W in m.childrenJS) m.childrenJS.hasOwnProperty(W) && o[r]._L[W].pausedTrueParrent && (o.renderLayerAnimation({
              layer: m.childrenJS[W],
              fastforward: !1,
              id: r,
              mode: "continue",
              updateChildren: !0,
              totime: ue
            }), o[r]._L[W].pausedTrueParrent = !1);
          }
        } else ;
      }
    }
  });
  var s = function s(e) {
      var i = o.clone(e);
      return delete i.backgroundColor, delete i.background, delete i.backgroundImage, delete i.borderSize, delete i.borderStyle, delete i["backdrop-filter"], i;
    },
    n = function n(e) {
      if (void 0 !== e && void 0 !== e.path && Array.isArray(e.path)) {
        var i = 0,
          t = 0;
        for (var a in e.path) !e.path.hasOwnProperty(a) || i > 0 || t > 0 || (i += e.path[a].x, t += e.path[a].y);
        return 0 != i || 0 != t;
      }
    },
    d = function d(e) {
      return void 0 === e.skewX && delete e.skewX, void 0 === e.skewY && delete e.skewY, e;
    },
    l = function l(e) {
      e.from = "edge" === e.from ? "edges" : e.from;
      var i = tpGS.gsap.utils.distribute(e);
      return function (t, a, r) {
        return i(t, a, r) + (t <= r.length / 2 ? 0 : e.offset || 0);
      };
    },
    c = function c(e) {
      o[e.id].BUG_safari_clipPath && e.L[0].classList.remove("rs-pelock"), (o[e.id]._L[e.L[0].id]._ingroup || o[e.id]._L[e.L[0].id]._incolumn || o[e.id]._L[e.L[0].id]._inrow) && void 0 !== o[e.id]._L[o[e.id]._L[e.L[0].id]._ligid] && void 0 !== o[e.id]._L[o[e.id]._L[e.L[0].id]._ligid].timeline && (o[e.id]._L[o[e.id]._L[e.L[0].id]._ligid].timeline.isActive() || void 0 === o[e.id]._L[e.L[0].id] || void 0 === o[e.id]._L[e.L[0].id].frames[o[e.id]._L[e.L[0].id].timeline.currentLabel()] || (null == o[e.id]._L[o[e.id]._L[e.L[0].id]._ligid].timezone || o[e.id]._L[o[e.id]._L[e.L[0].id]._ligid].timezone.to <= parseInt(o[e.id]._L[e.L[0].id].frames[o[e.id]._L[e.L[0].id].timeline.currentLabel()].timeline.start, 0)) && !0 !== o[e.id]._L[e.L[0].id].animOnScrollForceDisable && (o[e.id]._L[e.L[0].id].pausedTrueParrent = !0, o[e.id]._L[e.L[0].id].timeline.pause()));
      var i = o[e.id]._L[e.L[0].id],
        t = i.hovertimeline;
      t && t.time() > 0 && (t.pause(), t.time(0), t.kill(), delete i.hovertimeline), delete o[e.id]._L[e.L[0].id].childrenAtStartNotVisible, o[e.id]._L[e.L[0].id].pVisRequest = 1;
      var a = {
        layer: e.L
      };
      o[e.id]._L[e.L[0].id].ignoremousemove = !1, o[e.id]._L[e.L[0].id].leftstage = !1, o[e.id]._L[e.L[0].id].readyForHover = !1, void 0 !== o[e.id]._L[e.L[0].id].layerLoop && o[e.id]._L[e.L[0].id].layerLoop.from === e.frame && o[e.id]._L[e.L[0].id].layerLoop.count++, "frame_1" === e.frame && "Safari" === window.RSBrowser && void 0 === o[e.id]._L[e.L[0].id].safariRenderIssue && (tpGS.gsap.set([o[e.id]._L[e.L[0].id].c], {
        opacity: 1
      }), o[e.id]._L[e.L[0].id].safariRenderIssue = !0), "frame_999" !== e.frame && (o[e.id]._L[e.L[0].id].startedAnimOnce = !0, o[e.id]._L[e.L[0].id].pPeventsRequest = o[e.id]._L[e.L[0].id].noPevents ? "none" : "auto"), a.eventtype = "frame_0" === e.frame || "frame_1" === e.frame ? "enterstage" : "frame_999" === e.frame ? "leavestage" : "framestarted", o[e.id]._L[e.L[0].id]._ingroup && !0 !== o[e.id]._L[o[e.id]._L[e.L[0].id]._lig[0].id].frames.frame_1.timeline.waitoncall && (o[e.id]._L[o[e.id]._L[e.L[0].id]._lig[0].id].pVisRequest = 1), o.requestLayerUpdates(e.id, a.eventtype, e.L[0].id, void 0 !== o[e.id]._L[e.L[0].id].frames[e.frame] && void 0 !== o[e.id]._L[e.L[0].id].frames[e.frame].timeline && 0 == o[e.id]._L[e.L[0].id].frames[e.frame].timeline.usePerspective ? e.tPE : "ignore"), a.id = e.id, a.layerid = e.L[0].id, a.layertype = o[e.id]._L[e.L[0].id].type, a.frame_index = e.frame, a.layersettings = o[e.id]._L[e.L[0].id], o[e.id].c.trigger("revolution.layeraction", [a]), "enterstage" === a.eventtype && o.toggleState(o[e.id]._L[e.L[0].id].layertoggledby), "frame_1" === e.frame && o.animcompleted(e.L, e.id);
    },
    p = function p(e) {
      "frame_999" === e.frame && (o[e.id]._L[e.L[0].id].pVisRequest = 1, o[e.id]._L[e.L[0].id].pPeventsRequest = o[e.id]._L[e.L[0].id].noPevents ? "none" : "auto", o[e.id]._L[e.L[0].id].leftstage = !1, window.requestAnimationFrame(function () {
        o.requestLayerUpdates(e.id, "update", e.L[0].id);
      }));
    },
    g = function g(e) {
      var i = !0;
      if ("column" === o[e.id]._L[e.L[0].id].type || "row" === o[e.id]._L[e.L[0].id].type || "group" === o[e.id]._L[e.L[0].id].type) {
        var t = o[e.id]._L[e.L[0].id].timeline.currentLabel(),
          a = jQuery.inArray(t, o[e.id]._L[e.L[0].id].ford);
        a++, a = o[e.id]._L[e.L[0].id].ford.length > a ? o[e.id]._L[e.L[0].id].ford[a] : t, void 0 !== o[e.id]._L[e.L[0].id].frames[a] && void 0 !== o[e.id]._L[e.L[0].id].frames[t] && (o[e.id]._L[e.L[0].id].timezone = {
          from: parseInt(o[e.id]._L[e.L[0].id].frames[t].timeline.startAbsolute, 0),
          to: parseInt(o[e.id]._L[e.L[0].id].frames[a].timeline.startAbsolute, 0)
        });
      }
      if ("frame_999" !== e.frame && o[e.id].isEdge && "shape" === o[e.id]._L[e.L[0].id].type) {
        var r = o[e.id]._L[e.L[0].id].c[0].style.opacity;
        o[e.id]._L[e.L[0].id].c[0].style.opacity = r - 1e-4, tpGS.gsap.set(o[e.id]._L[e.L[0].id].c[0], {
          opacity: r - .001,
          delay: .05
        }), tpGS.gsap.set(o[e.id]._L[e.L[0].id].c[0], {
          opacity: r,
          delay: .1
        });
      }
      var s = {};
      s.layer = e.L, s.eventtype = "frame_0" === e.frame || "frame_1" === e.frame ? "enteredstage" : "frame_999" === e.frame ? "leftstage" : "frameended", o[e.id]._L[e.L[0].id].readyForHover = !0, s.layertype = o[e.id]._L[e.L[0].id].type, s.frame_index = e.frame, s.layersettings = o[e.id]._L[e.L[0].id], o[e.id].c.trigger("revolution.layeraction", [s]), "frame_999" === e.frame && "leftstage" === s.eventtype ? (o[e.id]._L[e.L[0].id].leftstage = !0, o[e.id]._L[e.L[0].id].pVisRequest = 0, o[e.id]._L[e.L[0].id].pPeventsRequest = "none", i = !1, window.requestAnimationFrame(function () {
        o.requestLayerUpdates(e.id, "leftstage", e.L[0].id);
      })) : (e.L[0].id, void 0 !== o[e.id]._L[e.L[0].id].frames[e.frame] && void 0 !== o[e.id]._L[e.L[0].id].frames[e.frame].timeline && 0 == o[e.id]._L[e.L[0].id].frames[e.frame].timeline.usePerspective && window.requestAnimationFrame(function () {
        o.requestLayerUpdates(e.id, "frameended", e.L[0].id, e.tPE);
      })), "leftstage" === s.eventtype && void 0 !== o[e.id].videos && void 0 !== o[e.id].videos[e.L[0].id] && o.stopVideo && o.stopVideo(e.L, e.id), "column" === o[e.id]._L[e.L[0].id].type && tpGS.gsap.to(o[e.id]._L[e.L[0].id].cbg, .01, {
        visibility: "visible"
      }), "leftstage" === s.eventtype && (o.unToggleState(e.layertoggledby), "video" === o[e.id]._L[e.L[0].id].type && o.resetVideo && setTimeout(function () {
        o.resetVideo(e.L, e.id);
      }, 100)), o[e.id].BUG_safari_clipPath && !i && e.L[0].classList.add("rs-pelock"), void 0 !== o[e.id]._L[e.L[0].id].layerLoop && o[e.id]._L[e.L[0].id].layerLoop.to === e.frame && (-1 == o[e.id]._L[e.L[0].id].layerLoop.repeat || o[e.id]._L[e.L[0].id].layerLoop.repeat > o[e.id]._L[e.L[0].id].layerLoop.count) && o.renderLayerAnimation({
        layer: o[e.id]._L[e.L[0].id].c,
        frame: o[e.id]._L[e.L[0].id].layerLoop.from,
        updateChildren: o[e.id]._L[e.L[0].id].layerLoop.children,
        mode: "continue",
        fastforward: !0 === o[e.id]._L[e.L[0].id].layerLoop.keep,
        id: e.id
      });
    },
    u = function u(e) {
      if (void 0 === e) return "";
      var i = "";
      return o.isChrome8889 && 0 === e.blur && (e.blur = .05), i = void 0 !== e.blur ? "blur(" + (e.blur || 0) + "px)" : "", i += void 0 !== e.grayscale ? (i.length > 0 ? " " : "") + "grayscale(" + (e.grayscale || 0) + "%)" : "", "" === (i += void 0 !== e.brightness ? (i.length > 0 ? " " : "") + "brightness(" + (e.brightness || 100) + "%)" : "") ? "none" : i;
    },
    h = function h(e, i, t) {
      var a,
        r = o.clone(e.transform);
      if ((r.originX || r.originY || r.originZ) && (r.transformOrigin = (void 0 === r.originX ? "50%" : r.originX) + " " + (void 0 === r.originY ? "50%" : r.originY) + " " + (void 0 === r.originZ ? "50%" : r.originZ), delete r.originX, delete r.originY, delete r.originZ), void 0 !== e && void 0 !== e.filter && (r.filter = u(e.filter), r["-webkit-filter"] = r.filter), r.color = void 0 === r.color ? "rgba(255,255,255,1)" : r.color, r.force3D = "auto", void 0 !== r.borderRadius && ((a = r.borderRadius.split(" ")).length, r.borderTopLeftRadius = a[0], r.borderTopRightRadius = a[1], r.borderBottomRightRadius = a[2], r.borderBottomLeftRadius = a[3], delete r.borderRadius), void 0 !== r.borderWidth && ((a = r.borderWidth.split(" ")).length, r.borderTopWidth = a[0], r.borderRightWidth = a[1], r.borderBottomWidth = a[2], r.borderLeftWidth = a[3], delete r.borderWidth), void 0 === t.bg || -1 === t.bg.indexOf("url")) {
        var s = -1 !== t.bgCol.search("gradient"),
          n = r.backgroundImage && "string" == typeof r.backgroundImage && -1 !== r.backgroundImage.search("gradient");
        n && s ? (180 !== v(t.bgCol) && 180 == v(r.backgroundImage) && (r.backgroundImage = m(r.backgroundImage, 180)), r.backgroundImage = tpGS.getSSGColors(t.bgCol, r.backgroundImage, void 0 === r.gs ? "fading" : r.gs).to) : n && !s ? r.backgroundImage = tpGS.getSSGColors(t.bgCol, r.backgroundImage, void 0 === r.gs ? "fading" : r.gs).to : !n && s && (r.backgroundImage = tpGS.getSSGColors(t.bgCol, r.backgroundColor, void 0 === r.gs ? "fading" : r.gs).to);
      }
      return delete r.gs, r;
    },
    m = function m(e, i) {
      var t = (e = e.split("("))[0];
      return e.shift(), t + "(" + i + "deg, " + e.join("(");
    },
    v = function v(e) {
      if (-1 !== e.search("deg,")) {
        var i = e.split("deg,")[0];
        if (-1 !== i.search(/\(/)) return parseInt(i.split("(")[1], 10);
      }
      return 180;
    },
    f = function f(e, i) {
      if (void 0 !== e && e.indexOf("oc:t") >= 0) return {};
      e = void 0 === e ? "" : e.split(";");
      var t = {
        fill: o.revToResp("#ffffff", o[i].rle),
        stroke: "transparent",
        "stroke-width": "0px",
        "stroke-dasharray": "0",
        "stroke-dashoffset": "0"
      };
      for (var a in e) if (e.hasOwnProperty(a)) {
        var r = e[a].split(":");
        switch (r[0]) {
          case "c":
            t.fill = o.revToResp(r[1], o[i].rle, void 0, "||");
            break;
          case "sw":
            t["stroke-width"] = r[1];
            break;
          case "sc":
            t.stroke = r[1];
            break;
          case "so":
            t["stroke-dashoffset"] = r[1];
            break;
          case "sa":
            t["stroke-dasharray"] = r[1];
            break;
          case "sall":
            t.svgAll = r[1];
        }
      }
      return t;
    },
    y = function y(e) {
      return "c" === e ? "center" : "l" === e ? "left" : "r" === e ? "right" : e;
    },
    w = function w(e) {
      var i = o[e.id]._L[e.layer[0].id],
        t = !1;
      if (i.splitText && !1 !== i.splitText && i.splitText.revert(), "text" === i.type || "button" === i.type) {
        for (var a in i.frames) if (void 0 !== i.frames[a].chars || void 0 !== i.frames[a].words || void 0 !== i.frames[a].lines) {
          t = !0;
          break;
        }
        i.splitText = !!t && new tpGS.SplitText(i.c, {
          type: "lines,words,chars",
          wordsClass: "rs_splitted_words",
          linesClass: "rs_splitted_lines",
          charsClass: "rs_splitted_chars"
        });
      } else i.splitText = !1;
    },
    b = function b(e, i, t) {
      if (void 0 !== e && e.indexOf("block") >= 0) {
        var a = {};
        switch (0 === i[0].getElementsByClassName("tp-blockmask_in").length && (i.append('<div class="tp-blockmask_in"></div>'), i.append('<div class="tp-blockmask_out"></div>')), t = void 0 === t ? "power3.inOut" : t, a.ft = [{
          scaleY: 1,
          scaleX: 0,
          transformOrigin: "0% 50%"
        }, {
          scaleY: 1,
          scaleX: 1,
          ease: t,
          immediateRender: !1
        }], a.t = {
          scaleY: 1,
          scaleX: 0,
          transformOrigin: "100% 50%",
          ease: t,
          immediateRender: !1
        }, a.bmask_in = i.find(".tp-blockmask_in"), a.bmask_out = i.find(".tp-blockmask_out"), a.type = "block", e) {
          case "blocktoleft":
          case "blockfromright":
            a.ft[0].transformOrigin = "100% 50%", a.t.transformOrigin = "0% 50%";
            break;
          case "blockfromtop":
          case "blocktobottom":
            a.ft = [{
              scaleX: 1,
              scaleY: 0,
              transformOrigin: "50% 0%"
            }, {
              scaleX: 1,
              scaleY: 1,
              ease: t,
              immediateRender: !1
            }], a.t = {
              scaleX: 1,
              scaleY: 0,
              transformOrigin: "50% 100%",
              ease: t,
              immediateRender: !1
            };
            break;
          case "blocktotop":
          case "blockfrombottom":
            a.ft = [{
              scaleX: 1,
              scaleY: 0,
              transformOrigin: "50% 100%"
            }, {
              scaleX: 1,
              scaleY: 1,
              ease: t,
              immediateRender: !1
            }], a.t = {
              scaleX: 1,
              scaleY: 0,
              transformOrigin: "50% 0%",
              ease: t,
              immediateRender: !1
            };
        }
        return a.ft[1].overwrite = "auto", a.t.overwrite = "auto", a;
      }
      return !1;
    },
    _ = function _(e, i, t, a, r) {
      return 0 === o[r].sdir || void 0 === i ? e : ("mask" === t ? a = "x" === a ? "mX" : "y" === a ? "mY" : a : "chars" === t ? a = "x" === a ? "cX" : "y" === a ? "cY" : "dir" === a ? "cD" : a : "words" === t ? a = "x" === a ? "wX" : "y" === a ? "wY" : "dir" === a ? "wD" : a : "lines" === t && (a = "x" === a ? "lX" : "y" === a ? "lY" : "dir" === a ? "lD" : a), void 0 === i[a] || !1 === i[a] ? e : void 0 !== i && !0 === i[a] ? "t" === e || "top" === e ? "b" : "b" === e || "bottom" === e ? "t" : "l" === e || "left" === e ? "r" : "r" === e || "right" === e ? "l" : -1 * e : void 0);
    },
    S = function S(e) {
      var i,
        t = o[e.id]._L[e.layer[0].id],
        a = void 0 === e.source ? o.clone(e.frame.transform) : o.clone(e.frame[e.source]),
        r = {
          originX: "50%",
          originY: "50%",
          originZ: "0"
        },
        s = void 0 !== t._lig ? o[e.id]._L[t._lig[0].id].eow : o[e.id].conw,
        n = void 0 !== t._lig ? o[e.id]._L[t._lig[0].id].eoh : o[e.id].conh;
      for (var d in a) if (a.hasOwnProperty(d)) {
        if (a[d] = "object" == _typeof(a[d]) ? a[d][o[e.id].level] : a[d], "inherit" === a[d] || "delay" === d || "direction" === d || "use" === d) delete a[d];else if ("originX" === d || "originY" === d || "originZ" === d) r[d] = a[d], delete a[d];else if (o.isNumeric(a[d], 0)) a[d] = _(a[d], e.frame.reverse, e.target, d, e.id, e.id);else if ("r" === a[d][0] && "a" === a[d][1] && "(" === a[d][3]) a[d] = a[d].replace("ran", "random");else if (a[d].indexOf("cyc(") >= 0) {
          var l = a[d].replace("cyc(", "").replace(")", "").replace("[", "").replace("]", "").split("|");
          a[d] = new function (e) {
            return tpGS.gsap.utils.wrap(l, void 0);
          }();
        } else if (a[d].indexOf("%") >= 0 && o.isNumeric(i = parseInt(a[d], 0))) a[d] = "x" === d ? _((t.eow || 0) * i / 100, e.frame.reverse, e.target, d, e.id) : "y" === d ? _((t.eoh || 0) * i / 100, e.frame.reverse, e.target, d, e.id) : a[d];else {
          a[d] = a[d].replace("[", "").replace("]", ""), a[d] = _(a[d], e.frame.reverse, e.target, d, e.id, e.id);
          var c = {
            t: 0,
            b: 0
          };
          switch ("row" === t.type && ("rev_row_zone_top" === t.zone && void 0 !== o[e.id].topZones[t.slideIndex] && void 0 !== o[e.id].topZones[t.slideIndex][0] ? c = {
            t: 0,
            b: 0
          } : "rev_row_zone_middle" === t.zone && void 0 !== o[e.id].middleZones[t.slideIndex] && void 0 !== o[e.id].middleZones[t.slideIndex][0] ? c = {
            t: Math.round(o[e.id].module.height / 2 - o[e.id].middleZones[t.slideIndex][0].offsetHeight / 2),
            b: Math.round(o[e.id].module.height / 2 + o[e.id].middleZones[t.slideIndex][0].offsetHeight / 2)
          } : "rev_row_zone_bottom" === t.zone && void 0 !== o[e.id].bottomZones[t.slideIndex] && void 0 !== o[e.id].bottomZones[t.slideIndex][0] && (c = {
            t: Math.round(o[e.id].module.height - o[e.id].bottomZones[t.slideIndex][0].offsetHeight),
            b: o[e.id].module.height + o[e.id].bottomZones[t.slideIndex][0].offsetHeight
          })), a[d]) {
            case "t":
            case "top":
              a[d] = 0 - (t.eoh || 0) - ("column" === t.type ? 0 : t.calcy || 0) - o.getLayerParallaxOffset(e.id, e.layer[0].id, "v") - ("row" === t.type && void 0 !== t.marginTop ? t.marginTop[o[e.id].level] : 0) - c.b;
              break;
            case "b":
            case "bottom":
              a[d] = n - ("column" === t.type || "row" === t.type ? 0 : t.calcy || 0) + o.getLayerParallaxOffset(e.id, e.layer[0].id, "v") - c.t;
              break;
            case "l":
            case "left":
              a[d] = 0 - ("row" === t.type ? t.pow : t.eow || 0) - ("column" === t.type ? 0 : "row" === t.type ? t.rowcalcx : t.calcx || 0) - o.getLayerParallaxOffset(e.id, e.layer[0].id, "h");
              break;
            case "r":
            case "right":
              a[d] = s - ("column" === t.type ? 0 : "row" === t.type ? t.rowcalcx : t.calcx || 0) + o.getLayerParallaxOffset(e.id, e.layer[0].id, "h");
              break;
            case "m":
            case "c":
            case "middle":
            case "center":
              a[d] = "x" === d ? _(s / 2 - ("column" === t.type ? 0 : t.calcx || 0) - (t.eow || 0) / 2, e.frame.reverse, e.target, d, e.id) : "y" === d ? _(n / 2 - ("column" === t.type ? 0 : t.calcy || 0) - (t.eoh || 0) / 2, e.frame.reverse, e.target, d, e.id) : a[d];
          }
        }
        "skewX" === d && void 0 !== a[d] && (a.scaleY = void 0 === a.scaleY ? 1 : parseFloat(a.scaleY), a.scaleY *= Math.cos(parseFloat(a[d]) * tpGS.DEG2RAD)), "skewY" === d && void 0 !== a[d] && (a.scaleX = void 0 === a.scaleX ? 1 : parseFloat(a.scaleX), a.scaleX *= Math.cos(parseFloat(a[d]) * tpGS.DEG2RAD));
      }
      if (a.transformOrigin = r.originX + " " + r.originY + " " + r.originZ, !o[e.id].BUG_ie_clipPath && void 0 !== a.clip && void 0 !== t.clipPath && t.clipPath.use) {
        var p = "rectangle" == t.clipPath.type,
          g = parseInt(a.clip, 0),
          h = 100 - parseInt(a.clipB, 0),
          m = Math.round(g / 2);
        switch (t.clipPath.origin) {
          case "invh":
            a.clipPath = "polygon(0% 0%, 0% 100%, " + g + "% 100%, " + g + "% 0%, 100% 0%, 100% 100%, " + h + "% 100%, " + h + "% 0%, 0% 0%)";
            break;
          case "invv":
            a.clipPath = "polygon(100% 0%, 0% 0%, 0% " + g + "%, 100% " + g + "%, 100% 100%, 0% 100%, 0% " + h + "%, 100% " + h + "%, 100% 0%)";
            break;
          case "cv":
            a.clipPath = p ? "polygon(" + (50 - m) + "% 0%, " + (50 + m) + "% 0%, " + (50 + m) + "% 100%, " + (50 - m) + "% 100%)" : "circle(" + g + "% at 50% 50%)";
            break;
          case "ch":
            a.clipPath = p ? "polygon(0% " + (50 - m) + "%, 0% " + (50 + m) + "%, 100% " + (50 + m) + "%, 100% " + (50 - m) + "%)" : "circle(" + g + "% at 50% 50%)";
            break;
          case "l":
            a.clipPath = p ? "polygon(0% 0%, " + g + "% 0%, " + g + "% 100%, 0% 100%)" : "circle(" + g + "% at 0% 50%)";
            break;
          case "r":
            a.clipPath = p ? "polygon(" + (100 - g) + "% 0%, 100% 0%, 100% 100%, " + (100 - g) + "% 100%)" : "circle(" + g + "% at 100% 50%)";
            break;
          case "t":
            a.clipPath = p ? "polygon(0% 0%, 100% 0%, 100% " + g + "%, 0% " + g + "%)" : "circle(" + g + "% at 50% 0%)";
            break;
          case "b":
            a.clipPath = p ? "polygon(0% 100%, 100% 100%, 100% " + (100 - g) + "%, 0% " + (100 - g) + "%)" : "circle(" + g + "% at 50% 100%)";
            break;
          case "lt":
            a.clipPath = p ? "polygon(0% 0%," + 2 * g + "% 0%, 0% " + 2 * g + "%)" : "circle(" + g + "% at 0% 0%)";
            break;
          case "lb":
            a.clipPath = p ? "polygon(0% " + (100 - 2 * g) + "%, 0% 100%," + 2 * g + "% 100%)" : "circle(" + g + "% at 0% 100%)";
            break;
          case "rt":
            a.clipPath = p ? "polygon(" + (100 - 2 * g) + "% 0%, 100% 0%, 100% " + 2 * g + "%)" : "circle(" + g + "% at 100% 0%)";
            break;
          case "rb":
            a.clipPath = p ? "polygon(" + (100 - 2 * g) + "% 100%, 100% 100%, 100% " + (100 - 2 * g) + "%)" : "circle(" + g + "% at 100% 100%)";
            break;
          case "clr":
            a.clipPath = p ? "polygon(0% 0%, 0% " + g + "%, " + (100 - g) + "% 100%, 100% 100%, 100% " + (100 - g) + "%, " + g + "% 0%)" : "circle(" + g + "% at 50% 50%)";
            break;
          case "crl":
            a.clipPath = p ? "polygon(0% " + (100 - g) + "%, 0% 100%, " + g + "% 100%, 100% " + g + "%, 100% 0%, " + (100 - g) + "% 0%)" : "circle(" + g + "% at 50% 50%)";
        }
        !0 !== o.isFirefox(e.id) && (a["-webkit-clip-path"] = a.clipPath), a["clip-path"] = a.clipPath, delete a.clip, delete a.clipB;
      } else delete a.clip;
      return "mask" !== e.target && (void 0 === e.frame || void 0 === e.frame.filter && !e.forcefilter || (a.filter = u(e.frame.filter), a["-webkit-filter"] = a.filter, a["backdrop-filter"] = function (e) {
        if (void 0 === e) return "";
        var i = "";
        return o.isChrome8889 && 0 === e.b_blur && (e.b_blur = .05), i = void 0 !== e.b_blur ? "blur(" + (e.b_blur || 0) + "px)" : "", i += void 0 !== e.b_grayscale ? (i.length > 0 ? " " : "") + "grayscale(" + (e.b_grayscale || 0) + "%)" : "", i += void 0 !== e.b_sepia ? (i.length > 0 ? " " : "") + "sepia(" + (e.b_sepia || 0) + "%)" : "", i += void 0 !== e.b_invert ? (i.length > 0 ? " " : "") + "invert(" + (e.b_invert || 0) + "%)" : "", "" == (i += void 0 !== e.b_brightness ? (i.length > 0 ? " " : "") + "brightness(" + (e.b_brightness || 100) + "%)" : "") ? "none" : i;
      }(e.frame.filter), window.isSafari11 && (a["-webkit-backdrop-filter"] = a["backdrop-filter"]), window.isSafari11 && void 0 !== a.filter && void 0 === a.x && void 0 !== e.frame.filter && void 0 !== e.frame.filter.blur && (a.x = 1e-4)), jQuery.inArray(e.source, ["chars", "words", "lines"]) >= 0 && (void 0 !== e.frame[e.source].blur || e.forcefilter) && (a.filter = u(e.frame[e.source]), a["-webkit-filter"] = a.filter), delete a.grayscale, delete a.blur, delete a.brightness), a.ease = void 0 !== a.ease ? a.ease : void 0 === a.ease && void 0 !== e.ease || void 0 !== a.ease && void 0 !== e.ease && "inherit" === a.ease ? e.ease : e.frame.timeline.ease, a.ease = void 0 === a.ease || "default" === a.ease ? "power3.inOut" : a.ease, a;
    },
    x = function x(e, i, t, a, r) {
      var s,
        n,
        d = {},
        l = {},
        c = {};
      for (var p in a = void 0 === a ? "transform" : a, "loop" === r ? (c.autoRotate = !1, c.yoyo_filter = !1, c.yoyo_rotate = !1, c.yoyo_move = !1, c.yoyo_scale = !1, c.curved = !1, c.curviness = 2, c.ease = "none", c.speed = 1e3, c.st = 0, d.x = 0, d.y = 0, d.z = 0, d.xr = 0, d.yr = 0, d.zr = 0, d.scaleX = 1, d.scaleY = 1, d.originX = "50%", d.originY = "50%", d.originZ = "0", d.rotationX = "0deg", d.rotationY = "0deg", d.rotationZ = "0deg") : (c.speed = 300, t ? c.ease = "default" : d.ease = "default"), "sfx" === r && (d.fxc = "#ffffff"), e = e.split(";")) if (e.hasOwnProperty(p)) {
        var g = e[p].split(":");
        switch (g[0]) {
          case "u":
            d.use = "true" === g[1] || "t" === g[1] || fasle;
            break;
          case "c":
            s = g[1];
            break;
          case "fxc":
            d.fxc = g[1];
            break;
          case "bgc":
            n = g[1];
            break;
          case "auto":
            d.auto = "t" === g[1] || void 0 === g[1] || "true" === g[1];
            break;
          case "o":
            d.opacity = g[1];
            break;
          case "oX":
            d.originX = g[1];
            break;
          case "oY":
            d.originY = g[1];
            break;
          case "oZ":
            d.originZ = g[1];
            break;
          case "sX":
            d.scaleX = g[1];
            break;
          case "sY":
            d.scaleY = g[1];
            break;
          case "skX":
            d.skewX = g[1];
            break;
          case "skY":
            d.skewY = g[1];
            break;
          case "rX":
            d.rotationX = g[1], 0 != g[1] && "0deg" !== g[1] && o.addSafariFix(i);
            break;
          case "rY":
            d.rotationY = g[1], 0 != g[1] && "0deg" !== g[1] && o.addSafariFix(i);
            break;
          case "rZ":
            d.rotationZ = g[1];
            break;
          case "sc":
            d.color = g[1];
            break;
          case "se":
            d.effect = g[1];
            break;
          case "bos":
            d.borderStyle = g[1];
            break;
          case "boc":
            d.borderColor = g[1];
            break;
          case "td":
            d.textDecoration = g[1];
            break;
          case "zI":
            d.zIndex = g[1];
            break;
          case "tp":
            d.transformPerspective = "isometric" === o[i].perspectiveType ? 0 : "global" === o[i].perspectiveType ? o[i].perspective : g[1];
            break;
          case "cp":
            d.clip = parseInt(g[1], 0);
            break;
          case "cpb":
            d.clipB = parseInt(g[1], 0);
            break;
          case "aR":
            c.autoRotate = "t" == g[1];
            break;
          case "rA":
            c.radiusAngle = g[1];
            break;
          case "yyf":
            c.yoyo_filter = "t" == g[1];
            break;
          case "yym":
            c.yoyo_move = "t" == g[1];
            break;
          case "yyr":
            c.yoyo_rotate = "t" == g[1];
            break;
          case "yys":
            c.yoyo_scale = "t" == g[1];
            break;
          case "crd":
            c.curved = "t" == g[1];
            break;
          case "x":
            d.x = "reverse" === r ? "t" === g[1] || !0 === g[1] || "true" == g[1] : "loop" === r ? parseInt(g[1], 0) : o.revToResp(g[1], o[i].rle);
            break;
          case "y":
            d.y = "reverse" === r ? "t" === g[1] || !0 === g[1] || "true" == g[1] : "loop" === r ? parseInt(g[1], 0) : o.revToResp(g[1], o[i].rle);
            break;
          case "z":
            d.z = "loop" === r ? parseInt(g[1], 0) : o.revToResp(g[1], o[i].rle), 0 != g[1] && o.addSafariFix(i);
            break;
          case "bow":
            d.borderWidth = o.revToResp(g[1], 4, 0).toString().replace(/,/g, " ");
            break;
          case "bor":
            d.borderRadius = o.revToResp(g[1], 4, 0).toString().replace(/,/g, " ");
            break;
          case "m":
            d.mask = "t" === g[1] || "f" !== g[1] && g[1];
            break;
          case "iC":
            d.instantClick = "t" === g[1] || "f" !== g[1] && g[1];
            break;
          case "xR":
            d.xr = parseInt(g[1], 0), o.addSafariFix(i);
            break;
          case "yR":
            d.yr = parseInt(g[1], 0), o.addSafariFix(i);
            break;
          case "zR":
            d.zr = parseInt(g[1], 0);
            break;
          case "blu":
            "loop" === r ? d.blur = parseInt(g[1], 0) : l.blur = parseInt(g[1], 0);
            break;
          case "gra":
            "loop" === r ? d.grayscale = parseInt(g[1], 0) : l.grayscale = parseInt(g[1], 0);
            break;
          case "bri":
            "loop" === r ? d.brightness = parseInt(g[1], 0) : l.brightness = parseInt(g[1], 0);
            break;
          case "bB":
            l.b_blur = parseInt(g[1], 0);
            break;
          case "bG":
            l.b_grayscale = parseInt(g[1], 0);
            break;
          case "bR":
            l.b_brightness = parseInt(g[1], 0);
            break;
          case "bI":
            l.b_invert = parseInt(g[1], 0);
            break;
          case "bS":
            l.b_sepia = parseInt(g[1], 0);
            break;
          case "sp":
            c.speed = parseInt(g[1], 0);
            break;
          case "d":
            d.delay = parseInt(g[1], 0);
            break;
          case "crns":
            c.curviness = parseInt(g[1], 0);
            break;
          case "st":
            c.start = "w" === g[1] || "a" === g[1] ? "+=0" : g[1], c.waitoncall = "w" === g[1] || "a" === g[1];
            break;
          case "sA":
            c.startAbsolute = g[1];
            break;
          case "sR":
            c.startRelative = g[1];
            break;
          case "e":
            t ? c.ease = g[1] : d.ease = g[1];
            break;
          default:
            g[0].length > 0 && (d[g[0]] = "t" === g[1] || "f" !== g[1] && g[1]);
        }
      }
      var u = {
        timeline: c
      };
      return jQuery.isEmptyObject(l) || ("split" === r ? d = jQuery.extend(!0, d, l) : u.filter = l), "split" === r && (d.dir = void 0 === d.dir ? "start" : "backward" === d.dir ? "end" : "middletoedge" === d.dir ? "center" : "edgetomiddle" === d.dir ? "edge" : d.dir), jQuery.isEmptyObject(s) || (u.color = s), jQuery.isEmptyObject(n) || (u.bgcolor = n), u[a] = d, u;
    },
    k = function k(e, i) {
      var t = {},
        a = 0;
      if (void 0 === o[i]._rdF0) {
        var r = x("x:0;y:0;z:0;rX:0;rY:0;rZ:0;o:0;skX:0;skY:0;sX:0;sY:0;oX:50%;oY:50%;oZ:0;dir:forward;d:5", i).transform;
        o[i]._rdF0 = o[i]._rdF1 = {
          transform: x("x:0;y:0;z:0;rX:0;rY:0;rZ:0;o:0;skX:0;skY:0;sX:0;sY:0;oX:50%;oY:50%;oZ:0;tp:600px", i, !0).transform,
          mask: x("x:0;y:0", i, !0).transform,
          chars: jQuery.extend(!0, {
            blur: 0,
            grayscale: 0,
            brightness: 100
          }, r),
          words: jQuery.extend(!0, {
            blur: 0,
            grayscale: 0,
            brightness: 100
          }, r),
          lines: jQuery.extend(!0, {
            blur: 0,
            grayscale: 0,
            brightness: 100
          }, r)
        }, o[i]._rdF1.transform.opacity = o[i]._rdF1.chars.opacity = o[i]._rdF1.words.opacity = o[i]._rdF1.lines.opacity = o[i]._rdF1.transform.scaleX = o[i]._rdF1.chars.scaleX = o[i]._rdF1.words.scaleX = o[i]._rdF1.lines.scaleX = o[i]._rdF1.transform.scaleY = o[i]._rdF1.chars.scaleY = o[i]._rdF1.words.scaleY = o[i]._rdF1.lines.scaleY = 1;
      }
      for (var a in void 0 === e.frame_0 && (e.frame_0 = "x:0"), void 0 === e.frame_1 && (e.frame_1 = "x:0"), e.dddNeeded = !1, e.ford) if (e.ford.hasOwnProperty(a)) {
        var s = e.ford[a];
        if (e[s]) {
          if (t[s] = x(e[s], i, !0), void 0 !== t[s].bgcolor && (e.bgcolinuse = !0), o[i].BUG_ie_clipPath && void 0 !== e.clipPath && e.clipPath.use && void 0 !== t[s].transform.clip) {
            var n = "rectangle" === e.clipPath.type ? 100 - parseInt(t[s].transform.clip) : 100 - Math.min(100, 2 * parseInt(t[s].transform.clip));
            switch (e.clipPath.origin) {
              case "clr":
              case "rb":
              case "rt":
              case "r":
                e[s + "_mask"] = "u:t;x:" + n + "%;y:0px;", t[s].transform.x = o.revToResp("-" + n + "%", o[i].rle);
                break;
              case "crl":
              case "lb":
              case "lt":
              case "cv":
              case "l":
                e[s + "_mask"] = "u:t;x:-" + n + "%;y:0px;", t[s].transform.x = o.revToResp(n + "%", o[i].rle);
                break;
              case "ch":
              case "t":
                e[s + "_mask"] = "u:t;y:-" + n + "%;y:0px;", t[s].transform.y = o.revToResp(n + "%", o[i].rle);
                break;
              case "b":
                e[s + "_mask"] = "u:t;y:" + n + "%;y:0px;", t[s].transform.y = o.revToResp("-" + n + "%", o[i].rle);
            }
            delete t[s].transform.clip, delete t[s].transform.clipB;
          }
          e[s + "_mask"] && (t[s].mask = x(e[s + "_mask"], i).transform), null != t[s].mask && t[s].mask.use ? (t[s].mask.x = void 0 === t[s].mask.x ? 0 : t[s].mask.x, t[s].mask.y = void 0 === t[s].mask.y ? 0 : t[s].mask.y, delete t[s].mask.use, t[s].mask.overflow = "hidden") : t[s].mask = {
            ease: "default",
            overflow: "visible"
          }, e[s + "_chars"] && (t[s].chars = x(e[s + "_chars"], i, void 0, void 0, "split").transform), e[s + "_words"] && (t[s].words = x(e[s + "_words"], i, void 0, void 0, "split").transform), e[s + "_lines"] && (t[s].lines = x(e[s + "_lines"], i, void 0, void 0, "split").transform), (e[s + "_chars"] || e[s + "_words"] || e[s + "_lines"]) && (t[s].dosplit = !0), t.frame_0 = void 0 === t.frame_0 ? {
            transform: {}
          } : t.frame_0, t[s].transform.auto && (t[s].transform = o.clone(t.frame_0.transform), t[s].transform.opacity = void 0 === t[s].transform.opacity ? 0 : t[s].transform.opacity, void 0 !== t.frame_0.filter && (t[s].filter = o.clone(t.frame_0.filter)), void 0 !== t.frame_0.mask && (t[s].mask = o.clone(t.frame_0.mask)), void 0 !== t.frame_0.chars && (t[s].chars = o.clone(t.frame_0.chars)), void 0 !== t.frame_0.words && (t[s].words = o.clone(t.frame_0.words)), void 0 !== t.frame_0.lines && (t[s].lines = o.clone(t.frame_0.lines)), void 0 === t.frame_0.chars && void 0 === t.frame_0.words && void 0 === t.frame_0.lines || (t[s].dosplit = !0)), e[s + "_sfx"] && (t[s].sfx = x(e[s + "_sfx"], i, !1, void 0, "sfx").transform), e[s + "_reverse"] && (t[s].reverse = x(e[s + "_reverse"], i, !1, void 0, "reverse").transform);
        }
      }
      if (t.frame_0.dosplit && (t.frame_1.dosplit = !0), void 0 === e.frame_hover && void 0 === e.svgh || (t.frame_hover = x(void 0 === e.frame_hover ? "" : e.frame_hover, i), !o.ISM || "true" != t.frame_hover.transform.instantClick && 1 != t.frame_hover.transform.instantClick ? (delete t.frame_hover.transform.instantClick, t.frame_hover.transform.color = t.frame_hover.color, void 0 === t.frame_hover.transform.color && delete t.frame_hover.transform.color, void 0 !== t.frame_hover.bgcolor && t.frame_hover.bgcolor.indexOf("gradient") >= 0 ? t.frame_hover.transform.backgroundImage = t.frame_hover.bgcolor : void 0 !== t.frame_hover.bgcolor && (t.frame_hover.transform.backgroundColor = t.frame_hover.bgcolor), void 0 !== t.frame_hover.bgcolor && (e.bgcolinuse = !0), t.frame_hover.transform.opacity = void 0 === t.frame_hover.transform.opacity ? 1 : t.frame_hover.transform.opacity, t.frame_hover.mask = void 0 !== t.frame_hover.transform.mask && t.frame_hover.transform.mask, delete t.frame_hover.transform.mask, void 0 !== t.frame_hover.transform && ((t.frame_hover.transform.borderWidth || t.frame_hover.transform.borderStyle) && (t.frame_hover.transform.borderColor = void 0 === t.frame_hover.transform.borderColor ? "transparent" : t.frame_hover.transform.borderColor), "none" !== t.frame_hover.transform.borderStyle && void 0 === t.frame_hover.transform.borderWidth && (t.frame_hover.transform.borderWidth = o.revToResp(0, 4, 0).toString().replace(/,/g, " ")), void 0 === e.bordercolor && void 0 !== t.frame_hover.transform.borderColor && (e.bordercolor = "transparent"), void 0 === e.borderwidth && void 0 !== t.frame_hover.transform.borderWidth && (e.borderwidth = o.revToResp(t.frame_hover.transform.borderWidth, 4, 0)), void 0 === e.borderstyle && void 0 !== t.frame_hover.transform.borderStyle && (e.borderstyle = o.revToResp(t.frame_hover.transform.borderStyle, 4, 0)))) : delete t.frame_hover), void 0 !== e.tloop) {
        e.layerLoop = {
          from: "frame_1",
          to: "frame_999",
          repeat: -1,
          keep: !0,
          children: !0
        };
        var d = e.tloop.split(";");
        for (var a in d) if (d.hasOwnProperty(a)) {
          var l = d[a].split(":");
          switch (l[0]) {
            case "f":
              e.layerLoop.from = l[1];
              break;
            case "t":
              e.layerLoop.to = l[1];
              break;
            case "k":
              e.layerLoop.keep = l[1];
              break;
            case "r":
              e.layerLoop.repeat = parseInt(l[1], 0);
              break;
            case "c":
              e.layerLoop.children = l[1];
          }
        }
        e.layerLoop.count = 0;
      }
      for (var a in (e.loop_0 || e.loop_999) && (t.loop = x(e.loop_999, i, !0, "frame_999", "loop"), t.loop.frame_0 = x(e.loop_0 || "", i, !1, void 0, "loop").transform), t.frame_0.transform.opacity = void 0 === t.frame_0.transform.opacity ? 0 : t.frame_0.transform.opacity, t.frame_1.transform.opacity = void 0 === t.frame_1.transform.opacity ? 1 : t.frame_1.transform.opacity, t.frame_999.transform.opacity = void 0 === t.frame_999.transform.opacity ? "inherit" : t.frame_999.transform.opacity, e.clipPath && e.clipPath.use && (t.frame_0.transform.clip = void 0 === t.frame_0.transform.clip ? 100 : parseInt(t.frame_0.transform.clip), t.frame_1.transform.clip = void 0 === t.frame_1.transform.clip ? 100 : parseInt(t.frame_1.transform.clip)), e.resetfilter = !1, e.useFilter = {
        blur: !1,
        grayscale: !1,
        brightness: !1,
        b_blur: !1,
        b_grayscale: !1,
        b_brightness: !1,
        b_invert: !1,
        b_sepia: !1
      }, t) void 0 !== t[a].filter && (e.resetfilter = !0, e.useFilter = R(e.useFilter, t[a].filter));
      if (!0 !== e.resetFilter && void 0 !== t.frame_hover && (e.useFilter = R(e.useFilter, t.frame_hover)), e.resetfilter) for (var a in t.frame_0.filter = o.clone(t.frame_0.filter), t.frame_0.filter = L(e.useFilter, o.clone(t.frame_0.filter)), t) void 0 !== t[a].filter && "frame_1" !== a && "frame_0" !== a && (t[a].filter = o.clone(t[a].filter), t[a].filter = L(e.useFilter, o.clone(t[a].filter)));
      return void 0 !== t.frame_0.filter && (t.frame_1.filter = o.clone(t.frame_1.filter), void 0 !== t.frame_0.filter.blur && 0 !== t.frame_1.filter.blur && (t.frame_1.filter.blur = void 0 === t.frame_1.filter.blur ? 0 : t.frame_1.filter.blur), void 0 !== t.frame_0.filter.brightness && 100 !== t.frame_1.filter.brightness && (t.frame_1.filter.brightness = void 0 === t.frame_1.filter.brightness ? 100 : t.frame_1.filter.brightness), void 0 !== t.frame_0.filter.grayscale && 0 !== t.frame_1.filter.grayscale && (t.frame_1.filter.grayscale = void 0 === t.frame_1.filter.grayscale ? 0 : t.frame_1.filter.grayscale), void 0 !== t.frame_0.filter.b_blur && 0 !== t.frame_1.filter.b_blur && (t.frame_1.filter.b_blur = void 0 === t.frame_1.filter.b_blur ? 0 : t.frame_1.filter.b_blur), void 0 !== t.frame_0.filter.b_brightness && 100 !== t.frame_1.filter.b_brightness && (t.frame_1.filter.b_brightness = void 0 === t.frame_1.filter.b_brightness ? 100 : t.frame_1.filter.b_brightness), void 0 !== t.frame_0.filter.b_grayscale && 0 !== t.frame_1.filter.b_grayscale && (t.frame_1.filter.b_grayscale = void 0 === t.frame_1.filter.b_grayscale ? 0 : t.frame_1.filter.b_grayscale), void 0 !== t.frame_0.filter.b_invert && 0 !== t.frame_1.filter.b_invert && (t.frame_1.filter.b_invert = void 0 === t.frame_1.filter.b_invert ? 0 : t.frame_1.filter.b_invert), void 0 !== t.frame_0.filter.b_sepia && 0 !== t.frame_1.filter.b_sepia && (t.frame_1.filter.b_sepia = void 0 === t.frame_1.filter.b_sepia ? 0 : t.frame_1.filter.b_sepia)), I(t, i, e);
    },
    L = function L(e, i) {
      return e.blur ? i.blur = void 0 === i.blur ? 0 : i.blur : delete i.blur, e.brightness ? i.brightness = void 0 === i.brightness ? 100 : i.brightness : delete i.brightness, e.grayscale ? i.grayscale = void 0 === i.grayscale ? 0 : i.grayscale : delete i.grayscale, e.b_blur ? i.b_blur = void 0 === i.b_blur ? 0 : i.b_blur : delete i.b_blur, e.b_brightness ? i.b_brightness = void 0 === i.b_brightness ? 100 : i.b_brightness : delete i.b_brightness, e.b_grayscale ? i.b_grayscale = void 0 === i.b_grayscale ? 0 : i.b_grayscale : delete i.b_grayscale, e.b_invert ? i.b_invert = void 0 === i.b_invert ? 0 : i.b_invert : delete i.b_invert, e.b_sepia ? i.b_sepia = void 0 === i.b_sepia ? 0 : i.b_sepia : delete i.b_sepia, i;
    },
    R = function R(e, i) {
      return e.blur = !0 === e.blur || void 0 !== i.blur && 0 !== i.blur && "0px" !== i.blur, e.grayscale = !0 === e.grayscale || void 0 !== i.grayscale && 0 !== i.grayscale && "0%" !== i.grayscale, e.brightness = !0 === e.brightness || void 0 !== i.brightness && 100 !== i.brightness && "100%" !== i.brightness, e.b_blur = !0 === e.b_blur || void 0 !== i.b_blur && 0 !== i.b_blur && "0px" !== i.b_blur, e.b_grayscale = !0 === e.b_grayscale || void 0 !== i.b_grayscale && 0 !== i.b_grayscale && "0%" !== i.b_grayscale, e.b_brightness = !0 === e.b_brightness || void 0 !== i.b_brightness && 100 !== i.b_brightness && "100%" !== i.b_brightness, e.b_invert = !0 === e.b_invert || void 0 !== i.b_invert && 0 !== i.b_invert && "0%" !== i.b_invert, e.b_sepia = !0 === e.b_sepia || void 0 !== i.b_sepia && 0 !== i.b_sepia && "0%" !== i.b_sepia, e;
    },
    O = function O(e) {
      return void 0 !== e && (void 0 !== e.rotationY || void 0 !== e.rotationX || void 0 !== e.z);
    },
    I = function I(e, i, t) {
      var a,
        r = {},
        s = ["transform", "words", "chars", "lines", "mask"],
        n = "global" == o[i].perspectiveType ? o[i].perspective : 0,
        d = !0,
        l = !1;
      for (var c in e) "loop" !== c && "frame_hover" !== c && (r = jQuery.extend(!0, r, e[c]));
      for (var c in e) if (e.hasOwnProperty(c) && (void 0 !== e[c].timeline && (e[c].timeline.usePerspective = !1), "loop" !== c && "frame_hover" !== c)) {
        for (a in r.transform) r.transform.hasOwnProperty(a) && (r.transform[a] = void 0 === e[c].transform[a] ? "frame_0" === c ? o[i]._rdF0.transform[a] : "frame_1" === c ? o[i]._rdF1.transform[a] : r.transform[a] : e[c].transform[a], e[c].transform[a] = void 0 === e[c].transform[a] ? r.transform[a] : e[c].transform[a]);
        for (var p = 1; p <= 4; p++) for (a in r[s[p]]) r[s[p]].hasOwnProperty(a) && (e[c][s[p]] = void 0 === e[c][s[p]] ? {} : e[c][s[p]], r[s[p]][a] = void 0 === e[c][s[p]][a] ? "frame_0" === c ? o[i]._rdF0[s[p]][a] : "frame_1" === c ? o[i]._rdF1[s[p]][a] : r[s[p]][a] : e[c][s[p]][a], e[c][s[p]][a] = void 0 === e[c][s[p]][a] ? r[s[p]][a] : e[c][s[p]][a]);
        void 0 !== e[c].timeline && !1 === e[c].timeline.usePerspective && void 0 !== e[c].transform && (void 0 !== e[c].transform.rotationY || void 0 !== e[c].transform.rotationX || void 0 !== e[c].transform.z || O(e[c].chars) || O(e[c].words) || O(e[c].lines)) && (n = "local" == o[i].perspectiveType ? void 0 === e[c].transform.transformPerspective ? 600 : e[c].transform.transformPerspective : n, e[c].timeline.usePerspective = !0, (O(e[c].chars) || O(e[c].words) || O(e[c].lines)) && !o.isFirefox(i) && (l = !0), d = !1);
      }
      if (l && requestAnimationFrame(function () {
        tpGS.gsap.set(t.c, {
          transformStyle: "preserve-3d"
        });
      }), void 0 !== e.frame_0.timeline && e.frame_0.timeline.usePerspective && (e.frame_0.transform.transformPerspective = "local" === o[i].perspectiveType ? void 0 === e.frame_0.transform.transformPerspective ? n : e.frame_0.transform.transformPerspective : "isometric" === o[i].perspectiveType ? 0 : o[i].perspective), d) for (var c in e) {
        if (!e.hasOwnProperty(c) || void 0 === e[c].transform) continue;
        delete e[c].transform.transformPerspective;
      }
      return e;
    },
    M = function M(e, i, t) {
      if (0 === e.length) return {};
      for (var a = e[0].getElementsByClassName(i), r = {}, o = 0; o < a.length; o++) void 0 !== t && -1 !== a[o].className.indexOf(t) || (r[a[o].id] = a[o]);
      if (void 0 !== e[1]) for (a = e[1].getElementsByClassName(i), o = 0; o < a.length; o++) void 0 !== t && -1 !== a[o].className.indexOf(t) || (r[a[o].id] = a[o]);
      return r;
    },
    T = function T(e) {
      return "thin" === (e = o.isNumeric(e) ? e : e.toLowerCase()) ? "00" : "extra light" === e ? 200 : "light" === e ? 300 : "normal" === e ? 400 : "medium" === e ? 500 : "semi bold" === e ? 600 : "bold" === e ? 700 : "extra bold" === e ? 800 : "ultra bold" === e ? 900 : "black" === e ? 900 : e;
    },
    C = function C(e, i, s) {
      var n;
      if ("BR" == e[0].nodeName || "br" == e[0].tagName || "object" != _typeof(e[0].className) && e[0].className.indexOf("rs_splitted_") >= 0) return !1;
      o.sA(e[0], "stylerecorder", !0), void 0 === e[0].id && (e[0].id = "rs-layer-sub-" + Math.round(1e6 * Math.random())), o[s].computedStyle[e[0].id] = window.getComputedStyle(e[0], null);
      var d = void 0 !== e[0].id && void 0 !== o[s]._L[e[0].id] ? o[s]._L[e[0].id] : e.data(),
        l = "rekursive" === i ? jQuery(o.closestClass(e[0], "rs-layer")) : void 0;
      void 0 !== l && (o[s].computedStyle[l[0].id] = void 0 === o[s].computedStyle[l[0].id] ? window.getComputedStyle(l[0], null) : o[s].computedStyle[l[0].id]);
      var c = void 0 !== l && o[s].computedStyle[e[0].id].fontSize == o[s].computedStyle[l[0].id].fontSize && T(o[s].computedStyle[e[0].id].fontWeight) == T(o[s].computedStyle[l[0].id].fontWeight) && o[s].computedStyle[e[0].id].lineHeight == o[s].computedStyle[l[0].id].lineHeight,
        p = c ? void 0 !== l[0].id && void 0 !== o[s]._L[l[0].id] ? o[s]._L[l[0].id] : l.data() : void 0,
        g = 0;
      for (d.basealign = void 0 === d.basealign ? "grid" : d.basealign, d._isnotext || (d.fontSize = o.revToResp(c ? void 0 === p.fontsize ? parseInt(o[s].computedStyle[l[0].id].fontSize, 0) || 20 : p.fontsize : void 0 === d.fontsize ? "rekursive" !== i ? 20 : "inherit" : d.fontsize, o[s].rle), d.fontWeight = o.revToResp(c ? void 0 === p.fontweight ? o[s].computedStyle[l[0].id].fontWeight || "inherit" : p.fontweight : void 0 === d.fontweight ? o[s].computedStyle[e[0].id].fontWeight || "inherit" : d.fontweight, o[s].rle), d.whiteSpace = o.revToResp(c ? void 0 === p.whitespace ? "nowrap" : p.whitespace : void 0 === d.whitespace ? "nowrap" : d.whitespace, o[s].rle), d.textAlign = o.revToResp(c ? void 0 === p.textalign ? "left" : p.textalign : void 0 === d.textalign ? "left" : d.textalign, o[s].rle), d.letterSpacing = o.revToResp(c ? void 0 === p.letterspacing ? parseInt(o[s].computedStyle[l[0].id].letterSpacing, 0) || "inherit" : p.letterspacing : void 0 === d.letterspacing ? parseInt("normal" === o[s].computedStyle[e[0].id].letterSpacing ? 0 : o[s].computedStyle[e[0].id].letterSpacing, 0) || "inherit" : d.letterspacing, o[s].rle), d.textDecoration = c ? void 0 === p.textDecoration ? "none" : p.textDecoration : void 0 === d.textDecoration ? "none" : d.textDecoration, g = 25, g = void 0 !== l && "I" === e[0].tagName ? "inherit" : g, void 0 !== d.tshadow && (d.tshadow.b = o.revToResp(d.tshadow.b, o[s].rle), d.tshadow.h = o.revToResp(d.tshadow.h, o[s].rle), d.tshadow.v = o.revToResp(d.tshadow.v, o[s].rle))), void 0 !== d.bshadow && (d.bshadow.b = o.revToResp(d.bshadow.b, o[s].rle), d.bshadow.h = o.revToResp(d.bshadow.h, o[s].rle), d.bshadow.v = o.revToResp(d.bshadow.v, o[s].rle), d.bshadow.s = o.revToResp(d.bshadow.s, o[s].rle)), void 0 !== d.tstroke && (d.tstroke.w = o.revToResp(d.tstroke.w, o[s].rle)), d.display = c ? void 0 === p.display ? o[s].computedStyle[l[0].id].display : p.display : void 0 === d.display ? o[s].computedStyle[e[0].id].display : d.display, d.float = o.revToResp(c ? void 0 === p.float ? o[s].computedStyle[l[0].id].float || "none" : p.float : void 0 === d.float ? "none" : d.float, o[s].rle), d.clear = o.revToResp(c ? void 0 === p.clear ? o[s].computedStyle[l[0].id].clear || "none" : p.clear : void 0 === d.clear ? "none" : d.clear, o[s].rle), d.lineHeight = o.revToResp(e.is("img") || -1 != jQuery.inArray(d.layertype, ["video", "image", "audio"]) ? g : c ? void 0 === p.lineheight ? parseInt(o[s].computedStyle[l[0].id].lineHeight, 0) || g : p.lineheight : void 0 === d.lineheight ? g : d.lineheight, o[s].rle), d.zIndex = c ? void 0 === p.zindex ? parseInt(o[s].computedStyle[l[0].id].zIndex, 0) || "inherit" : p.zindex : void 0 === d.zindex ? parseInt(o[s].computedStyle[e[0].id].zIndex, 0) || "inherit" : d.zindex, n = 0; n < 4; n++) d["padding" + t[n]] = o.revToResp(void 0 === d["padding" + r[n]] ? parseInt(o[s].computedStyle[e[0].id]["padding" + t[n]], 0) || 0 : d["padding" + r[n]], o[s].rle), d["margin" + t[n]] = o.revToResp(void 0 === d["margin" + r[n]] ? parseInt(o[s].computedStyle[e[0].id]["margin" + t[n]], 0) || 0 : d["margin" + r[n]], o[s].rle), d["border" + t[n] + "Width"] = void 0 === d.borderwidth ? parseInt(o[s].computedStyle[e[0].id]["border" + t[n] + "Width"], 0) || 0 : d.borderwidth[n], d["border" + t[n] + "Color"] = void 0 === d.bordercolor ? o[s].computedStyle[e[0].id]["border-" + r[n] + "-color"] : d.bordercolor, d["border" + a[n] + "Radius"] = o.revToResp(void 0 === d.borderradius ? o[s].computedStyle[e[0].id]["border" + a[n] + "Radius"] || 0 : d.borderradius[n], o[s].rle);
      for (d.borderStyle = o.revToResp(void 0 === d.borderstyle ? o[s].computedStyle[e[0].id].borderStyle || 0 : d.borderstyle, o[s].rle), "rekursive" !== i ? (d.color = o.revToResp(void 0 === d.color ? "#ffffff" : d.color, o[s].rle, void 0, "||"), d.minWidth = o.revToResp(void 0 === d.minwidth ? parseInt(o[s].computedStyle[e[0].id].minWidth, 0) || 0 : d.minwidth, o[s].rle), d.minHeight = o.revToResp(void 0 === d.minheight ? parseInt(o[s].computedStyle[e[0].id].minHeight, 0) || 0 : d.minheight, o[s].rle), d.width = o.revToResp(void 0 === d.width ? "auto" : o.smartConvertDivs(d.width), o[s].rle), d.height = o.revToResp(void 0 === d.height ? "auto" : o.smartConvertDivs(d.height), o[s].rle), d.maxWidth = o.revToResp(void 0 === d.maxwidth ? parseInt(o[s].computedStyle[e[0].id].maxWidth, 0) || "none" : d.maxwidth, o[s].rle), d.maxHeight = o.revToResp(-1 !== jQuery.inArray(d.type, ["column", "row"]) ? "none" : void 0 !== d.maxheight ? parseInt(o[s].computedStyle[e[0].id].maxHeight, 0) || "none" : d.maxheight, o[s].rle)) : "html" === d.layertype && (d.width = o.revToResp(e[0].width, o[s].rle), d.height = o.revToResp(e[0].height, o[s].rle)), d.styleProps = {
        background: e[0].style.background,
        "background-color": e[0].style["background-color"],
        color: e[0].style.color,
        cursor: e[0].style.cursor,
        "font-style": e[0].style["font-style"]
      }, null == d.bshadow && (d.styleProps.boxShadow = e[0].style.boxShadow), "" !== d.styleProps.background && void 0 !== d.styleProps.background && d.styleProps.background !== d.styleProps["background-color"] || delete d.styleProps.background, "" == d.styleProps.color && (d.styleProps.color = o[s].computedStyle[e[0].id].color), n = 0; n < 4; n++) A(d["padding" + t[n]], 0) && delete d["padding" + t[n]], A(d["margin" + t[n]], 0) && delete d["margin" + t[n]], A(d["border" + a[n] + "Radius"], "0px") ? delete d["border" + a[n] + "Radius"] : A(d["border" + a[n] + "Radius"], "0") && delete d["border" + a[n] + "Radius"];
      if (A(d.borderStyle, "none")) for (delete d.borderStyle, n = 0; n < 4; n++) delete d["border" + t[n] + "Width"], delete d["border" + t[n] + "Color"];
    },
    A = function A(e, i) {
      return i === e[0] && i === e[1] && i === e[2] && i === e[3];
    },
    D = function D(e, i, t, a, r) {
      var s = o.isNumeric(e) || void 0 === e ? "" : e.indexOf("px") >= 0 ? "px" : e.indexOf("%") >= 0 ? "%" : "";
      return e = o.isNumeric(parseInt(e)) ? parseInt(e) : e, e = null == (e = "full" === (e = o.isNumeric(e) ? e * i + s : e) ? a : "auto" === e || "none" === e ? t : e) ? r : e;
    },
    P = function P(e) {
      return null != e && 0 !== parseInt(e, 0);
    },
    B = function B(e) {
      var i,
        s,
        n,
        d,
        l,
        c,
        p,
        g,
        u,
        h,
        m = e.a,
        v = e.b,
        f = e.c,
        y = e.d,
        w = e.e,
        b = {},
        _ = {},
        S = o[v]._L[m[0].id],
        x = m[0].className;
      if (S = void 0 === S ? {} : S, "object" == _typeof(x) && (x = ""), void 0 !== m && void 0 !== m[0] && (x.indexOf("rs_splitted") >= 0 || "BR" == m[0].nodeName || "br" == m[0].tagName || m[0].tagName.indexOf("FCR") > 0 || m[0].tagName.indexOf("BCR") > 0)) return !1;
      w = "individual" === w ? S.slideIndex : w;
      e = function (e, i, r) {
        if (void 0 !== e) {
          if ("BR" == e[0].nodeName || "br" == e[0].tagName) return !1;
          var s,
            n = o[i].level,
            d = void 0 !== e[0] && void 0 !== e[0].id && void 0 !== o[i]._L[e[0].id] ? o[i]._L[e[0].id] : e.data();
          void 0 === (d = void 0 === d.basealign ? r.data() : d)._isnotext && (d._isnotext = void 0 !== r && void 0 !== r[0] && r[0].length > 0 ? o.gA(r[0], "_isnotext") : d._isnotext);
          var l = {
            basealign: void 0 === d.basealign ? "grid" : d.basealign,
            lineHeight: void 0 === d.basealign ? "inherit" : parseInt(d.lineHeight[n]),
            color: void 0 === d.color ? void 0 : d.color[n],
            width: void 0 === d.width ? void 0 : "a" === d.width[n] ? "auto" : d.width[n],
            height: void 0 === d.height ? void 0 : "a" === d.height[n] ? "auto" : d.height[n],
            minWidth: void 0 === d.minWidth ? void 0 : "n" === d.minWidth[n] ? "none" : d.minWidth[n],
            minHeight: void 0 === d.minHeight ? void 0 : "n" == d.minHeight[n] ? "none" : d.minHeight[n],
            maxWidth: void 0 === d.maxWidth ? void 0 : "n" == d.maxWidth[n] ? "none" : d.maxWidth[n],
            maxHeight: void 0 === d.maxHeight ? void 0 : "n" == d.maxHeight[n] ? "none" : d.maxHeight[n],
            float: d.float[n],
            clear: d.clear[n]
          };
          for (d.borderStyle && (l.borderStyle = d.borderStyle[n]), s = 0; s < 4; s++) d["padding" + t[s]] && (l["padding" + t[s]] = d["padding" + t[s]][n]), d["margin" + t[s]] && (l["margin" + t[s]] = parseInt(d["margin" + t[s]][n])), d["border" + a[s] + "Radius"] && (l["border" + a[s] + "Radius"] = d["border" + a[s] + "Radius"][n]), d["border" + t[s] + "Color"] && (l["border" + t[s] + "Color"] = d["border" + t[s] + "Color"]), d["border" + t[s] + "Width"] && (l["border" + t[s] + "Width"] = parseInt(d["border" + t[s] + "Width"]));
          return d._isnotext || (l.textDecoration = d.textDecoration, l.fontSize = parseInt(d.fontSize[n]), l.fontWeight = parseInt(d.fontWeight[n]), l.letterSpacing = parseInt(d.letterSpacing[n]) || 0, l.textAlign = d.textAlign[n], l.whiteSpace = d.whiteSpace[n], l.whiteSpace = "normal" === l.whiteSpace && "auto" === l.width && !0 !== d._incolumn ? "nowrap" : l.whiteSpace, l.display = d.display, void 0 !== d.tshadow && (l.textShadow = parseInt(d.tshadow.h[n], 0) + "px " + parseInt(d.tshadow.v[n], 0) + "px " + d.tshadow.b[n] + " " + d.tshadow.c), void 0 !== d.tstroke && (l.textStroke = parseInt(d.tstroke.w[n], 0) + "px " + d.tstroke.c)), void 0 !== d.bshadow && (l.boxShadow = parseInt(d.bshadow.h[n], 0) + "px " + parseInt(d.bshadow.v[n], 0) + "px " + parseInt(d.bshadow.b[n], 0) + "px " + parseInt(d.bshadow.s[n], 0) + "px " + d.bshadow.c), l;
        }
      }(m, v, e.RSL);
      var k,
        L = "off" === y ? 1 : o[v].CM.w;
      if (void 0 === S._isnotext && (S._isnotext = void 0 !== e.RSL && void 0 !== e.RSL[0] && e.RSL[0].length > 0 ? o.gA(e.RSL[0], "_isnotext") : S._isnotext), S.OBJUPD = null == S.OBJUPD ? {} : S.OBJUPD, S.caches = null == S.caches ? {} : S.caches, "column" === S.type) {
        for (s = {}, k = {}, i = 0; i < 4; i++) void 0 !== e["margin" + t[i]] && (s["padding" + t[i]] = Math.round(e["margin" + t[i]] * L) + "px", k["margin" + t[i]] = e["margin" + t[i]], delete e["margin" + t[i]]);
        jQuery.isEmptyObject(s) || tpGS.gsap.set(S._column, s);
      }
      var R = o.clone(S.OBJUPD.POBJ),
        O = o.clone(S.OBJUPD.LPOBJ);
      if (-1 === x.indexOf("rs_splitted_")) {
        for (s = {
          overwrite: "auto"
        }, i = 0; i < 4; i++) void 0 !== e["border" + a[i] + "Radius"] && (s["border" + a[i] + "Radius"] = e["border" + a[i] + "Radius"]), void 0 !== e["padding" + t[i]] && (s["padding" + t[i]] = Math.round(e["padding" + t[i]] * L) + "px"), void 0 === e["margin" + t[i]] || S._incolumn || (s["margin" + t[i]] = "row" === S.type ? 0 : Math.round(e["margin" + t[i]] * L) + "px");
        if (void 0 !== S.spike && (s["clip-path"] = s["-webkit-clip-path"] = S.spike), e.boxShadow && (s.boxShadow = e.boxShadow), "column" !== S.type && (void 0 !== e.borderStyle && "none" !== e.borderStyle && (0 !== e.borderTopWidth || e.borderBottomWidth > 0 || e.borderLeftWidth > 0 || e.borderRightWidth > 0) ? (s.borderTopWidth = Math.round(e.borderTopWidth * L) + "px", s.borderBottomWidth = Math.round(e.borderBottomWidth * L) + "px", s.borderLeftWidth = Math.round(e.borderLeftWidth * L) + "px", s.borderRightWidth = Math.round(e.borderRightWidth * L) + "px", s.borderStyle = e.borderStyle, s.borderTopColor = e.borderTopColor, s.borderBottomColor = e.borderBottomColor, s.borderLeftColor = e.borderLeftColor, s.borderRightColor = e.borderRightColor) : ("none" === e.borderStyle && (s.borderStyle = "none"), s.borderTopColor = e.borderTopColor, s.borderBottomColor = e.borderBottomColor, s.borderLeftColor = e.borderLeftColor, s.borderRightColor = e.borderRightColor)), "shape" !== S.type && "image" !== S.type || !(P(e.borderTopLeftRadius) || P(e.borderTopRightRadius) || P(e.borderBottomLeftRadius) || P(e.borderBottomRightRadius)) || (s.overflow = "hidden"), S._isnotext || ("column" !== S.type && (s.fontSize = Math.round(e.fontSize * L) + "px", s.fontWeight = e.fontWeight, s.letterSpacing = e.letterSpacing * L + "px", e.textShadow && (s.textShadow = e.textShadow), e.textStroke && (s["-webkit-text-stroke"] = e.textStroke)), s.lineHeight = Math.round(e.lineHeight * L) + "px", s.textAlign = e.textAlign), "column" === S.type && (void 0 === S.cbg_set && (S.cbg_set = S.styleProps["background-color"], S.cbg_set = "" == S.cbg_set || void 0 === S.cbg_set || 0 == S.cbg_set.length ? "transparent" : S.cbg_set, S.cbg_img = m.css("backgroundImage"), "" !== S.cbg_img && void 0 !== S.cbg_img && "none" !== S.cbg_img && (S.cbg_img_r = m.css("backgroundRepeat"), S.cbg_img_p = m.css("backgroundPosition"), S.cbg_img_s = m.css("backgroundSize")), S.cbg_o = S.bgopacity ? 1 : S.bgopacity, b.backgroundColor = "transparent", b.backgroundImage = ""), s.backgroundColor = "transparent", s.backgroundImage = "none"), S._isstatic && S.elementHovered && (p = m.data("frames")) && p.frame_hover && p.frame_hover.transform) for (g in s) s.hasOwnProperty(g) && p.frame_hover.transform.hasOwnProperty(g) && delete s[g];
        if ("IFRAME" == m[0].nodeName && "html" === o.gA(m[0], "layertype") && (u = "slide" == e.basealign ? o[v].module.width : o.iWA(v, w), h = "slide" == e.basealign ? o[v].module.height : o.iHE(v), s.width = !o.isNumeric(e.width) && e.width.indexOf("%") >= 0 ? !S._isstatic || S._incolumn || S._ingroup ? e.width : u * parseInt(e.width, 0) / 100 : D(e.width, L, "auto", u, "auto"), s.height = !o.isNumeric(e.height) && e.height.indexOf("%") >= 0 ? !S._isstatic || S._incolumn || S._ingroup ? e.height : h * parseInt(e.height, 0) / 100 : D(e.height, L, "auto", u, "auto")), b = jQuery.extend(!0, b, s), "rekursive" != f) {
          u = "slide" == e.basealign ? o[v].module.width : o.iWA(v, w), h = "slide" == e.basealign ? o[v].module.height : o.iHE(v);
          var I = !o.isNumeric(e.width) && e.width.indexOf("%") >= 0 ? !S._isstatic || S._incolumn || S._ingroup ? e.width : u * parseInt(e.width, 0) / 100 : D(e.width, L, "auto", u, "auto"),
            M = !o.isNumeric(e.height) && e.height.indexOf("%") >= 0 ? !S._isstatic || S._incolumn || S._ingroup ? e.height : h * parseInt(e.height, 0) / 100 : D(e.height, L, "auto", u, "auto"),
            T = {
              maxWidth: D(e.maxWidth, L, "none", u, "none"),
              maxHeight: D(e.maxHeight, L, "none", h, "none"),
              minWidth: D(e.minWidth, L, "0px", u, 0),
              minHeight: D(e.minHeight, L, "0px", h, 0),
              height: M,
              width: I,
              overwrite: "auto"
            };
          1 == S.heightSetByVideo && (T.height = S.vidOBJ.height);
          var C = !1;
          if (S._incolumn) {
            for (R = jQuery.extend(!0, R, {
              minWidth: I,
              maxWidth: I,
              float: e.float,
              clear: e.clear
            }), i = 0; i < 4; i++) void 0 !== e["margin" + t[i]] && (R["margin" + t[i]] = e["margin" + t[i]] * L + "px");
            O.width = "100%", void 0 !== e.display && "inline-block" !== e.display || (_ = {
              width: "100%"
            }), T.width = !o.isNumeric(e.width) && e.width.indexOf("%") >= 0 ? "100%" : I, "image" === S.type && tpGS.gsap.set(S.img, {
              width: "100%"
            });
          } else !o.isNumeric(e.width) && e.width.indexOf("%") >= 0 && (R.minWidth = "slide" === S.basealign || !0 === S._ingroup ? I : o.iWA(v, w) * o[v].CM.w * parseInt(I) / 100 + "px", O.width = "100%", _.width = "100%");
          if (!o.isNumeric(e.height) && e.height.indexOf("%") >= 0 && (R.minHeight = "slide" === S.basealign || !0 === S._ingroup ? M : o.iHE(v) * (o[v].currentRowsHeight > o[v].gridheight[o[v].level] ? 1 : o[v].CM.w) * parseInt(M) / 100 + "px", O.height = "100%", _.height = "100%", C = !0), S._isnotext || (T.whiteSpace = e.whiteSpace, T.textAlign = e.textAlign, T.textDecoration = e.textDecoration), "npc" != e.color && void 0 !== e.color && (T.color = e.color), S._ingroup && (S._groupw = T.minWidth, S._grouph = T.minHeight), "row" === S.type && (o.isNumeric(T.minHeight) || T.minHeight.indexOf("px") >= 0) && "0px" !== T.minHeight && 0 !== T.minHeight && "0" !== T.minHeight && "none" !== T.minHeight ? T.height = T.minHeight : "row" === S.type && (T.height = "auto"), S._isstatic && S.elementHovered && (p = m.data("frames")) && p.frame_hover && p.frame_hover.transform) for (g in T) T.hasOwnProperty(g) && p.frame_hover.transform.hasOwnProperty(g) && delete T[g];
          "group" !== S.type && "row" !== S.type && "column" !== S.type && (!o.isNumeric(T.width) && T.width.indexOf("%") >= 0 && (T.width = "100%"), !o.isNumeric(T.height) && T.height.indexOf("%") >= 0 && (T.height = "100%")), S._isgroup && (!o.isNumeric(T.width) && T.width.indexOf("%") >= 0 && (T.width = "100%"), R.height = C ? "100%" : T.height), b = jQuery.extend(!0, b, T), null != S.svg_src && void 0 !== S.svgI && ("string" == typeof S.svgI.fill && (S.svgI.fill = [S.svgI.fill]), S.svgTemp = o.clone(S.svgI), void 0 !== S.svgTemp.fill && (S.svgTemp.fill = S.svgTemp.fill[o[v].level], tpGS.gsap.set(S.svgPath, {
            fill: S.svgI.fill[o[v].level]
          })), tpGS.gsap.set(S.svg, S.svgTemp));
        }
        if ("row" === S.type) for (i = 0; i < 4; i++) void 0 !== e["margin" + t[i]] && (R["padding" + t[i]] = e["margin" + t[i]] * L + "px");
        if ("column" === S.type && S.cbg && S.cbg.length > 0) {
          for (void 0 !== S.cbg_img_s && (S.cbg[0].style.backgroundSize = S.cbg_img_s), s = {}, "" !== S.styleProps.cursor && (s.cursor = S.styleProps.cursor), "" !== S.cbg_set && "transparent" !== S.cbg_set && (s.backgroundColor = S.cbg_set), "" !== S.cbg_img && "none" !== S.cbg_img && (s.backgroundImage = S.cbg_img, "" !== S.cbg_img_r && (s.backgroundRepeat = S.cbg_img_r), "" !== S.cbg_img_p && (s.backgroundPosition = S.cbg_img_p)), "" !== S.cbg_o && void 0 !== S.cbg_o && (s.opacity = S.cbg_o), i = 0; i < 4; i++) void 0 !== e.borderStyle && "none" !== e.borderStyle && (void 0 !== e["border" + t[i] + "Width"] && (s["border" + t[i] + "Width"] = Math.round(parseInt(e["border" + t[i] + "Width"]) * L) + "px"), void 0 !== e["border" + t[i] + "Color"] && (s["border" + t[i] + "Color"] = e["border" + t[i] + "Color"])), e["border" + a[i] + "Radius"] && (s["border" + a[i] + "Radius"] = e["border" + a[i] + "Radius"]);
          for (void 0 !== e.borderStyle && "none" !== e.borderStyle && (s.borderStyle = e.borderStyle), (n = JSON.stringify(s)) !== o[v].emptyObject && n !== S.caches.cbgS && tpGS.gsap.set(S.cbg, s), S.caches.cbgS = n, s = {}, i = 0; i < 4; i++) k["margin" + t[i]] && (s[r[i]] = k["margin" + t[i]] * L + "px");
          (n = JSON.stringify(s)) !== o[v].emptyObject && n !== S.caches.cbgmaskS && (tpGS.gsap.set(S.cbgmask, s), S.caches.cbgmaskS = n);
        }
        "auto" === R.maxWidth && (R.maxWidth = "inherit"), "auto" === R.maxHeight && (R.maxHeight = "inherit"), "auto" === _.maxWidth && (_.maxWidth = "inherit"), "auto" === _.maxHeight && (_.maxHeight = "inherit"), "auto" === O.maxWidth && (O.maxWidth = "inherit"), "auto" === O.maxHeight && (O.maxHeight = "inherit"), void 0 !== S.vidOBJ && (b.width = S.vidOBJ.width, b.height = S.vidOBJ.height), void 0 !== S.OBJUPD.lppmOBJ && (void 0 !== S.OBJUPD.lppmOBJ.minWidth && (O.minWidth = S.OBJUPD.lppmOBJ.minWidth, _.minWidth = S.OBJUPD.lppmOBJ.minWidth, R.minWidth = S.OBJUPD.lppmOBJ.minWidth), void 0 !== S.OBJUPD.lppmOBJ.minHeight && (O.minHeight = S.OBJUPD.lppmOBJ.minHeight, _.minHeight = S.OBJUPD.lppmOBJ.minHeight, R.minHeight = S.OBJUPD.lppmOBJ.minHeight)), n = JSON.stringify(b), d = JSON.stringify(O), l = JSON.stringify(_), c = JSON.stringify(R), void 0 === S.imgOBJ || void 0 !== S.caches.imgOBJ && S.caches.imgOBJ.width === S.imgOBJ.width && S.caches.imgOBJ.height === S.imgOBJ.height && S.caches.imgOBJ.left === S.imgOBJ.left && S.caches.imgOBJ.right === S.imgOBJ.right && S.caches.imgOBJ.top === S.imgOBJ.top && S.caches.imgOBJ.bottom === S.imgOBJ.bottom || (S.caches.imgOBJ = o.clone(S.imgOBJ), S.imgOBJ.position = "relative", tpGS.gsap.set(S.img, S.imgOBJ)), void 0 === S.mediaOBJ || void 0 !== S.caches.mediaOBJ && S.caches.mediaOBJ.width === S.mediaOBJ.width && S.caches.mediaOBJ.height === S.mediaOBJ.height && S.caches.mediaOBJ.display === S.mediaOBJ.display || (S.caches.mediaOBJ = o.clone(S.mediaOBJ), S.media.css(S.mediaOBJ)), n != o[v].emptyObject && n != S.caches.LOBJ && (tpGS.gsap.set(m, b), S.caches.LOBJ = n), d != o[v].emptyObject && d != S.caches.LPOBJ && (tpGS.gsap.set(S.lp, O), S.caches.LPOBJ = d), l != o[v].emptyObject && l != S.caches.MOBJ && (tpGS.gsap.set(S.m, _), S.caches.MOBJ = l), c != o[v].emptyObject && c != S.caches.POBJ && (tpGS.gsap.set(S.p, R), S.caches.POBJ = c, S.caches.POBJ_LEFT = R.left, S.caches.POBJ_TOP = R.top);
      }
    },
    z = function z(e) {
      var i = {
        l: "none",
        lw: 10,
        r: "none",
        rw: 10
      };
      for (var t in e = e.split(";")) if (e.hasOwnProperty(t)) {
        var a = e[t].split(":");
        switch (a[0]) {
          case "l":
            i.l = a[1];
            break;
          case "r":
            i.r = a[1];
            break;
          case "lw":
            i.lw = a[1];
            break;
          case "rw":
            i.rw = a[1];
        }
      }
      return "polygon(" + G(i.l, 0, parseFloat(i.lw)) + "," + G(i.r, 100, 100 - parseFloat(i.rw), !0) + ")";
    },
    G = function G(e, i, t, a) {
      var r;
      switch (e) {
        case "none":
          r = i + "% 100%," + i + "% 0%";
          break;
        case "top":
          r = t + "% 100%," + i + "% 0%";
          break;
        case "middle":
          r = t + "% 100%," + i + "% 50%," + t + "% 0%";
          break;
        case "bottom":
          r = i + "% 100%," + t + "% 0%";
          break;
        case "two":
          r = t + "% 100%," + i + "% 75%," + t + "% 50%," + i + "% 25%," + t + "% 0%";
          break;
        case "three":
          r = i + "% 100%," + t + "% 75%," + i + "% 50%," + t + "% 25%," + i + "% 0%";
          break;
        case "four":
          r = i + "% 100%," + t + "% 87.5%," + i + "% 75%," + t + "% 62.5%," + i + "% 50%," + t + "% 37.5%," + i + "% 25%," + t + "% 12.5%," + i + "% 0%";
          break;
        case "five":
          r = i + "% 100%," + t + "% 90%," + i + "% 80%," + t + "% 70%," + i + "% 60%," + t + "% 50%," + i + "% 40%," + t + "% 30%," + i + "% 20%," + t + "% 10%," + i + "% 0%";
      }
      if (a) {
        var o = r.split(",");
        for (var t in r = "", o) o.hasOwnProperty(t) && (r += o[o.length - 1 - t] + (t < o.length - 1 ? "," : ""));
      }
      return r;
    };
  window.RS_MODULES = window.RS_MODULES || {}, window.RS_MODULES.layeranimation = {
    loaded: !0,
    version: "6.4.0"
  }, window.RS_MODULES.checkMinimal && window.RS_MODULES.checkMinimal();
}(jQuery), function (e) {
  "use strict";

  jQuery.fn.revolution = jQuery.fn.revolution || {};
  var i = jQuery.fn.revolution;
  function t(e, t) {
    var a = new Object({
      single: ".tp-" + t,
      c: i[e].cpar.find(".tp-" + t + "s")
    });
    return a.mask = a.c.find(".tp-" + t + "-mask"), a.wrap = a.c.find(".tp-" + t + "s-inner-wrapper"), a;
  }
  jQuery.extend(!0, i, {
    hideUnHideNav: function hideUnHideNav(e) {
      window.requestAnimationFrame(function () {
        var t = !1;
        c(i[e].navigation.arrows) && (t = S(i[e].navigation.arrows, e, t)), c(i[e].navigation.bullets) && (t = S(i[e].navigation.bullets, e, t)), c(i[e].navigation.thumbnails) && (t = S(i[e].navigation.thumbnails, e, t)), c(i[e].navigation.tabs) && (t = S(i[e].navigation.tabs, e, t)), t && i.manageNavigation(e);
      });
    },
    getOuterNavDimension: function getOuterNavDimension(e) {
      i[e].navigation.scaler = Math.max(0, Math.min(1, (i.winW - 480) / 500));
      var t = {
        left: 0,
        right: 0,
        horizontal: 0,
        vertical: 0,
        top: 0,
        bottom: 0
      };
      return i[e].navigation.thumbnails && i[e].navigation.thumbnails.enable && (i[e].navigation.thumbnails.isVisible = i[e].navigation.thumbnails.hide_under < i[e].module.width && i[e].navigation.thumbnails.hide_over > i[e].module.width, i[e].navigation.thumbnails.cw = Math.max(Math.round(i[e].navigation.thumbnails.width * i[e].navigation.scaler), i[e].navigation.thumbnails.min_width), i[e].navigation.thumbnails.ch = Math.round(i[e].navigation.thumbnails.cw / i[e].navigation.thumbnails.width * i[e].navigation.thumbnails.height), i[e].navigation.thumbnails.isVisible && "outer-left" === i[e].navigation.thumbnails.position ? t.left = i[e].navigation.thumbnails.cw + 2 * i[e].navigation.thumbnails.wrapper_padding : i[e].navigation.thumbnails.isVisible && "outer-right" === i[e].navigation.thumbnails.position ? t.right = i[e].navigation.thumbnails.cw + 2 * i[e].navigation.thumbnails.wrapper_padding : i[e].navigation.thumbnails.isVisible && "outer-top" === i[e].navigation.thumbnails.position ? t.top = i[e].navigation.thumbnails.ch + 2 * i[e].navigation.thumbnails.wrapper_padding : i[e].navigation.thumbnails.isVisible && "outer-bottom" === i[e].navigation.thumbnails.position && (t.bottom = i[e].navigation.thumbnails.ch + 2 * i[e].navigation.thumbnails.wrapper_padding)), i[e].navigation.tabs && i[e].navigation.tabs.enable && (i[e].navigation.tabs.isVisible = i[e].navigation.tabs.hide_under < i[e].module.width && i[e].navigation.tabs.hide_over > i[e].module.width, i[e].navigation.tabs.cw = Math.max(Math.round(i[e].navigation.tabs.width * i[e].navigation.scaler), i[e].navigation.tabs.min_width), i[e].navigation.tabs.ch = Math.round(i[e].navigation.tabs.cw / i[e].navigation.tabs.width * i[e].navigation.tabs.height), i[e].navigation.tabs.isVisible && "outer-left" === i[e].navigation.tabs.position ? t.left += i[e].navigation.tabs.cw + 2 * i[e].navigation.tabs.wrapper_padding : i[e].navigation.tabs.isVisible && "outer-right" === i[e].navigation.tabs.position ? t.right += i[e].navigation.tabs.cw + 2 * i[e].navigation.tabs.wrapper_padding : i[e].navigation.tabs.isVisible && "outer-top" === i[e].navigation.tabs.position ? t.top += i[e].navigation.tabs.ch + 2 * i[e].navigation.tabs.wrapper_padding : i[e].navigation.tabs.isVisible && "outer-bottom" === i[e].navigation.tabs.position && (t.bottom += i[e].navigation.tabs.ch + 2 * i[e].navigation.tabs.wrapper_padding)), {
        left: t.left,
        right: t.right,
        horizontal: t.left + t.right,
        vertical: t.top + t.bottom,
        top: t.top,
        bottom: t.bottom
      };
    },
    resizeThumbsTabs: function resizeThumbsTabs(e, t) {
      if (void 0 !== i[e] && i[e].navigation.use && (i[e].navigation && i[e].navigation.bullets.enable || i[e].navigation && i[e].navigation.tabs.enable || i[e].navigation && i[e].navigation.thumbnails.enable)) {
        var a = tpGS.gsap.timeline(),
          o = i[e].navigation.tabs,
          s = i[e].navigation.thumbnails,
          n = i[e].navigation.bullets;
        if (a.pause(), c(o) && (t || o.width > o.min_width) && r(e, a, i[e].c, o, i[e].slideamount, "tab"), c(s) && (t || s.width > s.min_width) && r(e, a, i[e].c, s, i[e].slideamount, "thumb", e), c(n) && t) {
          var d = i[e].c.find(".tp-bullets");
          d.find(".tp-bullet").each(function (e) {
            var i = jQuery(this),
              t = e + 1,
              a = i.outerWidth() + parseInt(void 0 === n.space ? 0 : n.space, 0),
              r = i.outerHeight() + parseInt(void 0 === n.space ? 0 : n.space, 0);
            "vertical" === n.direction ? (i.css({
              top: (t - 1) * r + "px",
              left: "0px"
            }), d.css({
              height: (t - 1) * r + i.outerHeight(),
              width: i.outerWidth()
            })) : (i.css({
              left: (t - 1) * a + "px",
              top: "0px"
            }), d.css({
              width: (t - 1) * a + i.outerWidth(),
              height: i.outerHeight()
            }));
          });
        }
        a.play();
      }
      return !0;
    },
    updateNavIndexes: function updateNavIndexes(e) {
      var t = i[e].c;
      function a(e) {
        t.find(e).lenght > 0 && t.find(e).each(function (e) {
          jQuery(this).data("liindex", e);
        });
      }
      a("rs-tab"), a("rs-bullet"), a("rs-thumb"), i.resizeThumbsTabs(e, !0), i.manageNavigation(e);
    },
    manageNavigation: function manageNavigation(e, t) {
      i[e].navigation.use && (c(i[e].navigation.bullets) && ("fullscreen" != i[e].sliderLayout && "fullwidth" != i[e].sliderLayout && (i[e].navigation.bullets.h_offset_old = void 0 === i[e].navigation.bullets.h_offset_old ? parseInt(i[e].navigation.bullets.h_offset, 0) : i[e].navigation.bullets.h_offset_old, i[e].navigation.bullets.h_offset = "center" === i[e].navigation.bullets.h_align ? i[e].navigation.bullets.h_offset_old + i[e].outNavDims.left / 2 - i[e].outNavDims.right / 2 : i[e].navigation.bullets.h_offset_old + i[e].outNavDims.left), w(i[e].navigation.bullets, e)), c(i[e].navigation.thumbnails) && w(i[e].navigation.thumbnails, e), c(i[e].navigation.tabs) && w(i[e].navigation.tabs, e), c(i[e].navigation.arrows) && ("fullscreen" != i[e].sliderLayout && "fullwidth" != i[e].sliderLayout && (i[e].navigation.arrows.left.h_offset_old = void 0 === i[e].navigation.arrows.left.h_offset_old ? parseInt(i[e].navigation.arrows.left.h_offset, 0) : i[e].navigation.arrows.left.h_offset_old, i[e].navigation.arrows.left.h_offset = (i[e].navigation.arrows.left.h_align, i[e].navigation.arrows.left.h_offset_old), i[e].navigation.arrows.right.h_offset_old = void 0 === i[e].navigation.arrows.right.h_offset_old ? parseInt(i[e].navigation.arrows.right.h_offset, 0) : i[e].navigation.arrows.right.h_offset_old, i[e].navigation.arrows.right.h_offset = (i[e].navigation.arrows.right.h_align, i[e].navigation.arrows.right.h_offset_old)), w(i[e].navigation.arrows.left, e), w(i[e].navigation.arrows.right, e)), !1 !== t && (c(i[e].navigation.thumbnails) && a(i[e].navigation.thumbnails, e), c(i[e].navigation.tabs) && a(i[e].navigation.tabs, e)));
    },
    showFirstTime: function showFirstTime(e) {
      g(e), i.hideUnHideNav(e);
    },
    selectNavElement: function selectNavElement(e, t, a, r) {
      for (var o = i[e].cpar[0].getElementsByClassName(a), s = 0; s < o.length; s++) i.gA(o[s], "key") === t ? (o[s].classList.add("selected"), void 0 !== r && r()) : o[s].classList.remove("selected");
    },
    transferParams: function transferParams(e, i) {
      if (void 0 !== i) for (var t in i.params) e = e.replace(i.params[t].from, i.params[t].to);
      return e;
    },
    updateNavElementContent: function updateNavElementContent(e, t, r, o, s) {
      if (void 0 !== i[e].pr_next_key || void 0 !== i[e].pr_active_key) {
        var n = void 0 === i[e].pr_next_key ? void 0 === i[e].pr_cache_pr_next_key ? i[e].pr_active_key : i[e].pr_cache_pr_next_key : i[e].pr_next_key,
          d = i.gA(i[e].slides[n], "key"),
          l = 0,
          c = !1;
        for (var p in r.enable && i.selectNavElement(e, d, "tp-bullet"), o.enable && i.selectNavElement(e, d, "tp-thumb", function () {
          a(o, e);
        }), s.enable && i.selectNavElement(e, d, "tp-tab", function () {
          a(s, e);
        }), i[e].thumbs) l = !0 === c ? l : p, c = i[e].thumbs[p].id === d || p == d || c;
        var g = (l = parseInt(l, 0)) > 0 ? l - 1 : i[e].slideamount - 1,
          u = l + 1 == i[e].slideamount ? 0 : l + 1;
        if (!0 === t.enable && t.pi !== g && t.ni !== u) {
          if (t.pi = g, t.ni = u, t.left.c[0].innerHTML = i.transferParams(t.tmp, i[e].thumbs[g]), u > i[e].slideamount) return;
          t.right.c[0].innerHTML = i.transferParams(t.tmp, i[e].thumbs[u]), t.right.iholder = t.right.c.find(".tp-arr-imgholder"), t.left.iholder = t.left.c.find(".tp-arr-imgholder"), t.rtl ? (void 0 !== t.left.iholder[0] && tpGS.gsap.set(t.left.iholder, {
            backgroundImage: "url(" + i[e].thumbs[u].src + ")"
          }), void 0 !== i[e].thumbs[g] && void 0 !== t.right.iholder[0] && tpGS.gsap.set(t.right.iholder, {
            backgroundImage: "url(" + i[e].thumbs[g].src + ")"
          })) : (void 0 !== i[e].thumbs[g] && void 0 !== t.left.iholder[0] && tpGS.gsap.set(t.left.iholder, {
            backgroundImage: "url(" + i[e].thumbs[g].src + ")"
          }), void 0 !== t.right.iholder[0] && tpGS.gsap.set(t.right.iholder, {
            backgroundImage: "url(" + i[e].thumbs[u].src + ")"
          }));
        }
      }
    },
    createNavigation: function createNavigation(e) {
      var a = i[e].navigation.arrows,
        r = i[e].navigation.bullets,
        n = i[e].navigation.thumbnails,
        u = i[e].navigation.tabs,
        m = c(a),
        f = c(r),
        y = c(n),
        S = c(u);
      for (var x in o(e), s(e), m && (v(a, e), a.c = i[e].cpar.find(".tparrows")), i[e].slides) if (i[e].slides.hasOwnProperty(x) && "true" != i.gA(i[e].slides[x], "not_in_nav")) {
        var k = jQuery(i[e].slides[i[e].slides.length - 1 - x]),
          L = jQuery(i[e].slides[x]);
        f && (i[e].navigation.bullets.rtl ? b(i[e].c, r, k, e) : b(i[e].c, r, L, e)), y && (i[e].navigation.thumbnails.rtl ? _(i[e].c, n, k, "tp-thumb", e) : _(i[e].c, n, L, "tp-thumb", e)), S && (i[e].navigation.tabs.rtl ? _(i[e].c, u, k, "tp-tab", e) : _(i[e].c, u, L, "tp-tab", e));
      }
      f && w(r, e), y && w(n, e), S && w(u, e), (y || S) && i.updateDims(e), i[e].navigation.createNavigationDone = !0, y && jQuery.extend(!0, n, t(e, "thumb")), S && jQuery.extend(!0, u, t(e, "tab")), i[e].c.on("revolution.slide.onafterswap revolution.nextslide.waiting", function () {
        i.updateNavElementContent(e, a, r, n, u);
      }), l(a), l(r), l(n), l(u), i[e].cpar.on("mouseenter mousemove", function (t) {
        void 0 !== t.target && void 0 !== t.target.className && "string" == typeof t.target.className && t.target.className.indexOf("rs-waction") >= 0 || !0 !== i[e].tpMouseOver && i[e].firstSlideAvailable && (i[e].tpMouseOver = !0, g(e), i.ISM && !0 !== i[e].someNavIsDragged && (p(i[e].hideAllNavElementTimer), i[e].hideAllNavElementTimer = setTimeout(function () {
          i[e].tpMouseOver = !1, h(e);
        }, 150)));
      }), i[e].cpar.on("mouseleave ", function () {
        i[e].tpMouseOver = !1, h(e);
      }), (y || S || "carousel" === i[e].sliderType || i[e].navigation.touch.touchOnDesktop || i[e].navigation.touch.touchenabled && i.ISM) && d(e), i[e].navigation.initialised = !0, i.updateNavElementContent(e, a, r, n, u), i.showFirstTime(e);
    }
  });
  var a = function a(e, t) {
      if (void 0 !== e && null != e.mask) {
        var a = "vertical" === e.direction ? e.mask.find(e.single).first().outerHeight(!0) + e.space : e.mask.find(e.single).first().outerWidth(!0) + e.space,
          r = "vertical" === e.direction ? e.mask.height() : e.mask.width(),
          o = e.mask.find(e.single + ".selected").data("liindex");
        o = (o = void 0 === (o = e.rtl ? i[t].slideamount - o : o) ? 0 : o) > 0 && 1 === i[t].sdir && e.visibleAmount > 1 ? o - 1 : o;
        var s = r / a,
          n = "vertical" === e.direction ? e.mask.height() : e.mask.width(),
          d = 0 - o * a,
          l = "vertical" === e.direction ? e.wrap.height() : e.wrap.width(),
          c = d < 0 - (l - n) ? 0 - (l - n) : d,
          p = i.gA(e.wrap[0], "offset");
        p = void 0 === p ? 0 : p, s > 2 && (c = d - (p + a) <= 0 ? d - (p + a) < 0 - a ? p : c + a : c, c = d - a + p + r < a && d + (Math.round(s) - 2) * a < p ? d + (Math.round(s) - 2) * a : c), c = "vertical" !== e.direction && e.mask.width() >= e.wrap.width() || "vertical" === e.direction && e.mask.height() >= e.wrap.height() ? 0 : c < 0 - (l - n) ? 0 - (l - n) : c > 0 ? 0 : c, e.c.hasClass("dragged") || ("vertical" === e.direction ? e.wrap.data("tmmove", tpGS.gsap.to(e.wrap, .5, {
          top: c + "px",
          ease: "power3.inOut"
        })) : e.wrap.data("tmmove", tpGS.gsap.to(e.wrap, .5, {
          left: c + "px",
          ease: "power3.inOut"
        })), e.wrap.data("offset", c));
      }
    },
    r = function r(e, t, a, _r2, o, s) {
      var n = a.parent().find(".tp-" + s + "s"),
        d = n.find(".tp-" + s + "s-inner-wrapper"),
        l = n.find(".tp-" + s + "-mask"),
        c = "vertical" === _r2.direction ? _r2.cw : _r2.cw * o + parseFloat(_r2.space) * (o - 1),
        p = "vertical" === _r2.direction ? _r2.ch * o + parseInt(_r2.space) * (o - 1) : _r2.ch,
        g = "vertical" === _r2.direction ? {
          width: _r2.cw + "px"
        } : {
          height: _r2.ch + "px"
        };
      if (t.add(tpGS.gsap.set(n, g)), t.add(tpGS.gsap.set(d, {
        width: c + "px",
        height: p + "px"
      })), "horizontal" === _r2.direction) {
        var u = Math.min(c, _r2.cw * _r2.visibleAmount + parseFloat(_r2.space) * (_r2.visibleAmount - 1));
        t.add(tpGS.gsap.set(l, {
          width: u + "px",
          height: p + "px"
        }));
      } else {
        var h = Math.min(p, _r2.ch * _r2.visibleAmount + parseFloat(_r2.space) * (_r2.visibleAmount - 1));
        t.add(tpGS.gsap.set(l, {
          width: c + "px",
          height: h + "px"
        }));
      }
      null !== d.outerWidth() && (i[e].thumbResized = !0);
      var m = d.find(".tp-" + s);
      return m && jQuery.each(m, function (e, i) {
        "vertical" === _r2.direction ? t.add(tpGS.gsap.set(i, {
          top: e * (_r2.ch + parseInt(void 0 === _r2.space ? 0 : _r2.space, 0)),
          width: _r2.cw + "px",
          height: _r2.ch + "px"
        })) : "horizontal" === _r2.direction && t.add(tpGS.gsap.set(i, {
          left: e * (_r2.cw + parseInt(void 0 === _r2.space ? 0 : _r2.space, 0)),
          width: _r2.cw + "px",
          height: _r2.ch + "px"
        }));
      }), t;
    },
    o = function o(e) {
      !0 === i[e].navigation.keyboardNavigation && i.document.on("keydown", function (t) {
        if ("horizontal" == i[e].navigation.keyboard_direction && 39 == t.keyCode || "vertical" == i[e].navigation.keyboard_direction && 40 == t.keyCode) {
          if (void 0 !== i[e].keydown_time_stamp && new Date().getTime() - i[e].keydown_time_stamp < 1e3) return;
          i[e].sc_indicator = "arrow", i[e].sc_indicator_dir = 0, "carousel" === i[e].sliderType && (i[e].ctNavElement = !0), i.callingNewSlide(e, 1, "carousel" === i[e].sliderType);
        }
        if ("horizontal" == i[e].navigation.keyboard_direction && 37 == t.keyCode || "vertical" == i[e].navigation.keyboard_direction && 38 == t.keyCode) {
          if (void 0 !== i[e].keydown_time_stamp && new Date().getTime() - i[e].keydown_time_stamp < 1e3) return;
          i[e].sc_indicator = "arrow", i[e].sc_indicator_dir = 1, "carousel" === i[e].sliderType && (i[e].ctNavElement = !0), i.callingNewSlide(e, -1, "carousel" === i[e].sliderType);
        }
        i[e].keydown_time_stamp = new Date().getTime();
      });
    },
    s = function s(e) {
      !0 !== i[e].navigation.mouseScrollNavigation && "on" !== i[e].navigation.mouseScrollNavigation && "carousel" !== i[e].navigation.mouseScrollNavigation || i[e].c.on("wheel mousewheel DOMMouseScroll", function (t) {
        var a = function (e) {
            var i = 0;
            return "deltaY" in e || "deltaX" in e ? i = 0 != e.deltaY && -0 != e.deltaY || !(e.deltaX < 0 || e.deltaX > 0) ? e.deltaY : e.deltaX : ("detail" in e && (i = e.detail), "wheelDelta" in e && (i = -e.wheelDelta / 120), "wheelDeltaY" in e && (i = -e.wheelDeltaY / 120)), ((i = navigator.userAgent.match(/mozilla/i) ? 10 * i : i) > 300 || i < -300) && (i /= 10), i;
          }(t.originalEvent),
          r = !1,
          o = 0 == i[e].pr_active_key || 0 == i[e].pr_processing_key,
          s = i[e].pr_active_key == i[e].slideamount - 1 || i[e].pr_processing_key == i[e].slideamount - 1,
          n = void 0 !== i[e].topc ? i[e].topc[0].getBoundingClientRect() : 0 === i[e].canv.height ? i[e].cpar[0].getBoundingClientRect() : i[e].c[0].getBoundingClientRect();
        if ((n.top > 0 && n.bottom < i.winH ? 1 : n.top >= 0 && n.bottom >= i.winH ? (i.winH - n.top) / n.height : n.top <= 0 && n.bottom <= i.winH ? n.bottom / n.height : 1) >= i[e].navigation.wheelViewPort) {
          if ("reverse" == i[e].navigation.mouseScrollReverse) {
            var d = s;
            s = o, o = d;
          }
          if ("carousel" === i[e].sliderType && !1 === i[e].carousel.snap) i.swipeAnimate({
            id: e,
            to: i[e].carousel.slide_offset + 5 * a,
            direction: a < 0 ? "left" : "right",
            easing: "power2.out",
            phase: "move"
          });else {
            var l = a < 0 ? -1 : 1;
            i[e].sc_indicator_dir = "reverse" === i[e].navigation.mouseScrollReverse && l < 0 || "reverse" !== i[e].navigation.mouseScrollReverse && l > 0 ? 0 : 1, "carousel" == i[e].navigation.mouseScrollNavigation || 0 === i[e].sc_indicator_dir && !s || 1 === i[e].sc_indicator_dir && !o ? void 0 === i[e].pr_processing_key && !0 !== i[e].justmouseScrolled ? (i[e].sc_indicator = "arrow", "carousel" === i[e].sliderType && (i[e].ctNavElement = !0), i.callingNewSlide(e, 0 === i[e].sc_indicator_dir ? 1 : -1, "carousel" === i[e].sliderType), i[e].justmouseScrolled = !0, setTimeout(function () {
              i[e].justmouseScrolled = !1;
            }, i[e].navigation.wheelCallDelay)) : delete i[e].sc_indicator_dir : !0 !== i[e].justmouseScrolled && (r = !0);
          }
          return !!r || (t.preventDefault(t), !1);
        }
      });
    },
    n = function n(e, t) {
      var a = !1;
      for (var r in (void 0 === t.path || i.ISM) && (a = function (e, i) {
        for (; e && e !== document; e = e.parentNode) if (e.tagName === i) return e;
        return !1;
      }(t.target, e)), t.path) t.path.hasOwnProperty(r) && t.path[r].tagName === e && (a = !0);
      return a;
    },
    d = function d(e) {
      var t = i[e].carousel,
        a = i.is_android();
      jQuery(".bullet, .bullets, .tp-bullets, .tparrows").addClass("noSwipe"), i[e].navigation.touch = void 0 === i[e].navigation.touch ? {} : i[e].navigation.touch, i[e].navigation.touch.swipe_direction = void 0 === i[e].navigation.touch.swipe_direction ? "horizontal" : i[e].navigation.touch.swipe_direction, i[e].cpar.find(".rs-nav-element").rsswipe({
        allowPageScroll: "vertical",
        triggerOnTouchLeave: !0,
        treshold: i[e].navigation.touch.swipe_treshold,
        fingers: i[e].navigation.touch.swipe_min_touches > 5 ? 1 : i[e].navigation.touch.swipe_min_touches,
        excludedElements: "button, input, select, textarea, .noSwipe, .rs-waction",
        tap: function tap(e, i) {
          if (void 0 !== i) var t = jQuery(i).closest("rs-thumb");
          void 0 !== t && t.length > 0 ? t.trigger("click") : (t = jQuery(i).closest("rs-tab")).length > 0 ? t.trigger("click") : (t = jQuery(i).closest("rs-bullet")).length > 0 && t.trigger("click");
        },
        swipeStatus: function swipeStatus(r, o, s, d, l, c, g) {
          if ("start" !== o && "move" !== o && "end" !== o && "cancel" != o) return !0;
          var h = n("RS-THUMB", r),
            m = n("RS-TAB", r);
          !1 === h && !1 === m && !0 !== (h = "RS-THUMBS-WRAP" === r.target.tagName || "RS-THUMBS" === r.target.tagName || r.target.className.indexOf("tp-thumb-mask") >= 0) && (m = "RS-TABS-WRAP" === r.target.tagName || "RS-TABS" === r.target.tagName || r.target.className.indexOf("tp-tab-mask") >= 0);
          var v = "start" === o ? 0 : a ? g[0].end.x - g[0].start.x : r.pageX - t.screenX,
            f = "start" === o ? 0 : a ? g[0].end.y - g[0].start.y : r.pageY - t.screenY,
            y = h ? ".tp-thumbs" : ".tp-tabs",
            w = h ? ".tp-thumb-mask" : ".tp-tab-mask",
            b = h ? ".tp-thumbs-inner-wrapper" : ".tp-tabs-inner-wrapper",
            _ = h ? ".tp-thumb" : ".tp-tab",
            S = h ? i[e].navigation.thumbnails : i[e].navigation.tabs,
            x = i[e].cpar.find(w),
            k = x.find(b),
            L = S.direction,
            R = "vertical" === L ? k.height() : k.width(),
            O = "vertical" === L ? x.height() : x.width(),
            I = "vertical" === L ? x.find(_).first().outerHeight(!0) + parseFloat(S.space) : x.find(_).first().outerWidth(!0) + parseFloat(S.space),
            M = void 0 === k.data("offset") ? 0 : parseInt(k.data("offset"), 0),
            T = 0;
          switch (o) {
            case "start":
              "vertical" === L && r.preventDefault(), t.screenX = a ? g[0].end.x : r.pageX, t.screenY = a ? g[0].end.y : r.pageY, i[e].cpar.find(y).addClass("dragged"), M = "vertical" === L ? k.position().top : k.position().left, k.data("offset", M), k.data("tmmove") && k.data("tmmove").pause(), i[e].someNavIsDragged = !0, u(e);
              break;
            case "move":
              if (R <= O) return !1;
              T = (T = M + ("vertical" === L ? f : v)) > 0 ? "horizontal" === L ? T - k.width() * (T / k.width() * T / k.width()) : T - k.height() * (T / k.height() * T / k.height()) : T;
              var C = "vertical" === L ? 0 - (k.height() - x.height()) : 0 - (k.width() - x.width());
              T = T < C ? "horizontal" === L ? T + k.width() * (T - C) / k.width() * (T - C) / k.width() : T + k.height() * (T - C) / k.height() * (T - C) / k.height() : T, "vertical" === L ? tpGS.gsap.set(k, {
                top: T + "px"
              }) : tpGS.gsap.set(k, {
                left: T + "px"
              }), p(i[e].hideAllNavElementTimer);
              break;
            case "end":
            case "cancel":
              return T = M + ("vertical" === L ? f : v), T = (T = "vertical" === L ? T < 0 - (k.height() - x.height()) ? 0 - (k.height() - x.height()) : T : T < 0 - (k.width() - x.width()) ? 0 - (k.width() - x.width()) : T) > 0 ? 0 : T, T = Math.abs(d) > I / 10 ? d <= 0 ? Math.floor(T / I) * I : Math.ceil(T / I) * I : d < 0 ? Math.ceil(T / I) * I : Math.floor(T / I) * I, T = (T = "vertical" === L ? T < 0 - (k.height() - x.height()) ? 0 - (k.height() - x.height()) : T : T < 0 - (k.width() - x.width()) ? 0 - (k.width() - x.width()) : T) > 0 ? 0 : T, "vertical" === L ? tpGS.gsap.to(k, .5, {
                top: T + "px",
                ease: "power3.out"
              }) : tpGS.gsap.to(k, .5, {
                left: T + "px",
                ease: "power3.out"
              }), T = T || ("vertical" === L ? k.position().top : k.position().left), k.data("offset", T), k.data("distance", d), i[e].cpar.find(y).removeClass("dragged"), i[e].someNavIsDragged = !1, !0;
          }
        }
      }), ("carousel" !== i[e].sliderType && (i.ISM && i[e].navigation.touch.touchenabled || !0 !== i.ISM && i[e].navigation.touch.touchOnDesktop) || "carousel" === i[e].sliderType && (i.ISM && i[e].navigation.touch.mobileCarousel || !0 !== i.ISM && i[e].navigation.touch.desktopCarousel)) && (i[e].preventClicks = !1, i[e].c.on("click", function (t) {
        i[e].preventClicks && t.preventDefault();
      }), i[e].c.rsswipe({
        allowPageScroll: "vertical",
        triggerOnTouchLeave: !0,
        treshold: i[e].navigation.touch.swipe_treshold,
        fingers: i[e].navigation.touch.swipe_min_touches > 5 ? 1 : i[e].navigation.touch.swipe_min_touches,
        excludedElements: "label, button, input, select, textarea, .noSwipe, .rs-nav-element",
        swipeStatus: function swipeStatus(r, o, s, n, d, l, c) {
          i[e].preventClicks = !0;
          var p = "start" === o ? 0 : a ? c[0].end.x - c[0].start.x : r.pageX - t.screenX,
            g = "start" === o ? 0 : a ? c[0].end.x - c[0].start.y : r.pageY - t.screenY;
          if (!("carousel" === i[e].sliderType && i[e].carousel.wrapwidth > i[e].carousel.maxwidth && "center" !== i[e].carousel.horizontal_align)) {
            if ("carousel" !== i[e].sliderType) {
              if ("end" == o) {
                if (i[e].sc_indicator = "arrow", "horizontal" == i[e].navigation.touch.swipe_direction && "left" == s || "vertical" == i[e].navigation.touch.swipe_direction && "up" == s) return i[e].sc_indicator_dir = 0, i.callingNewSlide(e, 1), !1;
                if ("horizontal" == i[e].navigation.touch.swipe_direction && "right" == s || "vertical" == i[e].navigation.touch.swipe_direction && "down" == s) return i[e].sc_indicator_dir = 1, i.callingNewSlide(e, -1), !1;
              }
              return !0;
            }
            switch ((t.preventSwipe || i.ISM && ("left" === s || "right" === s)) && r.preventDefault(), void 0 !== t.positionanim && t.positionanim.pause(), t.carouselAutomatic = !1, o) {
              case "start":
                clearTimeout(t.swipeMainTimer), t.beforeSwipeOffet = t.slide_offset, t.focusedBeforeSwipe = t.focused, t.beforeDragStatus = i[e].sliderstatus, i[e].c.trigger("stoptimer"), t.swipeStartPos = a ? c[0].start.x : r.pageX, t.swipeStartTime = new Date().getTime(), t.screenX = a ? c[0].end.x : r.pageX, t.screenY = a ? c[0].end.y : r.pageY, void 0 !== t.positionanim && (t.positionanim.pause(), t.carouselAutomatic = !1), t.overpull = "none", t.wrap.addClass("dragged");
                break;
              case "move":
                if ("left" !== s && "right" !== s || (t.preventSwipe = !0), t.justDragged = !0, Math.abs(p) >= 10 || i[e].carousel.isDragged) {
                  if (i[e].carousel.isDragged = !0, i[e].c.find(".rs-waction").addClass("tp-temporarydisabled"), t.CACHE_slide_offset = t.beforeSwipeOffet + p, !t.infinity) {
                    var u = "center" === t.horizontal_align ? (t.wrapwidth / 2 - t.slide_width / 2 - t.CACHE_slide_offset) / t.slide_width : (0 - t.CACHE_slide_offset) / t.slide_width;
                    "none" !== t.overpull && 0 !== t.overpull || !(u < 0 || u > i[e].slideamount - 1) ? u >= 0 && u <= i[e].slideamount - 1 && (u >= 0 && p > t.overpull || u <= i[e].slideamount - 1 && p < t.overpull) && (t.overpull = 0) : t.overpull = p, t.CACHE_slide_offset = u < 0 ? t.CACHE_slide_offset + (t.overpull - p) / 1.5 + Math.sqrt(Math.abs((t.overpull - p) / 1.5)) : u > i[e].slideamount - 1 ? t.CACHE_slide_offset + (t.overpull - p) / 1.5 - Math.sqrt(Math.abs((t.overpull - p) / 1.5)) : t.CACHE_slide_offset;
                  }
                  i.swipeAnimate({
                    id: e,
                    to: t.CACHE_slide_offset,
                    direction: s,
                    easing: "power2.out",
                    phase: "move"
                  });
                }
                break;
              case "end":
              case "cancel":
                if (clearTimeout(t.swipeMainTimer), t.swipeMainTimer = setTimeout(function () {
                  t.preventSwipe = !1;
                }, 500), i[e].carousel.isDragged = !1, t.wrap.removeClass("dragged"), t.swipeEndPos = a ? c[0].end.x : r.pageX, t.swipeEndTime = new Date().getTime(), t.swipeDuration = t.swipeEndTime - t.swipeStartTime, t.swipeDistance = i.ISM ? t.swipeEndPos - t.swipeStartPos : (t.swipeEndPos - t.swipeStartPos) / 1.5, t.swipePower = t.swipeDistance / t.swipeDuration, t.CACHE_slide_offset = t.slide_offset + t.swipeDistance * Math.abs(t.swipePower), Math.abs(p) < 5 && Math.abs(g) < 5) break;
                i.swipeAnimate({
                  id: e,
                  to: t.CACHE_slide_offset,
                  direction: s,
                  fix: !0,
                  newSlide: !0,
                  easing: "power2.out",
                  phase: "end"
                }), "playing" === t.beforeDragStatus && i[e].c.trigger("restarttimer"), setTimeout(function () {
                  i[e].c.find(".rs-waction").removeClass("tp-temporarydisabled");
                }, 19);
            }
          }
        },
        tap: function tap() {
          i[e].preventClicks = !1;
        }
      })), "carousel" === i[e].sliderType && (i.ISM && 0 == i[e].navigation.touch.mobileCarousel || !0 !== i.ISM && !1 === i[e].navigation.touch.desktopCarousel) && t.wrap.addClass("noswipe"), i[e].navigation.touch.drag_block_vertical && i[e].c.addClass("disableVerticalScroll");
    },
    l = function l(e) {
      e.hide_delay = i.isNumeric(parseInt(e.hide_delay, 0)) ? e.hide_delay : .2, e.hide_delay_mobile = i.isNumeric(parseInt(e.hide_delay_mobile, 0)) ? e.hide_delay_mobile : .2;
    },
    c = function c(e) {
      return e && e.enable;
    },
    p = function p(e) {
      clearTimeout(e);
    },
    g = function g(e) {
      var t = i[e].navigation.maintypes;
      for (var a in t) t.hasOwnProperty(a) && c(i[e].navigation[t[a]]) && void 0 !== i[e].navigation[t[a]].c && (p(i[e].navigation[t[a]].showCall), i[e].navigation[t[a]].showCall = setTimeout(function (t) {
        p(t.hideCall), t.hide_onleave && !0 !== i[e].tpMouseOver || (void 0 === t.tween ? t.tween = m(t) : t.tween.play());
      }, i[e].navigation[t[a]].hide_onleave && !0 !== i[e].tpMouseOver ? 0 : parseInt(i[e].navigation[t[a]].animDelay), i[e].navigation[t[a]]));
    },
    u = function u(e) {
      var t = i[e].navigation.maintypes;
      for (var a in t) t.hasOwnProperty(a) && void 0 !== i[e].navigation[t[a]] && i[e].navigation[t[a]].hide_onleave && c(i[e].navigation[t[a]]) && p(i[e].navigation[t[a]].hideCall);
    },
    h = function h(e, t) {
      var a = i[e].navigation.maintypes;
      for (var r in a) a.hasOwnProperty(r) && void 0 !== i[e].navigation[a[r]] && i[e].navigation[a[r]].hide_onleave && c(i[e].navigation[a[r]]) && (p(i[e].navigation[a[r]].hideCall), i[e].navigation[a[r]].hideCall = setTimeout(function (e) {
        p(e.showCall), e.tween && e.tween.reverse();
      }, i.ISM ? parseInt(i[e].navigation[a[r]].hide_delay_mobile, 0) : parseInt(i[e].navigation[a[r]].hide_delay, 0), i[e].navigation[a[r]]));
    },
    m = function m(e) {
      e.speed = void 0 === e.animSpeed ? .5 : e.animSpeed, e.anims = [], void 0 !== e.anim && void 0 === e.left && e.anims.push(e.anim), void 0 !== e.left && e.anims.push(e.left.anim), void 0 !== e.right && e.anims.push(e.right.anim);
      var i = tpGS.gsap.timeline();
      for (var t in i.add(tpGS.gsap.to(e.c, e.speed, {
        delay: e.animDelay,
        opacity: 1,
        ease: "power3.inOut"
      }), 0), e.anims) if (e.anims.hasOwnProperty(t)) switch (e.anims[t]) {
        case "left":
          i.add(tpGS.gsap.fromTo(e.c[t], e.speed, {
            marginLeft: -50
          }, {
            delay: e.animDelay,
            marginLeft: 0,
            ease: "power3.inOut"
          }), 0);
          break;
        case "right":
          i.add(tpGS.gsap.fromTo(e.c[t], e.speed, {
            marginLeft: 50
          }, {
            delay: e.animDelay,
            marginLeft: 0,
            ease: "power3.inOut"
          }), 0);
          break;
        case "top":
          i.add(tpGS.gsap.fromTo(e.c[t], e.speed, {
            marginTop: -50
          }, {
            delay: e.animDelay,
            marginTop: 0,
            ease: "power3.inOut"
          }), 0);
          break;
        case "bottom":
          i.add(tpGS.gsap.fromTo(e.c[t], e.speed, {
            marginTop: 50
          }, {
            delay: e.animDelay,
            marginTop: 0,
            ease: "power3.inOut"
          }), 0);
          break;
        case "zoomin":
          i.add(tpGS.gsap.fromTo(e.c[t], e.speed, {
            scale: .5
          }, {
            delay: e.animDelay,
            scale: 1,
            ease: "power3.inOut"
          }), 0);
          break;
        case "zoomout":
          i.add(tpGS.gsap.fromTo(e.c[t], e.speed, {
            scale: 1.2
          }, {
            delay: e.animDelay,
            scale: 1,
            ease: "power3.inOut"
          }), 0);
      }
      return i.play(), i;
    },
    v = function v(e, t) {
      e.style = void 0 === e.style ? "" : e.style, e.left.style = void 0 === e.left.style ? "" : e.left.style, e.right.style = void 0 === e.right.style ? "" : e.right.style, void 0 === e.left.c && (e.left.c = jQuery('<rs-arrow style="opacity:0" class="tp-leftarrow tparrows ' + e.style + " " + e.left.style + '">' + e.tmp + "</rs-arrow>"), i[t].c.append(e.left.c)), void 0 === e.right.c && (e.right.c = jQuery('<rs-arrow style="opacity:0"  class="tp-rightarrow tparrows ' + e.style + " " + e.right.style + '">' + e.tmp + "</rs-arrow>"), i[t].c.append(e.right.c)), e[e.rtl ? "left" : "right"].c.on("click", function () {
        "carousel" === i[t].sliderType && (i[t].ctNavElement = !0), i[t].sc_indicator = "arrow", i[t].sc_indicator_dir = 0, i[t].c.revnext();
      }), e[e.rtl ? "right" : "left"].c.on("click", function () {
        "carousel" === i[t].sliderType && (i[t].ctNavElement = !0), i[t].sc_indicator = "arrow", i[t].sc_indicator_dir = 1, i[t].c.revprev();
      }), e.padding_top = parseInt(i[t].carousel.padding_top || 0, 0), e.padding_bottom = parseInt(i[t].carousel.padding_bottom || 0, 0), w(e.left, t), w(e.right, t), "outer-left" != e.position && "outer-right" != e.position || (i[t].outernav = !0);
    },
    f = function f(e, t, a, r) {
      r = void 0 === r ? e.outerHeight(!0) : r;
      var o = null == i[a] ? 0 : 0 == i[a].canv.height ? i[a].module.height : i[a].canv.height,
        s = "layergrid" == t.container ? "fullscreen" == i[a].sliderLayout ? i[a].module.height / 2 - i[a].gridheight[i[a].level] * i[a].CM.h / 2 : i[a].autoHeight || null != i[a].minHeight && i[a].minHeight > 0 ? o / 2 - i[a].gridheight[i[a].level] * i[a].CM.h / 2 : 0 : 0,
        n = "top" === t.v_align ? {
          top: "0px",
          y: Math.round(t.v_offset + s) + "px"
        } : "center" === t.v_align ? {
          top: "50%",
          y: Math.round(0 - r / 2 + t.v_offset) + "px"
        } : {
          top: "100%",
          y: Math.round(0 - (r + t.v_offset + s)) + "px"
        };
      e.hasClass("outer-bottom") || tpGS.gsap.set(e, n);
    },
    y = function y(e, t, a, r) {
      r = void 0 === r ? e.outerWidth() : r;
      var o = "layergrid" === t.container ? i[a].module.width / 2 - i[a].gridwidth[i[a].level] * i[a].CM.w / 2 : 0,
        s = "left" === t.h_align ? {
          left: "0px",
          x: Math.round(t.h_offset + o) + "px"
        } : "center" === t.h_align ? {
          left: "50%",
          x: Math.round(0 - r / 2 + t.h_offset) + "px"
        } : {
          left: "100%",
          x: Math.round(0 - (r + t.h_offset + o)) + "px"
        };
      tpGS.gsap.set(e, s);
    },
    w = function w(e, t) {
      if (null != e && void 0 !== e.c) {
        var a = "fullwidth" == i[t].sliderLayout || "fullscreen" == i[t].sliderLayout ? i[t].module.width : i[t].canv.width,
          r = e.c.outerWidth(),
          o = e.c.outerHeight();
        if (!(r <= 0 || o <= 0) && (f(e.c, e, t, o), y(e.c, e, t, r), "outer-left" === e.position ? tpGS.gsap.set(e.c, {
          left: 0 - r + "px",
          x: e.h_offset + "px"
        }) : "outer-right" === e.position && tpGS.gsap.set(e.c, {
          right: 0 - r + "px",
          x: e.h_offset + "px"
        }), "tp-thumb" === e.type || "tp-tab" === e.type)) {
          var s = parseInt(e.padding_top || 0, 0),
            n = parseInt(e.padding_bottom || 0, 0),
            d = {},
            l = {};
          e.maxw > a && "outer-left" !== e.position && "outer-right" !== e.position ? (d.left = "0px", d.x = 0, d.maxWidth = a - 2 * e.wpad + "px", l.maxWidth = a - 2 * e.wpad + "px") : (d.maxWidth = e.maxw, l.maxWidth = a + "px"), e.maxh + 2 * e.wpad > i[t].conh && "outer-bottom" !== e.position && "outer-top" !== e.position ? (d.top = "0px", d.y = 0, d.maxHeight = s + n + (i[t].conh - 2 * e.wpad) + "px", l.maxHeight = s + n + (i[t].conh - 2 * e.wpad) + "px") : (d.maxHeight = e.maxh + "px", l.maxHeight = e.maxh + "px"), e.mask = void 0 === e.mask ? e.c.find("rs-navmask") : e.mask, (e.mhoff > 0 || e.mvoff > 0) && (l.padding = e.mvoff + "px " + e.mhoff + "px"), e.span ? ("layergrid" == e.container && "outer-left" !== e.position && "outer-right" !== e.position && (s = n = 0), "vertical" === e.direction ? (d.maxHeight = s + n + (i[t].conh - 2 * e.wpad) + "px", d.height = s + n + (i[t].conh - 2 * e.wpad) + "px", d.top = 0, d.y = 0, l.maxHeight = s + n + Math.min(e.maxh, i[t].conh - 2 * e.wpad) + "px", tpGS.gsap.set(e.c, d), tpGS.gsap.set(e.mask, l), f(e.mask, e, t)) : "horizontal" === e.direction && (d.maxWidth = "100%", d.width = a - 2 * e.wpad + "px", d.left = 0, d.x = 0, l.maxWidth = e.maxw >= a ? "100%" : Math.min(e.maxw, a) + "px", tpGS.gsap.set(e.c, d), tpGS.gsap.set(e.mask, l), y(e.mask, e, t))) : (tpGS.gsap.set(e.c, d), tpGS.gsap.set(e.mask, l));
        }
      }
    },
    b = function b(e, t, a, r) {
      0 === e.find(".tp-bullets").length && (t.style = void 0 === t.style ? "" : t.style, t.c = jQuery('<rs-bullets style="opacity:0"  class="tp-bullets ' + t.style + " " + t.direction + " nav-pos-hor-" + t.h_align + " nav-pos-ver-" + t.v_align + " nav-dir-" + t.direction + '"></rs-bullets>'));
      var o = a.data("key"),
        s = t.tmp;
      void 0 !== i[r].thumbs[a.index()] && jQuery.each(i[r].thumbs[a.index()].params, function (e, i) {
        s = s.replace(i.from, i.to);
      });
      var n = jQuery('<rs-bullet data-key="' + o + '" class="tp-bullet">' + s + "</rs-bullet>");
      void 0 !== i[r].thumbs[a.index()] && n.find(".tp-bullet-image").css({
        backgroundImage: "url(" + i[r].thumbs[a.index()].src + ")"
      }), t.c.append(n), e.append(t.c);
      var d = t.c.find(".tp-bullet").length,
        l = n.outerWidth(),
        c = n.outerHeight(),
        p = l + parseInt(void 0 === t.space ? 0 : t.space, 0),
        g = c + parseInt(void 0 === t.space ? 0 : t.space, 0);
      "vertical" === t.direction ? (n.css({
        top: (d - 1) * g + "px",
        left: "0px"
      }), t.c.css({
        height: (d - 1) * g + c,
        width: l
      })) : (n.css({
        left: (d - 1) * p + "px",
        top: "0px"
      }), t.c.css({
        width: (d - 1) * p + l,
        height: c
      })), n.on("click", function () {
        "carousel" === i[r].sliderType && (i[r].ctNavElement = !0), i[r].sc_indicator = "bullet", e.revcallslidewithid(o), e.find(".tp-bullet").removeClass("selected"), jQuery(this).addClass("selected");
      }), t.padding_top = parseInt(i[r].carousel.padding_top || 0, 0), t.padding_bottom = parseInt(i[r].carousel.padding_bottom || 0, 0), "outer-left" != t.position && "outer-right" != t.position || (i[r].outernav = !0);
    },
    _ = function _(e, t, a, r, o) {
      var s = "tp-thumb" === r ? ".tp-thumbs" : ".tp-tabs",
        n = "tp-thumb" === r ? ".tp-thumb-mask" : ".tp-tab-mask",
        d = "tp-thumb" === r ? ".tp-thumbs-inner-wrapper" : ".tp-tabs-inner-wrapper",
        l = "tp-thumb" === r ? ".tp-thumb" : ".tp-tab",
        c = "tp-thumb" === r ? ".tp-thumb-image" : ".tp-tab-image",
        p = "tp-thumb" === r ? "rs-thumb" : "rs-tab";
      t.type = r, t.visibleAmount = t.visibleAmount > i[o].slideamount ? i[o].slideamount : t.visibleAmount, t.sliderLayout = i[o].sliderLayout, void 0 === t.c && (t.wpad = t.wrapper_padding, t.c = jQuery("<" + p + 's style="opacity:0" class="nav-dir-' + t.direction + " nav-pos-ver-" + t.v_align + " nav-pos-hor-" + t.h_align + " rs-nav-element " + r + "s " + (!0 === t.span ? "tp-span-wrapper" : "") + " " + t.position + " " + (void 0 === t.style ? "" : t.style) + '"><rs-navmask class="' + r + '-mask" style="overflow:hidden;position:relative"><' + p + 's-wrap class="' + r + 's-inner-wrapper" style="position:relative;"></' + p + "s-wrap></rs-navmask></" + p + "s>"), t.c.css({
        overflow: "visible",
        position: "outer-top" === t.position || "outer-bottom" === t.position ? "relative" : "absolute",
        background: t.wrapper_color,
        padding: t.wpad + "px",
        boxSizing: "contet-box"
      }), "outer-top" === t.position ? e.parent().prepend(t.c) : "outer-bottom" === t.position ? e.after(t.c) : e.append(t.c), "outer-left" !== t.position && "outer-right" !== t.position || tpGS.gsap.set(i[o].c, {
        overflow: "visible"
      }), t.padding_top = parseInt(i[o].carousel.padding_top || 0, 0), t.padding_bottom = parseInt(i[o].carousel.padding_bottom || 0, 0), "outer-left" != t.position && "outer-right" != t.position || (i[o].outernav = !0));
      var g = a.data("key"),
        u = t.c.find(n),
        h = u.find(d),
        m = t.tmp;
      t.space = parseFloat(t.space) || 0, t.maxw = "horizontal" === t.direction ? t.width * t.visibleAmount + t.space * (t.visibleAmount - 1) : t.width, t.maxh = "horizontal" === t.direction ? t.height : t.height * t.visibleAmount + t.space * (t.visibleAmount - 1), t.maxw += 2 * t.mhoff, t.maxh += 2 * t.mvoff, void 0 !== i[o].thumbs[a.index()] && jQuery.each(i[o].thumbs[a.index()].params, function (e, i) {
        m = m.replace(i.from, i.to);
      });
      var v = jQuery("<" + p + ' data-liindex="' + a.index() + '" data-key="' + g + '" class="' + r + '" style="width:' + t.width + "px;height:" + t.height + 'px;">' + m + "<" + p + ">");
      void 0 !== i[o].thumbs[a.index()] && v.find(c).css({
        backgroundImage: "url(" + i[o].thumbs[a.index()].src + ")"
      }), h.append(v);
      var f = t.c.find(l).length,
        y = v.outerWidth(),
        w = v.outerHeight(),
        b = y + parseInt(void 0 === t.space ? 0 : t.space, 0),
        _ = w + parseInt(void 0 === t.space ? 0 : t.space, 0);
      "vertical" === t.direction ? (v.css({
        top: (f - 1) * _ + "px",
        left: "0px"
      }), h.css({
        height: (f - 1) * _ + w,
        width: y
      })) : (v.css({
        left: (f - 1) * b + "px",
        top: "0px"
      }), h.css({
        width: (f - 1) * b + y,
        height: w
      })), u.css({
        maxWidth: t.maxw + "px",
        maxHeight: t.maxh + "px"
      }), t.c.css({
        maxWidth: t.maxw + "px",
        maxHeight: t.maxh + "px"
      }), v.on("click", function () {
        i[o].sc_indicator = "bullet", "carousel" === i[o].sliderType && (i[o].ctNavElement = !0);
        var t = e.parent().find(d).data("distance");
        t = void 0 === t ? 0 : t, Math.abs(t) < 10 && (e.revcallslidewithid(g), e.parent().find(s).removeClass("selected"), jQuery(this).addClass("selected"));
      });
    },
    S = function S(e, t, a) {
      return null == e || void 0 === e.c ? a : (e.hide_under > i[t].canv.width || i[t].canv.width > e.hide_over ? (!0 !== e.tpForceNotVisible && (e.c.addClass("tp-forcenotvisible"), e.isVisible = !1, a = !0), e.tpForceNotVisible = !0) : (!1 !== e.tpForceNotVisible && (e.c.removeClass("tp-forcenotvisible"), e.isVisible = !0, a = !0), e.tpForceNotVisible = !1), a);
    };
  window.RS_MODULES = window.RS_MODULES || {}, window.RS_MODULES.navigation = {
    loaded: !0,
    version: "6.3.2"
  }, window.RS_MODULES.checkMinimal && window.RS_MODULES.checkMinimal();
}(jQuery), function (e) {
  "use strict";

  window._R_is_Editor ? RVS._R = void 0 === RVS._R ? {} : RVS._R : window._R_is_Editor = !1, jQuery.fn.revolution = jQuery.fn.revolution || {};
  var i = _R_is_Editor ? RVS._R : jQuery.fn.revolution;
  jQuery.extend(!0, i, {
    bgW: function bgW(e, t) {
      return _R_is_Editor ? RVS.RMD.width : "carousel" === i[e].sliderType ? i[e].justifyCarousel ? i[e].carousel.slide_widths[void 0 !== t ? t : i[e].carousel.focused] : i[e].carousel.slide_width : i[e].module.width;
    },
    bgH: function bgH(e, t) {
      return _R_is_Editor ? RVS.RMD.height : "carousel" === i[e].sliderType ? i[e].carousel.slide_height : i[e].module.height;
    },
    getPZSides: function getPZSides(e, i, t, a, r, o, s) {
      var n = e * t,
        d = i * t,
        l = Math.abs(a - n),
        c = Math.abs(r - d),
        p = new Object();
      return p.l = (0 - o) * l, p.r = p.l + n, p.t = (0 - s) * c, p.b = p.t + d, p.h = o, p.v = s, p;
    },
    getPZCorners: function getPZCorners(e, t, a, r) {
      var o = e.bgposition.split(" ") || "center center",
        s = "center" == o[0] ? "50%" : "left" == o[0] || "left" == o[1] ? "0%" : "right" == o[0] || "right" == o[1] ? "100%" : o[0],
        n = "center" == o[1] ? "50%" : "top" == o[0] || "top" == o[1] ? "0%" : "bottom" == o[0] || "bottom" == o[1] ? "100%" : o[1];
      s = parseInt(s, 0) / 100 || 0, n = parseInt(n, 0) / 100 || 0;
      var d = new Object();
      return d.start = i.getPZSides(r.start.width, r.start.height, r.start.scale, t, a, s, n), d.end = i.getPZSides(r.start.width, r.start.height, r.end.scale, t, a, s, n), d;
    },
    getPZValues: function getPZValues(e) {
      var i = e.panzoom.split(";"),
        t = {
          duration: 10,
          ease: "none",
          scalestart: 1,
          scaleend: 1,
          rotatestart: .01,
          rotateend: 0,
          blurstart: 0,
          blurend: 0,
          offsetstart: "0/0",
          offsetend: "0/0"
        };
      for (var a in i) if (i.hasOwnProperty(a)) {
        var r = i[a].split(":"),
          o = r[0],
          s = r[1];
        switch (o) {
          case "d":
            t.duration = parseInt(s, 0) / 1e3;
            break;
          case "e":
            t.ease = s;
            break;
          case "ss":
            t.scalestart = parseInt(s, 0) / 100;
            break;
          case "se":
            t.scaleend = parseInt(s, 0) / 100;
            break;
          case "rs":
            t.rotatestart = parseInt(s, 0);
            break;
          case "re":
            t.rotateend = parseInt(s, 0);
            break;
          case "bs":
            t.blurstart = parseInt(s, 0);
            break;
          case "be":
            t.blurend = parseInt(s, 0);
            break;
          case "os":
            t.offsetstart = s;
            break;
          case "oe":
            t.offsetend = s;
        }
      }
      return t.offsetstart = t.offsetstart.split("/") || [0, 0], t.offsetend = t.offsetend.split("/") || [0, 0], t.rotatestart = 0 === t.rotatestart ? .01 : t.rotatestart, e.panvalues = t, e.bgposition = "center center" == e.bgposition ? "50% 50%" : e.bgposition, t;
    },
    pzCalcL: function pzCalcL(e, t, a) {
      var r,
        o,
        s,
        n,
        d,
        l,
        c = void 0 === a.panvalues ? jQuery.extend(!0, {}, i.getPZValues(a)) : jQuery.extend(!0, {}, a.panvalues),
        p = c.offsetstart,
        g = c.offsetend,
        u = {
          start: {
            width: e,
            height: _R_is_Editor ? e / a.loadobj.width * a.loadobj.height : e / a.owidth * a.oheight,
            rotation: Math.PI / 180 * c.rotatestart,
            rotationV: c.rotatestart,
            scale: c.scalestart,
            transformOrigin: "0% 0%"
          },
          end: {
            rotation: Math.PI / 180 * c.rotateend,
            rotationV: c.rotateend,
            scale: c.scaleend
          }
        };
      c.scalestart, a.owidth, a.oheight, c.scaleend, a.owidth, a.oheight;
      return u.start.height < t && (l = t / u.start.height, u.start.height = t, u.start.width = u.start.width * l), .01 === c.rotatestart && 0 === c.rotateend && (delete u.start.rotation, delete u.end.rotation), r = i.getPZCorners(a, e, t, u), p[0] = parseFloat(p[0]) + r.start.l, g[0] = parseFloat(g[0]) + r.end.l, p[1] = parseFloat(p[1]) + r.start.t, g[1] = parseFloat(g[1]) + r.end.t, o = r.start.r - r.start.l, s = r.start.b - r.start.t, n = r.end.r - r.end.l, d = r.end.b - r.end.t, p[0] = p[0] > 0 ? 0 : o + p[0] < e ? e - o : p[0], g[0] = g[0] > 0 ? 0 : n + g[0] < e ? e - n : g[0], p[1] = p[1] > 0 ? 0 : s + p[1] < t ? t - s : p[1], g[1] = g[1] > 0 ? 0 : d + g[1] < t ? t - d : g[1], u.start.x = p[0], u.start.y = p[1], u.end.x = g[0], u.end.y = g[1], u.end.ease = c.ease, u;
    },
    pzDrawShadow: function pzDrawShadow(e, t, a) {
      "animating" !== t.currentState && null != t.panFake || (t.shadowCTX.clearRect(0, 0, t.shadowCanvas.width, t.shadowCanvas.height), t.shadowCTX.save(), void 0 !== a.rotation ? t.shadowCTX.transform(Math.cos(a.rotation) * a.scale, Math.sin(a.rotation) * a.scale, Math.sin(a.rotation) * -a.scale, Math.cos(a.rotation) * a.scale, a.x, a.y) : t.shadowCTX.transform(a.scale, 0, 0, a.scale, a.x, a.y), t.shadowCTX.drawImage(t.loadobj.img, 0, 0, a.width, a.height), t.shadowCTX.restore()), "animating" !== t.currentState ? null != t.panFake ? (t.panFake.visible || (t.panFake.visible = !0, t.panFake.img.style.opacity = 1, t.canvas.style.opacity = 0), tpGS.gsap.set(t.panFake.img, {
        width: a.width,
        height: a.height,
        force3D: !0,
        x: a.x,
        y: a.y,
        transformOrigin: "0% 0%",
        rotationZ: a.rotationV + "deg",
        scale: a.scale
      }), void 0 !== a.blur && (t.panFake.img.style.filter = 0 === a.blur ? "none" : "blur(" + a.blur + "px)")) : (i.updateSlideBGs(e, a.slidekey, t, !0), void 0 !== a.blur && (t.canvas.style.filter = 0 === a.blur ? "none" : "blur(" + a.blur + "px)")) : (void 0 !== t.panFake && !1 !== t.panFake.visible && (t.panFake.visible = !1, t.panFake.img.style.opacity = 0, t.canvas.style.opacity = 1, t.panFake.img.style.filter = "none"), void 0 !== a.blur && t.canvasFilter ? t.canvasFilterBlur = a.blur : t.canvas.style.filter = 0 === a.blur ? "none" : "blur(" + a.blur + "px)");
    },
    startPanZoom: function startPanZoom(e, t, a, r, o, s) {
      var n = _R_is_Editor ? e : e.data();
      if (void 0 !== n.panzoom && null !== n.panzoom) {
        var d = _R_is_Editor ? n : i[t].sbgs[s];
        _R_is_Editor || "carousel" !== i[t].sliderType || (i[t].carousel.justify && void 0 === i[t].carousel.slide_widths && i.setCarouselDefaults(t, !0), i[t].carousel.justify || (void 0 === i[t].carousel.slide_width && (i[t].carousel.slide_width = !0 !== i[t].carousel.stretch ? i[t].gridwidth[i[t].level] * (0 === i[t].CM.w ? 1 : i[t].CM.w) : i[t].canv.width), void 0 === i[t].carousel.slide_height && (i[t].carousel.slide_height = !0 !== i[t].carousel.stretch ? i[t].gridheight[i[t].level] * (0 === i[t].CM.w ? 1 : i[t].CM.w) : i[t].canv.height)));
        var l,
          c = i.getmDim(t, r, d),
          p = i.pzCalcL(c.width, c.height, n);
        _R_is_Editor || (i[t].panzoomTLs = void 0 === i[t].panzoomTLs ? {} : i[t].panzoomTLs, i[t].panzoomBGs = void 0 === i[t].panzoomBGs ? {} : i[t].panzoomBGs, void 0 === i[t].panzoomBGs[r] && (i[t].panzoomBGs[r] = e), l = i[t].panzoomTLs[r]), a = a || 0, void 0 !== l && (l.pause(), l.kill(), l = void 0), l = tpGS.gsap.timeline({
          paused: !0
        }), n.panvalues.duration = NaN === n.panvalues.duration || void 0 === n.panvalues.duration ? 10 : n.panvalues.duration, _R_is_Editor || void 0 === n || void 0 === d || (d.panvalues = n.panvalues), void 0 !== d && (void 0 === d.shadowCanvas && (d.shadowCanvas = document.createElement("canvas"), d.shadowCTX = d.shadowCanvas.getContext("2d"), d.shadowCanvas.style.background = "transparent", d.shadowCanvas.style.opacity = 1), d.shadowCanvas.width = c.width, d.shadowCanvas.height = c.height, p.slideindex = r, p.slidekey = _R_is_Editor ? void 0 : s, p.start.slidekey = p.slidekey, i.pzDrawShadow(t, d, p.start), p.end.onUpdate = function () {
          i.pzDrawShadow(t, d, p.start);
        }, d.panStart = jQuery.extend(!0, {}, p.start), void 0 === n.panvalues.blurstart || void 0 === n.panvalues.blurend || 0 === n.panvalues.blurstart && 0 === n.panvalues.blurend || (p.start.blur = n.panvalues.blurstart, p.end.blur = n.panvalues.blurend), (!_R_is_Editor && void 0 === p.start.blur || window.isSafari11 && i.ISM) && (d.panFake = void 0 === d.panFake ? {
          img: d.loadobj.img.cloneNode(!0)
        } : d.panFake, void 0 !== d.panFake && (!0 !== d.panFake.appended && (d.panFake.appended = !0, d.sbg.appendChild(d.panFake.img), d.panFake.img.style.position = "absolute", d.panFake.img.style.display = "block", d.panFake.img.style.zIndex = 0, d.panFake.img.style.opacity = 0, d.panFake.img.style.top = "0px", d.panFake.img.style.left = "0px"), d.panFake.img.width = p.start.width, d.panFake.img.height = p.start.height)), l.add(tpGS.gsap.to(p.start, n.panvalues.duration, p.end), 0), l.progress(a), "play" !== o && "first" !== o || l.play(), _R_is_Editor ? RVS.TL[RVS.S.slideId].panzoom = l : i[t].panzoomTLs[r] = l);
      }
    }
  }), window.RS_MODULES = window.RS_MODULES || {}, window.RS_MODULES.panzoom = {
    loaded: !0,
    version: "6.5.4"
  }, window.RS_MODULES.checkMinimal && window.RS_MODULES.checkMinimal();
}(jQuery), function (e) {
  "use strict";

  jQuery.fn.revolution = jQuery.fn.revolution || {};
  var i = jQuery.fn.revolution;
  jQuery.extend(!0, i, {
    checkForParallax: function checkForParallax(e) {
      var r = i[e].parallax;
      if (!r.done) {
        if (r.done = !0, i.ISM && r.disable_onmobile) return !1;
        if ("3D" == r.type || "3d" == r.type) {
          if (i.addSafariFix(e), tpGS.gsap.set(i[e].c, {
            overflow: r.ddd_overflow
          }), tpGS.gsap.set(i[e].canvas, {
            overflow: r.ddd_overflow
          }), "carousel" != i[e].sliderType && r.ddd_shadow) {
            var o = jQuery('<div class="dddwrappershadow"></div>');
            tpGS.gsap.set(o, {
              force3D: "auto",
              transformPerspective: 1600,
              transformOrigin: "50% 50%",
              width: "100%",
              height: "100%",
              position: "absolute",
              top: 0,
              left: 0,
              zIndex: 0
            }), i[e].c.prepend(o);
          }
          for (var s in i[e].slides) i[e].slides.hasOwnProperty(s) && t(jQuery(i[e].slides[s]), e);
          i[e].c.find("rs-static-layers").length > 0 && (tpGS.gsap.set(i[e].c.find("rs-static-layers"), {
            top: 0,
            left: 0,
            width: "100%",
            height: "100%"
          }), t(i[e].c.find("rs-static-layers"), e));
        }
        r.pcontainers = {}, r.bgcontainers = [], r.bgcontainer_depths = [], r.speed = void 0 === r.speed ? 0 : parseInt(r.speed, 0), r.speedbg = void 0 === r.speedbg ? 0 : parseInt(r.speedbg, 0), r.speedls = void 0 === r.speedls ? 0 : parseInt(r.speedls, 0), i[e].c.find("rs-slide rs-sbg-wrap, rs-slide rs-bgvideo").each(function () {
          var t = jQuery(this),
            a = t.data("parallax");
          window.isSafari11 || (i[e].parZ = 1), void 0 !== (a = "on" == a || !0 === a ? 1 : a) && "off" !== a && !1 !== a && (r.bgcontainers.push(t.closest("rs-sbg-px")), r.bgcontainer_depths.push(i[e].parallax.levels[parseInt(a, 0) - 1] / 100));
        });
        for (s = 1; s <= r.levels.length; s++) {
          for (var n in i[e].slides) if (i[e].slides.hasOwnProperty(n)) {
            var d = (c = i[e].slides[n]).dataset.key;
            void 0 === r.pcontainers[d] && (r.pcontainers[d] = {}), a(s, r, c, r.pcontainers[d]);
          }
          d = "static";
          void 0 === r.pcontainers[d] && (r.pcontainers[d] = {}), a(s, r, i[e].slayers[0], r.pcontainers[d]), JSON.stringify(r.pcontainers[d]) == JSON.stringify({}) && delete r.pcontainers[d];
        }
        if ("mouse" == r.type || "mousescroll" == r.type || "3D" == r.type || "3d" == r.type) {
          var l = "rs-slide .dddwrapper, .dddwrappershadow, rs-slide .dddwrapper-layer, rs-static-layers .dddwrapper-layer";
          for (var n in "carousel" === i[e].sliderType && (l = "rs-slide .dddwrapper, rs-slide .dddwrapper-layer, rs-static-layers .dddwrapper-layer"), r.sctors = {}, i[e].slides) if (i[e].slides.hasOwnProperty(n)) {
            var c;
            d = (c = i[e].slides[n]).dataset.key;
            r.sctors[d] = c.querySelectorAll(l);
          }
          i[e].slayers[0] && (r.sctors.static = i[e].slayers[0].querySelectorAll(l)), r.mouseEntered = !1, i[e].c.on("mouseenter", function (t) {
            var a = i[e].c.offset().top,
              o = i[e].c.offset().left;
            r.mouseEnterX = t.pageX - o, r.mouseEnterY = t.pageY - a, r.mouseEntered = !0;
          });
          var p = this.updateParallax.bind(this, e, r);
          i[e].c.on("mousemove.hoverdir, mouseleave.hoverdir, trigger3dpath", function (e) {
            r.eventData = e, void 0 !== r.frame && "mouseleave" !== e.type || (r.frame = window.requestAnimationFrame(p));
          }), i.ISM && window.addEventListener("deviceorientation", function (e) {
            r.eventData = e, void 0 === r.frame && (r.frame = window.requestAnimationFrame(p));
          });
        }
        var g = i[e].scrolleffect;
        g.set && (g.multiplicator_layers = parseFloat(g.multiplicator_layers), g.multiplicator = parseFloat(g.multiplicator)), void 0 !== g._L && 0 === g._L.length && (g._L = !1), void 0 !== g.bgs && 0 === g.bgs.length && (g.bgs = !1);
      }
    },
    getLayerParallaxOffset: function getLayerParallaxOffset(e, t, a) {
      return void 0 !== i[e].parallax && void 0 !== i[e].parallax.pcontainers && void 0 !== i[e].parallax.pcontainers[i[e]._L[t].slidekey] && void 0 !== i[e].parallax.pcontainers[i[e]._L[t].slidekey][t] ? Math.abs(i[e].parallax.pcontainers[i[e]._L[t].slidekey][t]["offs" + a]) : 0;
    },
    updateParallax: function updateParallax(e, t) {
      t.frame && (t.frame = window.cancelAnimationFrame(t.frame));
      var a,
        r,
        o = t.eventData,
        s = i[e].c.offset().left,
        n = i[e].c.offset().top,
        d = i[e].canv.width,
        l = i[e].canv.height,
        c = t.speed / 1e3 || 3;
      if ("enterpoint" == t.origo && "deviceorientation" !== o.type ? (!1 === t.mouseEntered && (t.mouseEnterX = o.pageX - s, t.mouseEnterY = o.pageY - n, t.mouseEntered = !0), a = t.mouseEnterX - (o.pageX - s), r = t.mouseEnterY - (o.pageY - n), c = t.speed / 1e3 || .4) : "deviceorientation" !== o.type && (a = d / 2 - (o.pageX - s), r = l / 2 - (o.pageY - n)), "deviceorientation" == o.type) {
        var p, g, u;
        p = o.beta - 60, g = o.gamma, u = p;
        var h = Math.abs(t.orientationX - g) > 1 || Math.abs(t.orientationY - u) > 1;
        if (t.orientationX = g, t.orientationY = u, !h) return;
        if (i.winW > i.getWinH(e)) {
          var m = g;
          g = u, u = m;
        }
        a = 360 / d * (g *= 1.5), r = 180 / l * (u *= 1.5);
      }
      for (var v in o.type, "mouseout" === o.type && (a = 0, r = 0, t.mouseEntered = !1), t.pcontainers) if (t.pcontainers.hasOwnProperty(v) && (void 0 === i[e].activeRSSlide || "static" === v || i[e].slides[i[e].activeRSSlide].dataset.key === v)) for (var f in t.pcontainers[v]) if (t.pcontainers[v].hasOwnProperty(f)) {
        var y = t.pcontainers[v][f];
        y.pl = "3D" == t.type || "3d" == t.type ? y.depth / 200 : y.depth / 100, y.offsh = a * y.pl, y.offsv = r * y.pl, "mousescroll" == t.type ? tpGS.gsap.to(y.tpw, c, {
          force3D: "auto",
          x: y.offsh,
          ease: "power3.out",
          overwrite: "all"
        }) : tpGS.gsap.to(y.tpw, c, {
          force3D: "auto",
          x: y.offsh,
          y: y.offsv,
          ease: "power3.out",
          overwrite: "all"
        });
      }
      if ("3D" == t.type || "3d" == t.type) for (var v in t.sctors) if (t.sctors.hasOwnProperty(v) && (void 0 === i[e].activeRSSlide || "static" === v || i[e].slides[i[e].activeRSSlide].dataset.key === v || i.isFF)) for (var f in t.sctors[v]) if (t.sctors[v].hasOwnProperty(f)) {
        n = jQuery(t.sctors[v][f]);
        var w = i.isFirefox() ? Math.min(25, t.levels[t.levels.length - 1]) / 200 : t.levels[t.levels.length - 1] / 200,
          b = a * w,
          _ = r * w,
          S = 0 == i[e].canv.width ? 0 : Math.round(a / i[e].canv.width * w * 100) || 0,
          x = 0 == i[e].canv.height ? 0 : Math.round(r / i[e].canv.height * w * 100) || 0,
          k = n.closest("rs-slide"),
          L = 0,
          R = !1;
        "deviceorientation" === o.type && (b = a * (w = t.levels[t.levels.length - 1] / 200), _ = r * w * 3, S = 0 == i[e].canv.width ? 0 : Math.round(a / i[e].canv.width * w * 500) || 0, x = 0 == i[e].canv.height ? 0 : Math.round(r / i[e].canv.height * w * 700) || 0), n.hasClass("dddwrapper-layer") && (L = t.ddd_z_correction || 65, R = !0), n.hasClass("dddwrapper-layer") && (b = 0, _ = 0), k.index() === i[e].pr_active_key || "carousel" != i[e].sliderType ? !t.ddd_bgfreeze || R ? tpGS.gsap.to(n, c, {
          rotationX: x,
          rotationY: -S,
          x: b,
          z: L,
          y: _,
          ease: "power3.out",
          overwrite: "all"
        }) : tpGS.gsap.to(n, .5, {
          force3D: "auto",
          rotationY: 0,
          rotationX: 0,
          z: 0,
          ease: "power3.out",
          overwrite: "all"
        }) : tpGS.gsap.to(n, .5, {
          force3D: "auto",
          rotationY: 0,
          x: 0,
          y: 0,
          rotationX: 0,
          z: 0,
          ease: "power3.out",
          overwrite: "all"
        }), "mouseleave" != o.type && "mouseout" !== o.type || tpGS.gsap.to(this, 3.8, {
          z: 0,
          ease: "power3.out"
        });
      }
    },
    parallaxProcesses: function parallaxProcesses(e, t, a, r) {
      var o = i[e].fixedOnTop ? Math.min(1, Math.max(0, window.scrollY / i.lastwindowheight)) : Math.min(1, Math.max(0, (0 - (t.top - i.lastwindowheight)) / (t.hheight + i.lastwindowheight))),
        s = (t.top >= 0 && t.top <= i.lastwindowheight || t.top <= 0 && t.bottom >= 0 || t.top <= 0 && t.bottom, i[e].slides[void 0 === i[e].pr_active_key ? 0 : i[e].pr_active_key]);
      if (i[e].scrollProg = o, i[e].scrollProgBasics = {
        top: t.top,
        height: t.hheight,
        bottom: t.bottom
      }, i[e].sbtimeline.fixed ? (!1 === i[e].fixedScrollOnState || !i.stickySupported || 0 != i[e].fullScreenOffsetResult && null != i[e].fullScreenOffsetResult ? i.stickySupported = !1 : (i[e].topc.addClass("rs-stickyscrollon"), i[e].fixedScrollOnState = !0), void 0 === i[e].sbtimeline.rest && i.updateFixedScrollTimes(e), t.top >= i[e].fullScreenOffsetResult && t.top <= i.lastwindowheight ? (o = i[e].sbtimeline.fixStart * (1 - t.top / i.lastwindowheight) / 1e3, !0 !== i.stickySupported && !1 !== i[e].fixedScrollOnState && (i[e].topc.removeClass("rs-fixedscrollon"), tpGS.gsap.set(i[e].cpar, {
        top: 0,
        y: 0
      }), i[e].fixedScrollOnState = !1)) : t.top <= i[e].fullScreenOffsetResult && t.bottom >= i[e].module.height ? (!0 !== i.stickySupported && !0 !== i[e].fixedScrollOnState && (i[e].fixedScrollOnState = !0, i[e].topc.addClass("rs-fixedscrollon"), tpGS.gsap.set(i[e].cpar, {
        top: 0,
        y: i[e].fullScreenOffsetResult
      })), o = (i[e].sbtimeline.fixStart + i[e].sbtimeline.time * (Math.abs(t.top) / (t.hheight - i[e].module.height))) / 1e3) : (!0 !== i.stickySupported && (tpGS.gsap.set(i[e].cpar, {
        top: i[e].scrollproc >= 0 ? 0 : t.height - i[e].module.height
      }), !1 !== i[e].fixedScrollOnState && (i[e].topc.removeClass("rs-fixedscrollon"), i[e].fixedScrollOnState = !1)), o = t.top > i.lastwindowheight ? 0 : (i[e].sbtimeline.fixEnd + i[e].sbtimeline.rest * (1 - t.bottom / i[e].module.height)) / 1e3)) : o = i[e].duration * o / 1e3, void 0 !== s && void 0 !== i.gA(s, "key") && !0 !== a) {
        var n = 0;
        for (var d in i[e].sbas[i.gA(s, "key")]) if (void 0 !== i[e]._L[d] && null == i[e]._L[d].timeline && n++, void 0 !== i[e]._L[d] && void 0 !== i[e]._L[d].timeline && (1 == i[e]._L[d].animationonscroll || "true" == i[e]._L[d].animationonscroll)) {
          n = -9999;
          var l = void 0 !== i[e]._L[d].scrollBasedOffset ? o + i[e]._L[d].scrollBasedOffset : o;
          l = l <= 0 ? 0 : l < .1 ? .1 : l, i[e]._L[d].animteToTime !== l && (i[e]._L[d].animteToTime = l, tpGS.gsap.to(i[e]._L[d].timeline, i[e].sbtimeline.speed, {
            time: l,
            ease: i[e].sbtimeline.ease
          }));
        }
        n > 0 && requestAnimationFrame(function () {
          i.parallaxProcesses(e, t, a, r);
        }), i[e].c.trigger("timeline_scroll_processed", {
          id: e,
          mproc: o,
          speed: i[e].sbtimeline.speed
        });
      }
      if (i.ISM && i[e].parallax.disable_onmobile) return !1;
      var c,
        p = i[e].parallax;
      if (void 0 !== i[e].slides[i[e].pr_processing_key] && void 0 !== i[e].slides[i[e].pr_processing_key].dataset && (c = i[e].slides[i[e].pr_processing_key].dataset.key), "3d" != p.type && "3D" != p.type) {
        if ("scroll" == p.type || "mousescroll" == p.type) for (var g in p.pcontainers) if (p.pcontainers.hasOwnProperty(g) && (void 0 === i[e].activeRSSlide || "static" === g || i[e].slides[i[e].activeRSSlide].dataset.key === g || c === g)) for (var u in p.pcontainers[g]) if (p.pcontainers[g].hasOwnProperty(u)) {
          var h = p.pcontainers[g][u],
            m = void 0 !== r ? r : p.speedls / 1e3 || 0;
          h.pl = h.depth / 100, h.offsv = Math.round(i[e].scrollproc * (-h.pl * i[e].canv.height) * 10) / 10 || 0, tpGS.gsap.to(h.tpw, m, {
            overwrite: "auto",
            force3D: "auto",
            y: h.offsv
          });
        }
        if (p.bgcontainers) for (u = 0; u < p.bgcontainers.length; u++) {
          var v = p.bgcontainers[u],
            f = p.bgcontainer_depths[u],
            y = i[e].scrollproc * (-f * i[e].canv.height) || 0;
          m = void 0 !== r ? r : p.speedbg / 1e3 || .015;
          m = void 0 !== i[e].parallax.lastBGY && 0 === m && Math.abs(y - i[e].parallax.lastBGY) > 50 ? .15 : m, tpGS.gsap.to(v, m, {
            position: "absolute",
            top: "0px",
            left: "0px",
            backfaceVisibility: "hidden",
            force3D: "true",
            y: y + "px"
          }), i[e].parallax.lastBGY = y;
        }
      }
      var w = i[e].scrolleffect;
      if (w.set && (!i.ISM || !1 === w.disable_onmobile)) {
        var b = Math.abs(i[e].scrollproc) - w.tilt / 100;
        if (b = b < 0 ? 0 : b, !1 !== w._L) {
          var _ = 1 - b * w.multiplicator_layers,
            S = {
              force3D: "true"
            };
          if ("top" == w.direction && i[e].scrollproc >= 0 && (_ = 1), "bottom" == w.direction && i[e].scrollproc <= 0 && (_ = 1), _ = _ > 1 ? 1 : _ < 0 ? 0 : _, w.fade && (S.opacity = _), w.scale) {
            var x = _;
            S.scale = 1 - x + 1;
          }
          if (w.blur) R = (R = (1 - _) * w.maxblur) <= .03 ? 0 : R, S["-webkit-filter"] = "blur(" + R + "px)", S.filter = "blur(" + R + "px)";
          if (w.grayscale) {
            var k = "grayscale(" + 100 * (1 - _) + "%)";
            S["-webkit-filter"] = void 0 === S["-webkit-filter"] ? k : S["-webkit-filter"] + " " + k, S.filter = void 0 === S.filter ? k : S.filter + " " + k;
          }
          tpGS.gsap.set(w._L, S);
        }
        if (!1 !== w.bgs) {
          _ = 1 - b * w.multiplicator, S = {
            backfaceVisibility: "hidden",
            force3D: "true"
          };
          for (var L in "top" == w.direction && i[e].scrollproc >= 0 && (_ = 1), "bottom" == w.direction && i[e].scrollproc <= 0 && (_ = 1), _ = _ > 1 ? 1 : _ < 0 ? 0 : _, w.bgs) if (w.bgs.hasOwnProperty(L)) {
            if (w.bgs[L].fade && (S.opacity = _), w.bgs[L].blur) {
              var R = (1 - _) * w.maxblur;
              S["-webkit-filter"] = "blur(" + R + "px)", S.filter = "blur(" + R + "px)";
            }
            if (w.bgs[L].grayscale) {
              k = "grayscale(" + 100 * (1 - _) + "%)";
              S["-webkit-filter"] = void 0 === S["-webkit-filter"] ? k : S["-webkit-filter"] + " " + k, S.filter = void 0 === S.filter ? k : S.filter + " " + k;
            }
            tpGS.gsap.set(w.bgs[L].c, S);
          }
        }
      }
    }
  });
  var t = function t(e, _t3) {
    var a = i[_t3].parallax;
    e.find("rs-sbg-wrap").wrapAll('<div class="dddwrapper" style="width:100%;height:100%;position:absolute;top:0px;left:0px;overflow:hidden"></div>');
    var r = e[0].querySelectorAll(".rs-parallax-wrap"),
      o = document.createElement("div");
    o.className = "dddwrapper-layer", o.style.width = "100%", o.style.height = "100%", o.style.position = "absolute", o.style.top = "0px", o.style.left = "0px", o.style.zIndex = 5, o.style.overflow = a.ddd_layer_overflow;
    for (var s = 0; s < r.length; s++) r.hasOwnProperty(s) && null === i.closestNode(r[s], "RS-GROUP") && null === i.closestNode(r[s], "RS-ROW") && o.appendChild(r[s]);
    e[0].appendChild(o), e.find(".rs-pxl-tobggroup").closest(".rs-parallax-wrap").wrapAll('<div class="dddwrapper-layertobggroup" style="position:absolute;top:0px;left:0px;z-index:50;width:100%;height:100%"></div>');
    var n = e.find(".dddwrapper"),
      d = e.find(".dddwrapper-layer");
    e.find(".dddwrapper-layertobggroup").appendTo(n), "carousel" == i[_t3].sliderType && (a.ddd_shadow && n.addClass("dddwrappershadow"), tpGS.gsap.set(n, {
      borderRadius: i[_t3].carousel.border_radius
    })), tpGS.gsap.set(e, {
      overflow: "visible",
      transformStyle: "preserve-3d",
      perspective: 1600
    }), tpGS.gsap.set(n, {
      force3D: "auto",
      transformOrigin: "50% 50%",
      transformStyle: "preserve-3d",
      transformPerspective: 1600
    }), tpGS.gsap.set(d, {
      force3D: "auto",
      transformOrigin: "50% 50%",
      zIndex: 5,
      transformStyle: "flat",
      transformPerspective: 1600
    }), tpGS.gsap.set(i[_t3].canvas, {
      transformStyle: "preserve-3d",
      transformPerspective: 1600
    });
  };
  function a(t, a, r, o) {
    e(r).find(".rs-pxl-" + t).each(function () {
      var e = this.className.indexOf("rs-pxmask") >= 0,
        r = e ? i.closestNode(this, "RS-PX-MASK") : i.closestClass(this, "rs-parallax-wrap");
      r && (e && !window.isSafari11 && (tpGS.gsap.set(r, {
        z: 1
      }), tpGS.gsap.set(i.closestNode(r, "RS-BG-ELEM"), {
        z: 1
      })), r.dataset.parallaxlevel = a.levels[t - 1], r.classList.add("tp-parallax-container"), o[this.id] = {
        tpw: r,
        depth: a.levels[t - 1],
        offsv: 0,
        offsh: 0
      });
    });
  }
  window.RS_MODULES = window.RS_MODULES || {}, window.RS_MODULES.parallax = {
    loaded: !0,
    version: "6.2.24"
  }, window.RS_MODULES.checkMinimal && window.RS_MODULES.checkMinimal();
}(jQuery), function (e) {
  "use strict";

  window._R_is_Editor ? RVS._R = void 0 === RVS._R ? {} : RVS._R : window._R_is_Editor = !1;
  jQuery.fn.revolution = jQuery.fn.revolution || {};
  var i = _R_is_Editor ? RVS._R : jQuery.fn.revolution;
  _R_is_Editor && (RVS._R.isNumeric = RVS.F.isNumeric), jQuery.extend(!0, i, {
    getSlideAnimationObj: function getSlideAnimationObj(e, t, a) {
      var r,
        o = {};
      for (var s in void 0 === t.anim && null == t.in && (t.in = "o:0"), t) if (t.hasOwnProperty(s) && void 0 !== t[s]) {
        var n = t[s].split(";");
        for (var d in n) n.hasOwnProperty(d) && void 0 !== (r = n[d].split(":"))[0] && void 0 !== r[1] && (o[s] = void 0 === o[s] ? {} : o[s], o[s][r[0]] = "d3" === s && "c" === r[0] ? r[1] : r[1].split(",")[0]);
      }
      return o.in = void 0 === o.in ? {} : o.in, o.anim = void 0 === o.anim ? {
        e: "basic"
      } : o.anim, _R_is_Editor || void 0 === o.in || void 0 === o.in.prst || i.loadSlideAnimLibrary(e, {
        key: a,
        prst: o.in.prst
      }), i[e].sbgs[a].slideanimationRebuild = !1, o;
    },
    loadSlideAnimLibrary: function loadSlideAnimLibrary(e, t) {
      void 0 === i.SLTR && !0 !== i.SLTR_loading ? (i.SLTR_loading = !0, jQuery.ajax({
        type: "post",
        url: i[e].ajaxUrl,
        dataType: "json",
        data: {
          action: "revslider_ajax_call_front",
          client_action: "get_transitions"
        },
        success: function success(a, r, o) {
          1 == a.success && (i.SLTR = a.transitions, void 0 !== t && i.setRandomDefaults(e, t.key, t.prst));
        },
        error: function error(e) {
          console.log("Transition Table can not be loaded"), console.log(e);
        }
      })) : void 0 !== t && void 0 !== i.SLTR && i.setRandomDefaults(e, t.key, t.prst);
    },
    convertSlideAnimVals: function convertSlideAnimVals(e) {
      return {
        anim: {
          eng: e.eng,
          ms: parseInt(e.speed, 0),
          o: e.o,
          e: e.e,
          f: e.f,
          p: e.p,
          d: parseInt(e.d, 0),
          adpr: e.adpr
        },
        d3: {
          f: e.d3.f,
          d: e.d3.d,
          z: e.d3.z,
          t: e.d3.t,
          c: e.d3.c,
          e: e.d3.e,
          fdi: e.d3.fdi,
          fdo: e.d3.fdo,
          fz: e.d3.fz,
          su: e.d3.su,
          smi: e.d3.smi,
          sma: e.d3.sma,
          sc: e.d3.sc,
          sl: e.d3.sl
        },
        in: {
          eng: e.in.eng,
          o: _R_is_Editor && void 0 !== e.preset && 0 === e.preset.indexOf("rnd") ? 0 : i.valBeau(e.in.o),
          x: i.valBeau(e.in.x),
          y: i.valBeau(e.in.y),
          r: i.valBeau(e.in.r),
          sx: i.valBeau(e.in.sx),
          sy: i.valBeau(e.in.sy),
          m: e.in.m,
          e: e.in.e,
          row: e.in.row,
          col: e.in.col,
          mo: "false" !== e.in.mou && !1 !== e.in.mou ? i.valBeau(e.in.mo) : 0,
          moo: "false" !== e.in.mou && !1 !== e.in.mou ? i.valBeau(e.in.moo) : "none",
          mou: e.in.mou
        },
        out: void 0 === e.out.a || "true" == e.out.a || !0 === e.out.a ? void 0 : {
          a: d(e.out.a),
          o: i.valBeau(e.out.o),
          x: i.valBeau(e.out.x),
          y: i.valBeau(e.out.y),
          r: i.valBeau(e.out.r),
          sx: i.valBeau(e.out.sx),
          sy: i.valBeau(e.out.sy),
          m: e.out.m,
          e: e.out.e,
          row: i.valBeau(e.out.row),
          col: i.valBeau(e.out.col)
        },
        filter: {
          u: e.filter.u,
          e: e.filter.e,
          b: e.filter.b,
          g: e.filter.g,
          h: e.filter.h,
          s: e.filter.s,
          c: e.filter.c,
          i: e.filter.i
        },
        addOns: e.addOns
      };
    },
    setRandomDefaults: function setRandomDefaults(e, t, a) {
      i[e].sbgs[t].random = i.getAnimObjectByKey(a, i.SLTR);
    },
    getSlideAnim_AddonDefaults: function getSlideAnim_AddonDefaults() {
      var e = {};
      for (var t in i.enabledSlideAnimAddons) e = jQuery.extend(!0, e, i[i.enabledSlideAnimAddons[t]].defaults());
      return e;
    },
    getSlideAnim_EmptyObject: function getSlideAnim_EmptyObject() {
      return {
        speed: 1e3,
        o: "inout",
        e: "basic",
        f: "start",
        p: "none",
        d: 15,
        eng: "animateCore",
        adpr: !1,
        d3: {
          f: "none",
          d: "horizontal",
          z: 300,
          t: 0,
          c: "#ccc",
          e: "power2.inOut",
          fdi: 1.5,
          fdo: 2,
          fz: 0,
          su: !1,
          smi: 0,
          sma: .5,
          sc: "#000",
          sl: 1
        },
        filter: {
          u: !1,
          e: "default",
          b: 0,
          g: 0,
          h: 100,
          s: 0,
          c: 100,
          i: 0
        },
        in: {
          o: 1,
          x: 0,
          y: 0,
          r: 0,
          sx: 1,
          sy: 1,
          m: !1,
          e: "power2.inOut",
          row: 1,
          col: 1,
          mo: 80,
          mou: !1
        },
        out: {
          a: "true",
          o: 1,
          x: 0,
          y: 0,
          r: 0,
          sx: 1,
          sy: 1,
          m: !1,
          e: "power2.inOut",
          row: 1,
          col: 1
        },
        addOns: i.getSlideAnim_AddonDefaults()
      };
    },
    getAnimObjectByKey: function getAnimObjectByKey(e, t) {
      if (i.getAnimObjectCacheKey === e) return i.getAnimObjectCache;
      var a;
      for (var r in i.getAnimObjectCacheKey = e, t) if (t.hasOwnProperty(r) && void 0 === a) for (var o in t[r]) if (t[r].hasOwnProperty(o) && void 0 === a) if (e === o && 0 === e.indexOf("rnd")) (a = t[r][o]).main = r, a.group = o;else for (var s in t[r][o]) t[r][o].hasOwnProperty(s) && void 0 === a && s === e && ((a = t[r][o][s]).main = r, a.group = o);
      return i.getAnimObjectCache = jQuery.extend(!0, {}, a), a;
    },
    getRandomSlideTrans: function getRandomSlideTrans(e, t, a) {
      if (void 0 !== i.randomSlideAnimCache && void 0 !== i.randomSlideAnimCache[e] && void 0 !== i.randomSlideAnimCache[e][t]) return i.randomSlideAnimCache[e][t][Math.floor(Math.random() * i.randomSlideAnimCache[e][t].length)];
      for (var r in i.randomSlideAnimCache = void 0 === i.randomSlideAnimCache ? {} : i.randomSlideAnimCache, i.randomSlideAnimCache[e] = void 0 === i.randomSlideAnimCache[e] ? {} : i.randomSlideAnimCache[e], i.randomSlideAnimCache[e][t] = void 0 === i.randomSlideAnimCache[e][t] ? [] : i.randomSlideAnimCache[e][t], a) if (a.hasOwnProperty(r) && "random" !== r && "custom" !== r && ("all" == e || r == e)) for (var o in a[r]) if (a[r].hasOwnProperty(o) && "icon" !== o && ("" + t == "undefined" || t.indexOf(o) >= 0)) for (var s in a[r][o]) a[r][o].hasOwnProperty(s) && -1 == jQuery.inArray(a[r][o][s].title, ["*north*", "*south*", "*east*", "*west*"]) && i.randomSlideAnimCache[e][t].push(s);
      return i.randomSlideAnimCache[e][t][Math.floor(Math.random() * i.randomSlideAnimCache[e][t].length)];
    },
    cbgW: function cbgW(e, t) {
      return _R_is_Editor ? RVS.RMD.width : "carousel" === i[e].sliderType ? i[e].justifyCarousel ? i[e].carousel.slide_widths[void 0 !== t ? t : i[e].carousel.focused] : i[e].carousel.slide_width : i[e].canv.width;
    },
    cbgH: function cbgH(e, t) {
      return _R_is_Editor ? RVS.RMD.height : "carousel" === i[e].sliderType ? i[e].carousel.slide_height : void 0 !== i[e].maxHeight && i[e].maxHeight > 0 && !i[e].fixedOnTop ? Math.min(i[e].canv.height, i[e].maxHeight) : i[e].canv.height;
    },
    valBeau: function valBeau(e) {
      return e = ("" + (e = ("" + (e = ("" + (e = ("" + (e = ("" + e).split(",").join("|"))).replace("{", "ran("))).replace("}", ")"))).replace("[", "cyc("))).replace("]", ")");
    },
    animateSlide: function animateSlide(e, i) {
      return _R_is_Editor && RVS.F.resetSlideTL(), void 0 === tpGS.eases.late && (tpGS.CustomEase.create("late", "M0,0,C0,0,0.474,0.078,0.724,0.26,0.969,0.438,1,1,1,1"), tpGS.CustomEase.create("late2", "M0,0 C0,0 0.738,-0.06 0.868,0.22 1,0.506 1,1 1,1 "), tpGS.CustomEase.create("late3", "M0,0,C0,0,0.682,0.157,0.812,0.438,0.944,0.724,1,1,1,1")), o(e, i);
    },
    getBasic: function getBasic(e) {
      return jQuery.extend(!0, {
        attr: null == e || void 0 === e.attr ? ["o", "r", "sx", "sy", "x", "y", "m", "e", "row", "col", "mo", "moo"] : e.attr,
        in: {
          f: "start",
          m: !1,
          o: 1,
          r: 0,
          sx: 1,
          sy: 1,
          x: 0,
          y: 0,
          row: 1,
          col: 1,
          e: "power2.inOut",
          ms: 1e3,
          mo: 0,
          moo: "none"
        },
        out: {
          f: "start",
          m: !1,
          o: 1,
          r: 0,
          sx: 1,
          sy: 1,
          x: 0,
          y: 0,
          row: 1,
          col: 1,
          e: "power2.inOut",
          ms: 1e3
        }
      }, e);
    },
    playBGVideo: function playBGVideo(e, t, a) {
      if (_R_is_Editor) a = void 0 === a ? RVS.SBGS[RVS.S.slideId].n : a;else {
        if (void 0 === a && (void 0 === i[e].pr_next_bg || 0 === i[e].pr_next_bg.length)) return;
        a = void 0 === a ? i[e].sbgs[void 0 === t ? i[e].pr_next_bg[0].dataset.key : t] : a;
      }
      void 0 !== a.bgvid && a.bgvid.length > 0 && (c(e, {}, a, "in"), i.resetVideo(a.bgvid, e), i.playVideo(a.bgvid, e, !0), tpGS.gsap.to(a.bgvid[0], .2, {
        zIndex: 30,
        display: "block",
        autoAlpha: 1,
        delay: .075,
        overwrite: "all"
      }));
    },
    stopBGVideo: function stopBGVideo(e, t, a) {
      if (_R_is_Editor) a = void 0 === a ? RVS.SBGS[RVS.S.slideId].n : a;else {
        if (void 0 === a && (void 0 === i[e].pr_next_bg || 0 === i[e].pr_next_bg.length)) return;
        a = void 0 === a ? i[e].sbgs[void 0 === t ? i[e].pr_next_bg[0].dataset.key : t] : a;
      }
      void 0 !== a.bgvid && a.bgvid.length > 0 && (a.drawVideoCanvasImagesRecall = !1, i.stopVideo(a.bgvid, e), tpGS.gsap.to(a.bgvid[0], .2, {
        autoAlpha: 0,
        zIndex: 0,
        display: "none"
      }));
    },
    SATools: {
      getOffset: function getOffset(e, t, a, r) {
        var o = ("" + e).indexOf("%") >= 0;
        return 0 == (e = i.SATools.getSpecialValue(e, r, a)) || void 0 === e ? 0 : o ? t * (parseInt(e) / 100) : parseInt(e);
      },
      getSpecialValue: function getSpecialValue(e, t, a, r) {
        if (i.isNumeric(parseFloat(e, 0))) return parseFloat(e, 0);
        var o = ("" + e).split("ran(").length > 1 ? "random" : ("" + e).split("cyc(").length > 1 ? "wrap" : ("" + e).split("(").length > 1 ? "dir" : "unknown",
          s = ("random" === o ? e.slice(4, -1) : "wrap" === o ? e.slice(4, -1) : e.slice(1, -1)).split("|");
        if ("random" === o) return tpGS.gsap.utils.random(parseFloat(s[0]), parseFloat(s.length > 1 ? s[1] : 0 - s[0]));
        if ("wrap" === o) {
          var n = tpGS.gsap.utils.wrap(s, t);
          return ("" + n).split("(").length > 1 ? parseFloat(n.slice(1, -1)) * a + (r ? "%" : "") : n;
        }
        return "dir" === o ? parseFloat(s[0]) * a + (r ? "%" : "") : void 0;
      }
    },
    getmDim: function getmDim(e, t, a) {
      var r = i.cbgW(e, t),
        o = i.cbgH(e, t);
      return a.DPR = _R_is_Editor ? Math.min(window.devicePixelRatio, 2) : i[e].DPR, i.maxDimCheck(a, r, o);
    },
    maxDimCheck: function maxDimCheck(e, t, a) {
      var r, o;
      void 0 !== e.video && ("img" === e.video.tagName || null == e.video.videoWidth || e.video.videoWidth);
      if ("animating" !== e.currentState && null == e.panzoom || "animating" === e.currentState && null == e.panzoom && (null == e.slideanimation || null == e.slideanimation.anim || "true" !== e.slideanimation.anim.adpr)) {
        if (e.DPR > 1 && i.ISM && a > 1024) e.DPR = 1, r = t, o = a;else {
          var s = {
            w: null == e.video || e.isVidImg ? e.loadobj.width : 0 == e.video.videoWidth ? e.loadobj.width : e.video.videoWidth,
            h: null == e.video || e.isVidImg ? e.loadobj.height : 0 == e.video.videoHeight ? e.loadobj.height : e.video.videoHeight
          };
          void 0 === s.w && (s.w = e.loadobj.width), void 0 === s.h && (s.h = e.loadobj.height);
          var n = a / s.w,
            d = t / s.h,
            l = Math.max(n, d);
          if (l > e.DPR || n >= 1 && d >= 1 ? e.DPR = 1 : e.DPR > l && (e.DPR = Math.min(e.DPR, e.DPR / l)), r = t * e.DPR, o = a * e.DPR, e.DPR > 1) {
            var c = t / a;
            s.w > s.h && s.w < r ? (o = (r = Math.max(t, s.w)) / c, e.DPR = 1) : s.h > s.w && s.h < o && (r = (o = Math.max(a, s.h)) * c, e.DPR = 1);
          }
        }
      } else e.DPR = 1, r = t, o = a;
      return {
        width: Math.round(r),
        height: Math.round(o),
        w: t,
        h: a
      };
    },
    updateSlideBGs: function updateSlideBGs(e, t, a, r) {
      if (_R_is_Editor) a = void 0 === a ? RVS.SBGS[RVS.S.slideId].n : a;else {
        if (void 0 === a && (void 0 === i[e].pr_next_bg || 0 === i[e].pr_next_bg.length)) return;
        a = void 0 === a ? i[e].sbgs[void 0 === t ? i[e].pr_next_bg[0].dataset.key : t] : a;
      }
      (r = void 0 !== a.mDIM && r) || (a.mDIM = i.getmDim(e, a.skeyindex, a)), void 0 !== a.video ? ("IMG" !== a.video.tagName && (a.isVidImg = ""), a.cDIMS = i.getBGCanvasDetails(e, a), a.canvas.width = a.mDIM.width, a.canvas.height = a.mDIM.height, a.ctx.clearRect(0, 0, a.mDIM.width, a.mDIM.height), a.ctx.drawImage(a.shadowCanvas, 0, 0)) : (a.cDIMS = i.getBGCanvasDetails(e, a, r), a.canvas.width = a.mDIM.width, a.canvas.height = a.mDIM.height, "panzoom" === a.currentState || "animating" === a.currentState || void 0 === a.currentState && !_R_is_Editor && "carousel" != i[e].sliderType || (a.ctx.clearRect(0, 0, a.mDIM.width, a.mDIM.height), a.ctx.drawImage(a.shadowCanvas, 0, 0))), "animating" === a.currentState && "carousel" !== i[e].sliderType && i.animatedCanvasUpdate(e, a);
    },
    addCanvas: function addCanvas() {
      var e = document.createElement("canvas");
      return x = e.getContext("2d"), e.style.background = "transparent", e.style.opacity = 1, x;
    },
    updateVideoFrames: function updateVideoFrames(e, t, a) {
      if (t.now = Date.now(), t.then = void 0 === t.then ? t.now - 500 : t.then, t.elapsed = t.now - t.then, t.fps = "animating" === t.currentState && window._rs_firefox ? 50 : 33, t.elapsed > t.fps) {
        t.then = t.now - t.elapsed % t.fps;
        var r = "img" === t.video.tagName || null == t.video.videoWidth || 0 == t.video.videoWidth;
        void 0 !== t.video && !t.video.BGrendered && void 0 !== t.loadobj && void 0 !== t.loadobj.img || i.ISM && i.isFirefox(e) ? (t.mDIM = i.getmDim(e, t.skeyindex, t), t.pDIMS = s(t.mDIM, t, {
          width: t.mDIM.width,
          height: t.mDIM.height,
          x: 0,
          y: 0,
          contw: t.loadobj.width,
          conth: t.loadobj.height
        }), t.shadowCanvas.width = t.mDIM.width, t.shadowCanvas.height = t.mDIM.height, t.shadowCTX.drawImage(t.loadobj.img, t.pDIMS.x, t.pDIMS.y, t.pDIMS.width, t.pDIMS.height)) : ((a || void 0 === t.sDIMS || r !== t.isVidImg || 0 === t.sDIMS.width || 0 === t.sDIMS.height) && (t.isVidImg = r, t.mDIM = i.getmDim(e, t.skeyindex, t), t.sDIMS = s(t.mDIM, t, {
          width: t.mDIM.width,
          height: t.mDIM.height,
          x: 0,
          y: 0,
          contw: t.isVidImg ? t.loadobj.width : t.video.videoWidth,
          conth: t.isVidImg ? t.loadobj.height : t.video.videoHeight
        })), void 0 !== t.sDIMS && 0 !== t.sDIMS.width && 0 !== t.sDIMS.height && ("animating" === t.currentState ? (t.shadowCanvas.width = t.sDIMS.width, t.shadowCanvas.height = t.sDIMS.height, t.shadowCTX.drawImage(t.video, t.sDIMS.x, t.sDIMS.y, t.sDIMS.width, t.sDIMS.height)) : void 0 === t.animateDirection && (t.canvas.width = t.mDIM.width, t.canvas.height = t.mDIM.height, t.ctx.drawImage(t.video, t.sDIMS.x, t.sDIMS.y, t.sDIMS.width, t.sDIMS.height)), t.shadowCanvas_Drawn = !0));
      }
      (a || t.drawVideoCanvasImagesRecall && "animating" === t.currentState || "animating" === t.currentState && void 0 === t.shadowCanvas_Drawn) && window.requestAnimationFrame(function () {
        i.updateVideoFrames(e, t);
      });
    },
    createOverlay: function createOverlay(e, t, a, r) {
      if ("none" === t) return "none";
      a = void 0 === a ? 1 : a;
      r = void 0 === r ? {
        0: "rgba(0, 0, 0, 0)",
        1: "rgba(0, 0, 0, 1)"
      } : r;
      var o = {
          none: [[0]],
          1: [[1, 0], [0, 0]],
          2: [[1, 0, 0], [0, 0, 0], [0, 0, 0]],
          3: [[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],
          4: [[1], [0]],
          5: [[1], [0], [0]],
          6: [[1], [0], [0], [0]],
          7: [[1, 0]],
          8: [[1, 0, 0]],
          9: [[1, 0, 0, 0]],
          10: [[1, 0, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 0, 1]],
          11: [[0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [1, 0, 0, 0, 1], [0, 1, 0, 1, 0], [0, 0, 1, 0, 0]],
          12: [[1, 0, 0], [0, 1, 0], [0, 0, 1]],
          13: [[0, 0, 1], [0, 1, 0], [1, 0, 0]],
          14: [[1, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0], [0, 0, 0, 0, 0]],
          15: [[0, 0, 0, 0, 1], [0, 0, 0, 1, 0], [0, 0, 1, 0, 0], [0, 1, 0, 0, 0], [1, 0, 0, 0, 0]],
          16: [[1, 0, 0, 0, 1], [0, 1, 0, 1, 0], [0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [1, 0, 0, 0, 1]]
        },
        s = void 0 === o[t = void 0 === t ? 1 : t] ? o[2] : o[t];
      _R_is_Editor && (i[e] = void 0 === i[e] ? {} : i[e]), i[e].patternCanvas = document.createElement("canvas"), i[e].patternCtx = i[e].patternCanvas.getContext("2d"), i[e].patternCanvas.width = s[0].length * a, i[e].patternCanvas.height = s.length * a;
      for (var n = 0; n < s.length; n++) for (var d = 0; d < s[n].length; d++) "transparent" != r[s[n][d]] && (i[e].patternCtx.fillStyle = r[s[n][d]], i[e].patternCtx.fillRect(d * a, n * a, a, a));
      return "url(" + i[e].patternCanvas.toDataURL() + ")";
    },
    getBGCanvasDetails: function getBGCanvasDetails(e, t, a) {
      var r;
      return a || (t.mDIM = i.getmDim(e, t.skeyindex, t)), t.usepattern = ("auto" === t.bgfit || t.bgfit.indexOf("%") >= 0) && (void 0 === t.loadobj || !0 !== t.loadobj.useBGColor), _R_is_Editor && void 0 === t.panzoom && delete t.shadowCanvas, void 0 === t.shadowCanvas && (t.shadowCanvas = document.createElement("canvas"), t.shadowCTX = t.shadowCanvas.getContext("2d"), t.shadowCanvas.style.background = "transparent", t.shadowCanvas.style.opacity = 1), !0 === t.replaceShadowCanvas || !0 === t.loadobj.bgColor || !0 === t.usebgColor || void 0 !== t.panzoom || null != t.isHTML5 && 1 != t.poster || t.usepattern ? (r = {
        width: t.mDIM.width,
        height: t.mDIM.height,
        x: 0,
        y: 0
      }, t.usepattern && void 0 !== t.loadobj && void 0 !== t.loadobj.img ? i.getCanvasPattern(e, t, {
        ratio: t.loadobj.height / t.loadobj.width
      }) : (t.loadobj.bgColor || t.usebgColor) && (t.shadowCanvas.width = t.mDIM.width, t.shadowCanvas.height = t.mDIM.height, i.getCanvasGradients(e, t))) : (r = s(t.mDIM, t, {
        width: t.mDIM.width,
        height: t.mDIM.height,
        x: 0,
        y: 0,
        contw: t.loadobj.width,
        conth: t.loadobj.height
      }), t.shadowCanvas.width = t.mDIM.width, t.shadowCanvas.height = t.mDIM.height, void 0 !== t.loadobj && void 0 !== t.loadobj.img && t.shadowCTX.drawImage(t.loadobj.img, r.x, r.y, r.width, r.height), r = {
        width: t.mDIM.width,
        height: t.mDIM.height,
        x: 0,
        y: 0
      }), r;
    },
    getCanvasPattern: function getCanvasPattern(e, t, a) {
      void 0 === t.patternImageCanvas && (t.patternImageCanvas = document.createElement("canvas"), t.patternImageCTX = t.patternImageCanvas.getContext("2d"));
      var r = t.bgfit.split(" ");
      1 === r.length && (r[1] = r[0]), a.width = "auto" === r[0] ? t.loadobj.width : t.loadobj.width * (parseInt(r[0], 0) / 100), a.height = "auto" === r[1] ? t.loadobj.height : a.width * a.ratio, t.DPR = _R_is_Editor ? Math.min(window.devicePixelRatio, 2) : i[e].DPR;
      var o = a.width / a.height;
      a.width = a.width * t.DPR, a.height = a.height * t.DPR, i.isIOS && a.width * a.height > 15728640 && (t.mDIM.width > t.mDIM.height ? (a.width = t.mDIM.width, a.height = Math.round(t.mDIM.width / o)) : (a.height = t.mDIM.height, a.width = Math.round(t.mDIM.height * o))), t.patternImageCanvas.width = a.width, t.patternImageCanvas.height = a.height, t.patternImageCTX.drawImage(t.loadobj.img, 0, 0, a.width, a.height), t.shadowCanvas.width = t.mDIM.width, t.shadowCanvas.height = t.mDIM.height, t.pattern = t.shadowCTX.createPattern(t.patternImageCanvas, t.bgrepeat), t.shadowCTX.fillStyle = t.pattern, t.shadowShifts = {
        h: t.bgposition.split(" ")[0],
        v: t.bgposition.split(" ")[1]
      }, t.shadowShifts.hperc = i.isNumeric(parseInt(t.shadowShifts.h)) ? parseInt(t.shadowShifts.h) / 100 * t.mDIM.width : 0, t.shadowShifts.vperc = i.isNumeric(parseInt(t.shadowShifts.v)) ? parseInt(t.shadowShifts.v) / 100 * t.mDIM.height : 0, t.shadowShifts.x = "left" === t.shadowShifts.h ? 0 : "center" === t.shadowShifts.h || "50%" == t.shadowShifts.h ? "repeat" == t.bgrepeat || "repeat-x" == t.bgrepeat ? t.mDIM.width / 2 - a.width / 2 - Math.ceil(t.mDIM.width / 2 / a.width) * a.width : t.mDIM.width / 2 - a.width / 2 : "right" === t.shadowShifts.h ? "repeat" == t.bgrepeat || "repeat-x" == t.bgrepeat ? -(a.width - t.mDIM.width % a.width) : t.mDIM.width - a.width : "repeat" == t.bgrepeat || "repeat-x" == t.bgrepeat ? -(a.width - t.shadowShifts.hperc % a.width) : t.shadowShifts.hperc, t.shadowShifts.y = "top" === t.shadowShifts.v ? 0 : "center" === t.shadowShifts.v || "50%" == t.shadowShifts.v ? "repeat" == t.bgrepeat || "repeat-y" == t.bgrepeat ? t.mDIM.height / 2 - a.height / 2 - Math.ceil(t.mDIM.height / 2 / a.height) * a.height : t.mDIM.height / 2 - a.height / 2 : "bottom" === t.shadowShifts.v ? "repeat" == t.bgrepeat || "repeat-y" == t.bgrepeat ? -(a.height - t.mDIM.height % a.height) : t.mDIM.height - a.height : "repeat" == t.bgrepeat || "repeat-y" == t.bgrepeat ? -(a.height - t.shadowShifts.vperc % a.height) : t.shadowShifts.vperc, t.shadowCTX.translate(t.shadowShifts.x, t.shadowShifts.y), t.shadowCTX.fillRect(0, 0, t.mDIM.width - t.shadowShifts.x, t.mDIM.height - t.shadowShifts.y);
    },
    getCanvasGradients: function getCanvasGradients(e, t) {
      if (t.bgcolor.indexOf("gradient") >= 0) {
        t.gradient = null == t.gradient || _R_is_Editor ? i.getGradients(t.bgcolor) : t.gradient, t.shadowGrd = "radialGradient" === t.gradient.type ? t.shadowCTX.createRadialGradient(t.mDIM.width / 2, t.mDIM.height / 2, 0, t.mDIM.width / 2, t.mDIM.height / 2, Math.max(t.mDIM.width / 2, t.mDIM.height / 2)) : i.calcLinearGradient(t.shadowCTX, t.shadowCanvas.width, t.shadowCanvas.height, t.gradient.deg);
        for (var a = 0; a < t.gradient.stops.length; a += 2) t.shadowGrd.addColorStop(t.gradient.stops[a + 1], t.gradient.stops[a]);
        t.shadowCTX.clearRect(0, 0, t.mDIM.width, t.mDIM.height), t.shadowCTX.fillStyle = t.shadowGrd, t.shadowCTX.fillRect(0, 0, t.mDIM.width, t.mDIM.height);
      } else t.shadowCTX.fillStyle = t.bgcolor, t.shadowCTX.fillRect(0, 0, t.mDIM.width, t.mDIM.height);
    },
    cNS: function cNS(e) {
      var i;
      for (i in e.n = document.createElementNS("http://www.w3.org/2000/svg", e.n), e.v) e.n.setAttributeNS(null, i.replace(/[A-Z]/g, function (e, i, t, a) {
        return "-" + e.toLowerCase();
      }), e.v[i]);
      for (i in void 0 !== e.c && e.n.setAttribute("class", e.c), void 0 !== e.id && (e.n.id = e.id), void 0 !== e.t && (e.n.textContent = e.t), e.s) e.s.hasOwnProperty(i) && (e.n.style[i] = e.s[i]);
      return e.n;
    },
    rgbToHex: function rgbToHex(e) {
      return "#" + l(e[0]) + l(e[1]) + l(e[2]);
    },
    getSVGGradient: function getSVGGradient(e) {
      if (void 0 === e) return e;
      if (_R_is_Editor && (e = RSColor.convert(e)), -1 == e.indexOf("gradient")) return e;
      var t = i.getGradients(e);
      void 0 === i.gradSVG && (i.gradSVG = i.cNS({
        n: "svg",
        id: "tp_svg_gradients",
        s: {
          width: "100%",
          height: "100%",
          opacity: 0,
          pointerEvents: "none"
        }
      }), i.gradSVG.setAttribute("viewBox", "0 0 1 1"), i.gradSVG.setAttribute("preserveAspectRatio", "none"), document.body.appendChild(i.gradSVG), i.svgGradients = []);
      for (var a = !1, r = JSON.stringify(e), o = 0; o < i.svgGradients.length; o++) a || i.svgGradients[o].src == r && (a = !0, e = i.svgGradients[o].url);
      if (!a) {
        var s,
          n,
          d,
          l = "radialGradient" === t.type ? 0 : t.deg * (Math.PI / 180),
          c = "radialGradient" === t.type ? 0 : {
            x1: Math.round(50 + 50 * Math.sin(l)) + "%",
            y1: Math.round(50 + 50 * Math.cos(l)) + "%",
            x2: Math.round(50 + 50 * Math.sin(l + Math.PI)) + "%",
            y2: Math.round(50 + 50 * Math.cos(l + Math.PI)) + "%"
          };
        d = i.cNS({
          n: t.type,
          id: "tp_svg_gradient_" + i.svgGradients.length,
          v: "radialGradient" === t.type ? void 0 : {
            gradientUnits: "userSpaceOnUse",
            x1: c.x1,
            y1: c.y1,
            x2: c.x2,
            y2: c.y2
          }
        });
        for (var p = 0; p <= t.stops.length / 2; p += 2) n = tpGS.gsap.utils.splitColor(t.stops[p]), s = i.cNS({
          n: "stop",
          v: {
            offset: 100 * t.stops[p + 1] + "%",
            stopColor: i.rgbToHex(n),
            stopOpacity: n.length > 3 ? n[3] : 1
          }
        }), d.appendChild(s);
        i.gradSVG.appendChild(d), e = "url(#tp_svg_gradient_" + i.svgGradients.length + ")", i.svgGradients.push({
          url: e,
          src: r,
          g: d
        });
      }
      return e;
    },
    getGradients: function getGradients(e) {
      return e.indexOf("radial-gradient") >= 0 ? {
        stops: i.getGradientColorStopPoints(e.split("radial-gradient(ellipse at center, ")[1]),
        type: "radialGradient",
        deg: 0
      } : -1 !== e.indexOf("gradient") ? i.getLinearGradientStops(e) : e;
    },
    getLinearGradientStops: function getLinearGradientStops(e) {
      var i = e.split("linear-gradient(")[1];
      _R_is_Editor && (i = (i = i.split(", ").join(",")).split(",rgba").join(", rgba"));
      var t = i.split("deg, ");
      for (var a in i = (t.length > 1 ? t[1] : t[0]).split(" "), t = t.length > 1 ? t[0] : 180, i) i.hasOwnProperty(a) && i[a].indexOf("%") >= 0 && (i[a] = "" + Math.round(100 * parseFloat(i[a].split("%,")[0].split("%)")[0])) / 1e4);
      return {
        stops: i,
        deg: t,
        type: "linearGradient"
      };
    },
    getGradientColorStopPoints: function getGradientColorStopPoints(e) {
      var i = /rgb([\s\S]*?)%/g,
        t = [],
        a = [];
      do {
        (o = i.exec(e)) && t.push(o[0]);
      } while (o);
      for (var r = 0; r < t.length; r++) {
        var o = t[r],
          s = (e = /rgb([\s\S]*?)\)/.exec(o), /\)([\s\S]*?)%/.exec(o));
        e[0] && (e = e[0]), s[1] && (s = s[1]), a.push(e), a.push(parseFloat(s) / 100);
      }
      return a;
    },
    calcLinearGradient: function calcLinearGradient(e, i, t, a) {
      a = a * Math.PI / 180 + Math.PI / 2;
      for (var r, o, s, n, d = i / 2, l = t / 2, c = Math.sqrt(d * d + l * l), h = {
          x1: Math.cos(a) * c + d,
          y1: Math.sin(a) * c + l,
          x2: d,
          y2: l
        }, m = [g({
          x: 0,
          y: 0
        }, a), g({
          x: i,
          y: 0
        }, a), g({
          x: i,
          y: t
        }, a), g({
          x: 0,
          y: t
        }, a)], v = [], f = 0; f < m.length; f++) v.push(u(m[f], h));
      if (p(d, l, v[0].x, v[0].y) > p(d, l, v[1].x, v[1].y) ? (r = v[0].x, o = v[0].y) : (r = v[1].x, o = v[1].y), p(d, l, v[2].x, v[2].y) > p(d, l, v[3].x, v[3].y) ? (s = v[2].x, n = v[2].y) : (s = v[3].x, n = v[3].y), Math.round(100 * Math.atan2(l - o, d - r)) / 100 === Math.round(a % (2 * Math.PI) * 100) / 100) {
        var y = r,
          w = o;
        r = s, o = n, s = y, n = w;
      }
      return e.createLinearGradient(Math.round(r), Math.round(o), Math.round(s), Math.round(n));
    },
    transitions: {
      filter: {
        update: function update(e, i, t) {
          if (void 0 !== e && void 0 !== e.tl) {
            var a = void 0 !== t || void 0 !== e.tl.blur ? " blur(" + (void 0 !== t ? t : 0 + e.tl.blur !== void 0 ? e.tl.blur : 0) + "px)" : "";
            i.canvas.style.filter = void 0 === e.tl.filter ? "" + a : e.tl.filter + a;
          }
        },
        extendTimeLine: function extendTimeLine(e, i, t) {
          if (null != i) {
            var a = void 0 !== i.g && "0%" !== i.g && 0 !== i.g ? ("" === a ? "" : " ") + "grayscale(_g_%)" : "";
            a += void 0 !== i.h && "100%" !== i.h && 100 !== i.h ? ("" === a ? "" : " ") + "brightness(_h_%)" : "", a += void 0 !== i.s && "0px" !== i.s && 0 !== i.s ? ("" === a ? "" : " ") + "sepia(_s_%)" : "", a += void 0 !== i.c && 100 !== i.c ? ("" === a ? "" : " ") + "contrast(_c_%)" : "", "" !== (a += void 0 !== i.i && 0 !== i.i ? ("" === a ? "" : " ") + "invert(_i_%)" : "") && (i.tl = {
              filter: a.replace("_g_", parseFloat(i.g)).replace("_h_", parseFloat(i.h)).replace("_s_", parseFloat(i.s)).replace("_c_", parseFloat(i.c)).replace("_i_", parseFloat(i.i))
            }), void 0 !== i.b && "0px" !== i.b && 0 !== i.b && (void 0 === i.tl ? i.tl = {
              blur: parseFloat(i.b)
            } : i.tl.blur = parseFloat(i.b)), void 0 !== i.tl && (e.add(tpGS.gsap.to(i.tl, i.ms / i.sec, void 0 === i.tl.filter ? {
              blur: 0
            } : void 0 === i.tl.blur ? {
              filter: a.replace("_g_", "0").replace("_h_", "100").replace("_s_", "0").replace("_c_", 100).replace("_i_", 0),
              ease: i.e
            } : {
              blur: 0,
              filter: a.replace("_g_", "0").replace("_h_", "100").replace("_s_", "0").replace("_c_", 100).replace("_i_", 0),
              ease: i.e
            }), 0), t.canvasFilter = !0);
          }
        }
      },
      slidingoverlay: {
        getBasic: function getBasic() {
          return i.getBasic({
            attr: ["x", "y"],
            in: {
              m: !0,
              o: -1,
              _xy: 20,
              _gxys: 10,
              _gxye: -10,
              zIndex: 20,
              e: "power1.inOut"
            },
            out: {
              m: !0,
              reversed: !1,
              _xy: -100,
              o: 0,
              zIndex: 10,
              e: "power1.inOut"
            }
          });
        },
        updateAnim: function updateAnim(e, t, a) {
          var r = void 0 !== t.in.x && 0 !== t.in.x && "0%" !== t.in.x ? "x" : "y";
          t.in["g" + r + "s"] = i.SATools.getOffset(t.in[r], t.in._gxys, a, 1) + "%", t.in["g" + r + "e"] = i.SATools.getOffset(t.in[r], t.in._gxye, a, 1) + "%", t.out[r] = i.SATools.getOffset(t.in[r], t.out._xy, a, 1) + "%", t.in[r] = i.SATools.getOffset(t.in[r], t.in._xy, a, 1) + "%";
          var o = parseInt(t.in[r]) >= 0;
          return t.in.d = "x" === r ? o ? "left" : "right" : o ? "up" : "down", t;
        },
        beforeDraw: function beforeDraw(e, i, t, a) {
          void 0 !== t.d && (t._dxs = "right" === t.d ? 0 + t.mw : "left" === t.d ? 0 - t.mw : 0, t._dys = "down" === t.d ? 0 + t.mh : "up" === t.d ? 0 - t.mh : 0, t._xs = "left" === t.d ? 0 - t.mw : 0, t._ys = "up" === t.d ? 0 - t.mh : 0, t._xe = "right" === t.d ? a.SLOT.OW + t.mw : "left" === t.d ? a.SLOT.OW - t.mw : a.SLOT.OW, t._ye = "down" === t.d ? a.SLOT.OH + t.mh : "up" === t.d ? a.SLOT.OH - t.mh : a.SLOT.OH, i.beginPath(), i.rect("left" === t.d ? Math.max(0, t._xs) : "right" === t.d ? Math.min(0, t._xs) : 0, "up" === t.d ? Math.max(0, t._ys) : "down" === t.d ? Math.min(0, t._ys) : 0, "left" === t.d ? Math.max(a.SLOT.OW, t._xe) : "right" === t.d ? Math.min(a.SLOT.OW, t._xe) : t._xe, "up" === t.d ? Math.max(a.SLOT.OH, t._ye) : "down" === t.d ? Math.min(a.SLOT.OH, t._ye) : t._ye), i.clip());
        },
        afterDraw: function afterDraw(e, i, t, a, r) {
          void 0 !== t.d && (i.save(), i.beginPath(), i.rect(Math.max(0, t._dxs), Math.max(0, t._dys), t._xe, t._ye), i.clip(), i.save(), i.transform(r.csx, r.ssx, r.ssy, r.csy, .5 * a.SLOT.OW + t.x + t.sgx, .5 * a.SLOT.OH + t.y + t.sgy), i.drawImage(void 0 !== a.shadowCanvas ? a.shadowCanvas : a.loadobj.img, 0, 0, a.SLOT.OW, a.SLOT.OH, t.sgx - a.SLOT.OW / 2, t.sgy - a.SLOT.OH / 2, a.SLOT.OW, a.SLOT.OH), i.restore(), i.fillStyle = "rgba(0,0,0,0.6)", i.fillRect(t.gx, t.gy, a.SLOT.OW, a.SLOT.OH), i.restore());
        },
        extendTimeLine: function extendTimeLine(e, t, a, r, o, s) {
          "in" !== o.direction || void 0 === r.gxe && void 0 === r.gye || (jQuery.extend(!0, a[0], {
            d: r.d,
            gx: void 0 === r.gxs ? 0 : 2 * i.SATools.getOffset(r.gxs, s.width, o.sdir, 0),
            gy: void 0 === r.gys ? 0 : 2 * i.SATools.getOffset(r.gys, s.height, o.sdir, 0),
            sgx: void 0 === r.gxs ? 0 : i.SATools.getOffset(r.gxs, s.width, o.sdir, 0),
            sgy: void 0 === r.gys ? 0 : i.SATools.getOffset(r.gys, s.height, o.sdir, 0),
            mw: 0 - s.width,
            mh: 0 - s.height
          }), t.add(tpGS.gsap.to(a, r.ms / r.sec, {
            gx: void 0 === r.gxe ? 0 : 2 * i.SATools.getOffset(r.gxe, s.width, o.sdir, 0),
            gy: void 0 === r.gye ? 0 : 2 * i.SATools.getOffset(r.gye, s.height, o.sdir, 0),
            sgx: void 0 === r.gxe ? 0 : 2 * i.SATools.getOffset(r.gxe, s.width, o.sdir, 0),
            sgy: void 0 === r.gye ? 0 : 2 * i.SATools.getOffset(r.gye, s.height, o.sdir, 0),
            mw: s.width,
            mh: s.height,
            ease: r.e
          }), 0));
        }
      },
      motionFilter: {
        init: function init(e, i) {
          return void 0 !== i && parseFloat(i) > 0 ? (i = parseFloat(i), e.fmExists = !0, e.fmShadow = void 0 === e.fmShadow ? document.createElement("canvas") : e.fmShadow, e.fmCtx = e.fmShadow.getContext("2d"), e.fmShadow.width = e.ctx.canvas.width, e.fmShadow.height = e.ctx.canvas.height, e.fmCtx.globalAlpha = tpGS.gsap.utils.mapRange(100, 0, 40, 0, i) / 100, e.fmCtx.clearRect(0, 0, e.ctx.canvas.width, e.ctx.canvas.height)) : e.fmExists = !1, i;
        },
        render: function render(e, i) {
          "partial" === i && (e.fmCtx.globalCompositeOperation = "source-over"), e.fmCtx.drawImage(e.canvas, 0, 0, e.canvas.width, e.canvas.height), e.ctx.clearRect(0, 0, e.canvas.width, e.canvas.height), e.ctx.drawImage(e.fmCtx.canvas, 0, 0, e.canvas.width, e.canvas.height), "partial" === i && (e.fmCtx.globalCompositeOperation = "source-atop"), "partial" !== i && "full" !== i || (e.fmCtx.fillStyle = "rgba(255, 255, 255, 0.1)", e.fmCtx.fillRect(0, 0, e.canvas.width, e.canvas.height));
        },
        clearFull: function clearFull(e, i) {
          e.fmExists && void 0 !== e.fmCtx && (e.ctx.clearRect(0, 0, e.canvas.width, e.canvas.height), e.fmCtx.clearRect(0, 0, e.canvas.width, e.canvas.height), void 0 !== i && i.render(i.time(), !0, !0));
        },
        complete: function complete(e) {
          e.fmShadow && e.fmShadow.remove();
        }
      },
      d3: {
        ticker: function ticker(e, i, t) {
          if (void 0 !== e.helper) {
            var a = e.smi * ("in" === t ? e.helper.oo : e.helper.o),
              r = e.sma * ("in" === t ? e.helper.oo : e.helper.o);
            if (e.gradient = "vertical" === e.d ? "in" === t ? i.ctx.createLinearGradient(0, 0, 0, i.canvas.height) : i.ctx.createLinearGradient(0, i.canvas.height, 0, 0) : "in" === t ? i.ctx.createLinearGradient(0, 0, i.canvas.width, 0) : i.ctx.createLinearGradient(i.canvas.width, 0, 0, 0), e.gradient.addColorStop(0, "rgba(" + e.sc + "," + a + ")"), e.gradient.addColorStop(e.sl, "rgba(" + e.sc + "," + r + ")"), i.ctx.fillStyle = e.gradient, i.ctx.fillRect(0, 0, i.canvas.width, i.canvas.height), void 0 !== i.cube && i.cube.ctx) {
              var o = void 0 !== e.roomhelper && !1 !== e.roomhelper && (90 - e.roomhelper.r) / 90;
              a = !1 !== o ? o : e.smi * e.helper.o, r = !1 !== o ? o : e.sma * e.helper.o, i.cube.ctx.clearRect(0, 0, i.cube.ctx.canvas.width, i.cube.ctx.canvas.height), e.gradientW = !1 !== o ? "vertical" === e.d ? e.t < 0 && 1 === e.sdir || e.t > 0 && -1 === e.sdir ? i.ctx.createRadialGradient(0, i.cube.ctx.canvas.width / 2, 0, 0, 0, 2 * i.cube.ctx.canvas.width) : i.ctx.createRadialGradient(i.cube.ctx.canvas.width, 0, 0, 0, 0, 2 * i.cube.ctx.canvas.width) : e.t > 0 && 1 === e.sdir || e.t < 0 && -1 === e.sdir ? i.ctx.createRadialGradient(i.cube.ctx.canvas.width / 2, i.cube.ctx.canvas.height, 0, i.cube.ctx.canvas.width / 2, i.cube.ctx.canvas.height, i.cube.ctx.canvas.width) : i.ctx.createRadialGradient(i.cube.ctx.canvas.width / 2, .2 * i.cube.ctx.canvas.height, 0, i.cube.ctx.canvas.width / 2, .2 * i.cube.ctx.canvas.height, i.cube.ctx.canvas.width) : "vertical" === e.d ? i.ctx.createLinearGradient(0, 0, 0, i.cube.ctx.canvas.height) : i.ctx.createLinearGradient(0, 0, i.cube.ctx.canvas.width, 0), e.gradientW.addColorStop(0, "rgba(" + e.sc + "," + (!1 !== o ? "a" === e.DIR ? r : 0 : "a" === e.DIR ? 0 : r) + ")"), e.gradientW.addColorStop(1, "rgba(" + e.sc + "," + (!1 !== o ? "a" === e.DIR ? 0 : r : "a" === e.DIR ? r : 0) + ")"), i.cube.ctx.fillStyle = e.gradientW, i.cube.ctx.fillRect(0, 0, i.cube.ctx.canvas.width, i.cube.ctx.canvas.height);
            }
          }
        },
        setWall: function setWall(e, i, t, a, r, o) {
          return e.TL = tpGS.gsap.timeline(), e.TL.add(tpGS.gsap.to(e.c, .2, {
            display: "block"
          }), 0), "rotationX" === t ? (e.ctx.canvas.width = a.w, e.ctx.canvas.height = a.w, e.TL.add(tpGS.gsap.set(e.w, {
            backgroundColor: r,
            width: a.w,
            height: a.w,
            transformOrigin: "50% 50% -" + a.w / 2 + "px",
            x: 0,
            y: i > 0 ? -(a.w - a.h) : 0,
            rotationX: i > 0 ? -90 : 90,
            rotationY: 0
          }), 0)) : (e.ctx.canvas.width = o ? a.w : a.h, e.ctx.canvas.height = a.h, e.TL.add(tpGS.gsap.set(e.w, {
            backgroundColor: r,
            width: o ? a.w : a.h,
            height: a.h,
            transformOrigin: "50% 50% -" + (o ? a.w : a.h) / 2 + "px",
            x: i < 0 ? a.w - a.h : 0,
            y: 0,
            rotationX: 0,
            rotationY: i > 0 ? -90 : 90
          }), 0)), e.TL;
        },
        buildCube: function buildCube(e) {
          e.cube = {
            c: document.createElement("div"),
            w: document.createElement("canvas")
          }, e.cube.ctx = e.cube.w.getContext("2d"), e.cube.c.className = "rs_fake_cube", e.cube.w.className = "rs_fake_cube_wall", tpGS.gsap.set(e.cube.c, {
            width: e.mDIM.w,
            height: e.mDIM.h
          }), tpGS.gsap.set(e.cube.w, {
            width: e.mDIM.w,
            height: e.mDIM.h,
            backgroundColor: "#ccc"
          }), e.cube.c.appendChild(e.cube.w), e.sbg.appendChild(e.cube.c);
        },
        cubeTL: function cubeTL(e, t, a, r) {
          if ("none" !== t.f && void 0 !== t.f) {
            a.sbg.style.transformStyle = "preserve-3d";
            var o = tpGS.gsap.timeline(),
              s = "incube" === t.f ? 1 : -1,
              n = "incube" === t.f || "cube" === t.f,
              d = "fly" === t.f ? -30 : 90,
              l = "turn" !== t.f && !1 !== t.t && (_R_is_Editor || !0 === i[e].firstSlideAnimDone),
              c = -1 * t.z,
              p = {},
              g = {
                z: l ? 0 : c,
                ease: "power1.inOut"
              },
              u = {
                ease: t.e
              },
              h = [a.canvas],
              m = n ? "50% 50% " : "20% 20% ",
              v = "rotationX",
              f = "rotationY",
              y = "y",
              w = "height",
              b = t.fd;
            if ("vertical" !== t.d ? (v = "rotationY", f = "rotationX", y = "x", w = "width", t.DIR = 1 === t.sdir ? "b" : "a") : t.DIR = 1 === t.sdir ? "a" : "b", w = "width" === w ? "w" : "height" === w ? "h" : w, "turn" === t.f ? (d = "vertical" === t.d ? -120 : 120, m = "vertical" === t.d ? 1 === t.sdir ? "in" === r ? "0% 0% 0%" : "0% 100% 0%" : "in" === r ? "0% 100% 0%" : "0% 0% 0%" : 1 === t.sdir ? "in" === r ? "0% 0% 0%" : "100% 0% 0%" : "in" === r ? "100% 0% 0%" : "0% 0% 0%", g.z = 0, u.ease = "out" === r ? "power3.out" : u.ease, b = "out" === r ? b / 2 : b) : m += s * a.mDIM[w] / 2 + "px", u[v] = 0, u[y] = 0, "in" === r ? p[v] = d * t.sdir : u[v] = -d * t.sdir, "fly" === t.f) {
              var _ = void 0 === t.fz ? 20 * Math.random() - 10 : parseInt(t.fz);
              "in" === r ? (p[y] = a.mDIM[w] * (void 0 === t.fdi ? 1.5 : parseFloat(t.fdi)) * t.sdir, p.rotateZ = t.sdir * _, u.rotateZ = 0) : (u[y] = a.mDIM[w] * (void 0 === t.fdo ? 2 : parseFloat(t.fdo)) * t.sdir * -1, u.rotateZ = t.sdir * _ * -1);
            }
            if (a.sbg.style.perspective = l ? "2500px" : "1500px", l) {
              var S = {
                  z: c * ("fly" === t.f ? 1.5 : 3),
                  ease: "power1.inOut"
                },
                x = {
                  z: 0,
                  ease: "power1.inOut"
                };
              S[f] = -1 * t.t, x[f] = 0, t.roomhelper = {
                r: 0
              }, o.add(tpGS.gsap.set(_R_is_Editor ? RVS.SBGS[RVS.S.slideId].wrap : a.wrap[0], {
                perspective: 1200,
                transformStyle: "preserve-3d",
                transformOrigin: m
              }), 0), o.add(tpGS.gsap.to(a.sbg, 3 * t.md, S), 0), o.add(tpGS.gsap.to(a.sbg, 3 * t.md, x), b - t.md), o.add(tpGS.gsap.to(t.roomhelper, 3 * t.md, {
                r: Math.abs(t.t)
              }), 0), o.add(tpGS.gsap.to(t.roomhelper, 3 * t.md, {
                r: 0
              }), b - t.md), "in" === r && 1 !== s && n && (void 0 === a.cube && i.transitions.d3.buildCube(a), o.add(i.transitions.d3.setWall(a.cube, S[f], f, a.mDIM, t.c), 0), h.push(a.cube.c));
            } else t.roomhelper = !1, o.add(tpGS.gsap.set(_R_is_Editor ? RVS.SBGS[RVS.S.slideId].wrap : a.wrap[0], {
              perspective: "none",
              transformStyle: "none",
              transformOrigin: "50% 50%"
            }), 0), !_R_is_Editor && !0 !== i[e].firstSlideAnimDone && n && (void 0 === a.cube && i.transitions.d3.buildCube(a), o.add(i.transitions.d3.setWall(a.cube, p[v], v, a.mDIM, t.c, !0), 0), o.add(tpGS.gsap.fromTo(a.cube.w, 4 * t.md, {
              opacity: 0
            }, {
              opacity: 1
            }), 0), h.push(a.cube.c));
            return t.helper = {
              o: 0,
              oo: 1
            }, o.add(tpGS.gsap.to(t.helper, b, {
              o: 1,
              oo: 0,
              ease: t.e
            }), t.md + 0), o.add(tpGS.gsap.set(h, jQuery.extend(!0, {}, p, {
              force3D: !0,
              transformOrigin: m
            })), 0), "turn" !== t.f && o.add(tpGS.gsap.to(h, 3 * t.md, g), 0), o.add(tpGS.gsap.to(h, b, u), t.md + 0), "turn" !== t.f && o.add(tpGS.gsap.to(h, 3 * t.md, {
              z: 0,
              ease: "power1.inOut"
            }), b - t.md), "out" === r && 1 !== s && o.add(tpGS.gsap.to(h, 2 * t.md, {
              opacity: 0
            }), t.dur - 2 * t.md), o;
          }
        }
      }
    },
    animatedCanvasUpdate: function animatedCanvasUpdate(e, t) {
      t.cDIMS = i.getBGCanvasDetails(e, t), t.canvas.style.backgroundColor = "transparent", t.canvas.style.opacity = 1, t.canvas.width !== t.mDIM.width && (t.canvas.width = t.mDIM.width), t.canvas.height !== t.mDIM.height && (t.canvas.height = t.mDIM.height), _R_is_Editor || !0 !== i[e].clearModalBG || (t.ctx.clearRect(0, 0, t.canvas.width, t.canvas.height), i[e].clearModalBG = !1, t.sbg.parentNode.style.opacity = 1), t.col = t.col || 1, t.row = t.row || 1, t.SLOT = jQuery.extend(!0, {
        s: {},
        c: {}
      }, a(e, t.col, t.row, t.mDIM, "OW", "OH")), t.SLOT.DX = 0 - t.SLOT.OW / 2, t.SLOT.DY = 0 - t.SLOT.OH / 2, t.row = Math.ceil(t.mDIM.height / t.SLOT.OH) || 1, void 0 !== t.callFromAnimatedCanvasUpdate && t.callFromAnimatedCanvasUpdate();
    },
    slideAnimFinished: function slideAnimFinished(e, t, a, r) {
      void 0 !== t && (void 0 !== t.bgvid && t.bgvid.length > 0 && "out" === a.direction && (t.drawVideoCanvasImagesRecall = !1, i.stopVideo(t.bgvid, e), t.bgvid[0].style.display = "none", t.bgvid[0].style.zIndex = 0), "in" === a.direction && (i.transitions.motionFilter.complete(t), t.ctx.canvas.style.filter = "none", tpGS.gsap.set(a.slide, {
        zIndex: 20
      }), delete t.animateDirection, t.bgvid.length > 0 && (t.isHTML5 || (i.resetVideo(t.bgvid, e), i.playVideo(t.bgvid, e, !0)), tpGS.gsap.set(t.bgvid[0], {
        zIndex: 30,
        display: "block",
        opacity: 1
      }))), "out" === a.direction ? (tpGS.gsap.set(a.slide, {
        zIndex: 10
      }), tpGS.gsap.set(t.canvas, {
        rotationX: 0,
        rotationY: 0,
        rotationZ: 0,
        x: 0,
        y: 0,
        z: 0,
        opacity: 1
      }), t.currentState = void 0) : t.currentState = "idle", void 0 !== t.cube && (t.cube.c.style.display = "none"), "in" === a.direction && (i.updateSlideBGs(e, t.skeyindex, t), void 0 === t.panzoom || _R_is_Editor || i.startPanZoom(i[e].pr_next_bg, e, void 0 !== i[e].panzoomTLs[t.skeyindex] ? i[e].panzoomTLs[t.skeyindex].progress() : 0, t.skeyindex, "play", t.key), void 0 !== a.BG && !0 !== r && a.BG.ctx.clearRect(0, 0, 2 * t.canvas.width, 2 * t.canvas.height)));
    },
    animateCore: function animateCore(e, t, a, r) {
      var o,
        s,
        n,
        d,
        l = t.canvas,
        c = t.ctx,
        p = 0;
      if (t.col = a.col, t.row = a.row, _R_is_Editor && t.three) {
        for (t.canvas.style.display = "block"; t.three.scene.children.length > 0;) t.three.scene.remove(t.three.scene.children[0]);
        t.three.canvas.parentNode.removeChild(t.three.canvas), t.three = void 0;
      }
      i.animatedCanvasUpdate(e, t), a.row = t.row, t.animateDirection = r.direction, r.delay = void 0 === r.delay ? 0 : r.delay, n = a.col * a.row, d = Array(n), void 0 === t.help_canvas && "out" === r.direction && void 0 !== r.bgColor && (t.help_canvas = document.createElement("canvas"), t.help_ctx = t.help_canvas.getContext("2d")), "out" === r.direction && void 0 !== r.bgColor && (t.help_canvas.width = t.mDIM.width, t.help_canvas.height = t.mDIM.height, t.help_ctx.fillStyle = r.bgColor, t.help_ctx.fillRect(0, 0, t.mDIM.width, t.mDIM.height)), a.mo = i.transitions.motionFilter.init(t, a.mo), a.dur = a.ms / a.sec, void 0 !== r.d3 && (r.d3.dur = a.dur, r.d3.fd = .7 * a.dur, r.d3.md = .15 * a.dur, r.d3.sdir = r.sdir), t.SLOT.c = {
        ws: 0,
        hs: 0,
        wd: 0,
        hd: 0
      }, a.mo > 0 && _R_is_Editor && c.clearRect(0, 0, l.width, l.height);
      var g = tpGS.gsap.timeline({
        onUpdate: function onUpdate() {
          if (p = 0, a.mo > 0 ? i.transitions.motionFilter.render(t, a.moo) : c.clearRect(0, 0, l.width, l.height), t.help_canvas && "out" === r.direction && c.drawImage(t.help_canvas, 0, 0), (r.filter && r.filter.u || !_R_is_Editor) && i.transitions.filter.update(r.filter, c, t.canvasFilterBlur), _R_is_Editor && 0 !== a.zIndex && void 0 !== a.zIndex && tpGS.gsap.set(r.slide, {
            zIndex: a.zIndex
          }), void 0 !== t.shadowCanvas) for (o = 0; o < a.col; o++) for (t.SLOT.SX = t.SLOT.OW * o, t.SLOT.tw = t.SLOT.OW * (o + .5), t.SLOT.c.wd = t.mDIM.width - (t.SLOT.tw + t.SLOT.DX + t.SLOT.OW), t.SLOT.c.wd = t.SLOT.c.wd < 0 ? t.SLOT.c.wd : 0, t.SLOT.DW = t.SLOT.SW = t.SLOT.OW + t.SLOT.c.wd, s = 0; s < a.row; s++) {
            c.save();
            var n = -Math.PI / 180 * d[p].r,
              g = 0 !== a.r ? Math.cos(n) * d[p].sx : d[p].sx,
              u = 0 !== a.r ? Math.cos(n) * d[p].sy : d[p].sy,
              h = 0 !== a.r ? Math.sin(n) * d[p].sx : 0,
              m = 0 !== a.r ? Math.sin(n) * -d[p].sy : 0;
            t.SLOT.SY = t.SLOT.OH * s, t.SLOT.th = t.SLOT.OH * (s + .5), i.transitions[r.effect] && i.transitions[r.effect].beforeDraw && i.transitions[r.effect].beforeDraw(e, c, d[p], t), a.m && (c.beginPath(), c.rect(t.SLOT.OW * o, t.SLOT.OH * s, t.SLOT.OW, t.SLOT.OH), c.clip()), c.transform(g, h, m, u, t.SLOT.tw + d[p].x, t.SLOT.th + d[p].y), c.globalAlpha = Math.max(0, d[p].o), t.SLOT.c.hd = t.mDIM.height - (t.SLOT.th + t.SLOT.DY + t.SLOT.OH), t.SLOT.c.hd = t.SLOT.c.hd < 0 ? t.SLOT.c.hd : 0, t.SLOT.DH = t.SLOT.SH = t.SLOT.OH + t.SLOT.c.hd, t.SLOT.SW > 1 && t.SLOT.SH > 1 && c.drawImage(t.shadowCanvas, t.SLOT.SX, t.SLOT.SY, t.SLOT.SW, t.SLOT.SH, t.SLOT.DX, t.SLOT.DY, t.SLOT.DW, t.SLOT.DH), c.restore(), i.transitions[r.effect] && i.transitions[r.effect].afterDraw && i.transitions[r.effect].afterDraw(e, c, d[p], t, {
              csx: g,
              csy: u,
              ssx: h,
              ssy: m
            }), p++;
          }
          void 0 !== r.d3 && r.d3.su && i.transitions.d3.ticker(r.d3, t, r.direction), t.currentState = "animating";
        },
        onComplete: function onComplete() {
          i.slideAnimFinished(e, t, r);
        }
      });
      if (a.col * a.row < 2 && (a.f = "start"), 0 !== a.zIndex && void 0 !== a.zIndex && g.add(tpGS.gsap.set(r.slide, {
        zIndex: parseInt(a.zIndex, 0)
      }), 0), a.m = "false" != a.m && !1 !== a.m, "in" === r.direction) {
        for (o = 0; o < n; o++) d[o] = {
          x: i.SATools.getOffset(a.x, a.m ? t.SLOT.OW : t.mDIM.width, r.sdir, o),
          y: i.SATools.getOffset(a.y, a.m ? t.SLOT.OH : t.mDIM.height, r.sdir, o),
          o: i.SATools.getSpecialValue(a.o, o, r.sdir),
          sx: i.SATools.getSpecialValue(a.sx, o, r.sdir),
          sy: i.SATools.getSpecialValue(a.sy, o, r.sdir),
          r: 0 !== a.r ? i.SATools.getSpecialValue(a.r, o, r.sdir) : 0
        };
        g.add(tpGS.gsap.to(d, a.dur, {
          o: 1,
          sx: 1,
          sy: 1,
          r: 0,
          x: 0,
          y: 0,
          ease: a.e,
          stagger: {
            amount: "nodelay" === a.f ? 0 : a.ms / a.stasec,
            grid: [a.col, a.row],
            from: "nodelay" === a.f ? "start" : a.f
          }
        }), r.delay), void 0 !== r.d3 && g.add(i.transitions.d3.cubeTL(e, r.d3, t, "in"), 0), i.transitions.filter.extendTimeLine(g, r.filter, t);
      } else {
        for (o = 0; o < n; o++) d[o] = {
          x: 0,
          y: 0,
          o: 1,
          sx: 1,
          sy: 1,
          r: 0
        };
        g.add(tpGS.gsap.to(d, a.dur, {
          o: function o(e) {
            return i.SATools.getSpecialValue(a.o, e, r.sdir);
          },
          sx: function sx(e) {
            return i.SATools.getSpecialValue(a.sx, e, r.sdir);
          },
          sy: function sy(e) {
            return i.SATools.getSpecialValue(a.sy, e, r.sdir);
          },
          r: 0 !== a.r && void 0 !== a.r ? function (e) {
            return i.SATools.getSpecialValue(a.r, e, r.sdir);
          } : 0,
          x: function x(e) {
            return i.SATools.getOffset(a.x, a.m ? t.SLOT.OW : t.mDIM.width, r.sdir, e) * (a.reversed ? -1 : 1);
          },
          y: function y(e) {
            return i.SATools.getOffset(a.y, a.m ? t.SLOT.OH : t.mDIM.height, r.sdir, e) * (a.reversed ? -1 : 1);
          },
          ease: a.e,
          stagger: {
            amount: "nodelay" === a.f ? 0 : a.ms / a.stasec,
            grid: [a.col, a.row],
            from: "nodelay" === a.f ? "start" : a.f
          }
        }), r.delay + (void 0 !== a.outdelay ? a.outdelay : 0)), void 0 !== r.d3 && g.add(i.transitions.d3.cubeTL(e, r.d3, t, "out"), 0);
      }
      i.transitions[r.effect] && i.transitions[r.effect].extendTimeLine && i.transitions[r.effect].extendTimeLine(e, g, d, a, r, t.mDIM), _R_is_Editor ? RVS.TL[RVS.S.slideId].slide.add(g, 0) : i[e].mtl.add(g, r.delay);
    }
  });
  var t = function t(e, _t4) {
      return void 0 !== _t4 && i.isNumeric(_t4) ? parseFloat(_t4, 0) : null == _t4 || "default" === _t4 || "d" === _t4 ? e : _t4;
    },
    a = function a(e, i, t, _a, r, o) {
      var s = {};
      return s[r] = Math.ceil(_a.width / i), s[o] = (_R_is_Editor, Math.ceil(_a.height / t)), s;
    },
    r = function r(e) {
      return null == e || 0 === e || NaN === e ? 1 : e;
    },
    o = function o(e, a) {
      _R_is_Editor || (i[e].duringslidechange = !0);
      var o,
        s = _R_is_Editor ? -1 : "arrow" == i[e].sc_indicator ? void 0 === i[e].sc_indicator_dir ? i[e].sdir : i[e].sc_indicator_dir : i[e].sdir,
        d = !!_R_is_Editor || void 0 !== i[e].pr_next_bg && i[e].pr_next_bg.length > 0 && void 0 !== i[e].pr_next_bg[0],
        l = !!_R_is_Editor || void 0 !== i[e].pr_active_bg && i[e].pr_active_bg.length > 0 && void 0 !== i[e].pr_active_bg[0],
        p = _R_is_Editor ? RVS.SBGS[RVS.S.slideId].n : d ? i[e].sbgs[i[e].pr_next_bg[0].dataset.key] : void 0,
        g = _R_is_Editor ? RVS.SBGS[RVS.S.slideId].c : l ? i[e].sbgs[i[e].pr_active_bg[0].dataset.key] : void 0;
      s = 1 === s ? -1 : 1, o = jQuery.extend(!0, {}, function (e, a, o) {
        var s = void 0 !== i.transitions[a.anim.e] && void 0 !== i.transitions[a.anim.e].getBasic ? i.transitions[a.anim.e].getBasic() : i.getBasic(),
          n = "";
        s.out = null == s.out ? {} : s.out, s.out.reversed = void 0 === a.out && (void 0 === s.out.reversed || s.out.reversed);
        void 0 !== a.iw && parseInt(a.iw, 0), void 0 !== a.ow && parseInt(a.ow, 0);
        for (var d in s.attr) n = s.attr[d], s.in[n] = t(s.in[n], a.in[n]), s.out[n] = s.out.reversed ? s.in[n] : void 0 === a.out ? s.out[n] : t(s.out[n], a.out[n]);
        return s.filter = void 0 !== a.filter ? jQuery.extend(!0, a.filter, a.filter) : s.filter, i.transitions[a.anim.e] && i.transitions[a.anim.e].updateAnim && (s = i.transitions[a.anim.e].updateAnim(e, s, o)), s.e = a.anim.e, void 0 !== s.in && (s.in.col = "random" === s.in.col ? tpGS.gsap.utils.random(1, 10, 1) : r(s.in.col), s.in.row = "random" === s.in.row ? tpGS.gsap.utils.random(1, 10, 1) : r(s.in.row)), void 0 !== s.out && (s.out.col = "random" === s.out.col ? tpGS.gsap.utils.random(1, 10, 1) : r(s.out.col), s.out.row = "random" === s.out.row ? tpGS.gsap.utils.random(1, 10, 1) : r(s.out.row)), s;
      }(e, a, s)), void 0 !== p.random && void 0 !== i.SLTR && void 0 !== g && (delete g.help_canvas, delete g.help_ctx), o.ms = t(void 0, void 0 === a.anim.ms ? 1e3 : a.anim.ms), o.f = t(void 0, a.anim.f), o.p = t(void 0, a.anim.p), o.d = t(void 0, a.anim.d), o.o = a.anim.o, void 0 !== a.d3 && (a.d3.t = void 0 !== a.d3.t && 0 !== a.d3.t && a.d3.t, a.d3.su = "true" == a.d3.su || 1 == a.d3.su, a.d3.su && (a.d3.smi = void 0 === a.d3.smi ? 0 : parseFloat(a.d3.smi), a.d3.sl = void 0 === a.d3.sl ? 1 : parseFloat(a.d3.sl), a.d3.sma = void 0 === a.d3.sma ? .5 : parseFloat(a.d3.sma), a.d3.sc = void 0 === a.d3.sc ? "0,0,0" : tpGS.gsap.utils.splitColor(a.d3.sc).join(",")), o.p = "none", void 0 !== o.in.row && void 0 !== o.in.col && o.in.row * o.in.col > 200 && (o.filter = void 0)), o.in.sec = void 0 === o.in.sec ? 1e3 : o.in.sec, o.in.stasec = void 0 === o.in.stasec ? void 0 === o.d ? 1500 : 100 * o.d : o.in.stasec, o.in.ms = "default" === o.ms || "d" === o.ms ? o.in.ms : "random" === o.ms ? Math.round(1e3 * Math.random() + 300) : null != o.ms ? parseInt(o.ms, 0) : o.in.ms, o.out.ms = o.in.ms, void 0 !== o.filter && (o.filter.ms = o.in.ms, o.filter.sec = o.in.sec, o.filter.e = void 0 === o.filter.e || "default" === o.filter.e ? o.in.e : o.filter.e), o.in.f = void 0 === o.f || "default" === o.f || "d" === o.f ? o.in.f : o.f, o.in.f = "slidebased" === o.in.f ? 1 == s ? "start" : "end" : "oppslidebased" === o.in.f ? 1 === s ? "end" : "start" : o.in.f, o.out.f = o.in.f, o.out = jQuery.extend(!0, {}, o.in, o.out), o.in.eng = o.out.eng = a.anim.eng, void 0 !== o.p && "none" !== o.p && (o.in.bg = "dark" === o.p ? "#000" : "light" === o.p ? "#fff" : "transparent", o.out.delay = "none" !== o.p ? function (e, i) {
        return e / 2.5;
      } : 0, 1 === o.out.o && 0 === o.out.x && 0 === o.out.y && (o.out.o = 0)), "forceinout" === o.o ? (o.in.zIndex = 20, o.out.zIndex = 10) : "outin" !== o.o && (1 !== o.in.o || 0 !== o.in.x || 0 !== o.in.y || void 0 === a.out || 1 === o.out.o && 0 === o.out.x && 0 === o.out.y) || (o.in.zIndex = 10, o.out.zIndex = 20), p.bgvid.length > 0 && (o.in = c(e, o.in, p, "in")), l && void 0 !== g.bgvid && g.bgvid.length > 0 && (o.out = c(e, o.out, g, "out")), void 0 !== o.out && (o.out.simplify || o.in.simplify) && (o.out = n(o.out)), o.in.simplify && (o.in = n(o.in)), _R_is_Editor || requestAnimationFrame(function () {
        i.generalObserver(i.ISM, !0);
      }), o.in.eng = void 0 === o.in.eng ? "animateCore" : o.in.eng, o.out.eng = void 0 === o.out.eng ? "animateCore" : o.out.eng, l && !0 !== o.out.skip && i[o.out.eng](e, g, o.out, {
        effect: o.e,
        slide: _R_is_Editor ? RVS.SBGS[RVS.S.slideId].c.sbg : i[e].pr_active_slide,
        direction: "out",
        delay: 0,
        bgColor: o.in.bg,
        sdir: s,
        filter: void 0,
        d3: a.d3,
        addOns: _R_is_Editor ? a.addOns : void 0
      }), !0 !== o.in.skip && i[o.in.eng](e, p, o.in, {
        effect: o.e,
        slide: _R_is_Editor ? RVS.SBGS[RVS.S.slideId].n.sbg : i[e].pr_next_slide,
        direction: "in",
        delay: l ? "function" == typeof o.out.delay ? o.out.delay(o.in.ms / 1e3, o.out.row * o.out.col) : o.out.delay : o.in.delay,
        BG: g,
        outslide: _R_is_Editor ? RVS.SBGS[RVS.S.slideId].c.sbg : i[e].pr_active_slide,
        sdir: s,
        filter: o.filter,
        d3: a.d3,
        addOns: _R_is_Editor ? a.addOns : void 0
      });
    },
    s = function s(e, t, a) {
      var r = e.height / e.width;
      if (a.ratio = a.conth / a.contw, a.ratio < r && "contain" === t.bgfit || a.ratio > r && "cover" === t.bgfit) a.height = e.width * a.ratio;else if (a.ratio > r && "contain" === t.bgfit || a.ratio < r && "cover" === t.bgfit) a.width = e.width * r / a.ratio;else if (a.ratio !== r || "contain" !== t.bgfit && "cover" !== t.bgfit) {
        var o = t.bgfit.split(" ");
        1 === o.length && (o[1] = o[0]), a.width = "auto" === o[0] ? a.contw : e.width * (parseInt(o[0], 0) / 100), a.height = "auto" === o[1] ? a.conth : a.width * a.ratio, t.usepattern = !0;
      } else a.width = e.width;
      var s = function (e, t, a) {
        return 1 === (a = a.split(" ")).length && (a[1] = a[0]), {
          x: "center" === a[0] || "50%" === a[0] ? (e.width - t.width) / 2 : "left" === a[0] ? 0 : "right" === a[0] ? e.width - t.width : i.isNumeric(a[0]) ? 0 : a[0].indexOf("%") >= 0 ? parseInt(a[0], 0) / 100 * e.width - parseInt(a[0], 0) / 100 * t.width : parseInt(a[0], 0),
          y: "center" === a[1] || "50%" === a[1] ? (e.height - t.height) / 2 : "top" === a[1] ? 0 : "bottom" === a[1] ? e.height - t.height : i.isNumeric(a[1]) ? 0 : a[1].indexOf("%") >= 0 ? parseInt(a[1], 0) / 100 * e.height - parseInt(a[1], 0) / 100 * t.height : parseInt(a[1], 0)
        };
      }(e, a, t.bgposition);
      return a.x = s.x, a.y = s.y, a;
    },
    n = function n(e) {
      return e.o = 0, e.r = 0, e.row = 1, e.col = 1, e.x = 0, e.y = 0, e.sx = 1, e.sy = 1, e;
    },
    d = function d(e) {
      return e = "false" !== e && !1 !== e && "off" !== e && void 0 !== e && 0 !== e && -1 !== e;
    },
    l = function l(e) {
      var i = e.toString(16);
      return 1 == i.length ? "0" + i : i;
    },
    c = function c(e, t, a, r) {
      return t.skip = !1, "in" === r ? a.isHTML5 ? (a.bgvid[0].style.display = "none", i.resetVideo(a.bgvid, e), a.animateDirection = "in", a.currentState = "animating", a.drawVideoCanvasImagesRecall = !0, i.updateVideoFrames(e, a, !0), i.playVideo(a.bgvid, e)) : (i[e].videos[a.bgvid[0].id].pauseCalled = !1, t.waitToSlideTrans = i[e].videos[a.bgvid[0].id].waitToSlideTrans, !0 !== a.poster ? (i.resetVideo(a.bgvid, e), i[e].videos[a.bgvid[0].id].prePlayForaWhile = !1, !0 !== t.waitToSlideTrans && i.playVideo(a.bgvid, e, !0), tpGS.gsap.fromTo(a.bgvid, t.ms / t.sec, {
        zIndex: 30,
        display: "block",
        opacity: 0
      }, {
        opacity: 1,
        zIndex: 30,
        display: "block"
      }), a.loadobj.bgColor = !0, a.bgcolor = "#000", t.simplify = !0) : (i[e].videos[a.bgvid[0].id].prePlayForaWhile = !1, i.resetVideo(a.bgvid, e), i.playVideo(a.bgvid, e), a.bgvid[0].style.display = "none", a.bgvid[0].style.zIndex = 0, a.bgvid[0].style.opacity = 0)) : "out" === r && (a.isHTML5 ? (a.currentState = "animating", a.drawVideoCanvasImagesRecall = !0, i.updateVideoFrames(e, a, !0), window.requestAnimationFrame(function () {
        tpGS.gsap.to(a.bgvid, .1, {
          zIndex: 0,
          display: "none"
        });
      })) : (i.stopVideo(a.bgvid, e, !0), !0 !== a.poster && (a.loadobj.bgColor = !0, a.bgcolor = "#000"))), t;
    },
    p = function p(e, i, t, a) {
      return Math.sqrt(Math.pow(e - t, 2) + Math.pow(i - a, 2));
    },
    g = function g(e, i) {
      var t = i + Math.PI / 2;
      return {
        x1: e.x,
        y1: e.y,
        x2: e.x + 100 * Math.cos(t),
        y2: e.y + 100 * Math.sin(t)
      };
    },
    u = function u(e, i) {
      var t = e.y2 - e.y1,
        a = e.x1 - e.x2,
        r = t * e.x1 + a * e.y1,
        o = i.y2 - i.y1,
        s = i.x1 - i.x2,
        n = o * i.x1 + s * i.y1,
        d = t * s - o * a;
      return 0 !== d && {
        x: Math.round((s * r - a * n) / d * 100) / 100,
        y: Math.round((t * n - o * r) / d * 100) / 100
      };
    };
  window.RS_MODULES = window.RS_MODULES || {}, window.RS_MODULES.slideanims = {
    loaded: !0,
    version: "6.5.4"
  }, window.RS_MODULES.checkMinimal && window.RS_MODULES.checkMinimal();
}(jQuery), function (e) {
  "use strict";

  jQuery.fn.revolution = jQuery.fn.revolution || {};
  var i = jQuery.fn.revolution;
  function t(e) {
    return null == e ? -1 : i.isNumeric(e) ? e : e.split(":").length > 1 ? 60 * parseInt(e.split(":")[0], 0) + parseInt(e.split(":")[1], 0) : e;
  }
  jQuery.extend(!0, i, {
    preLoadAudio: function preLoadAudio(e, t) {
      i[t].videos = void 0 === i[t].videos ? {} : i[t].videos, e.find(".rs-layer-audio").each(function () {
        var a = jQuery(this),
          r = i[t].videos[a[0].id] = void 0 === i[t].videos[a[0].id] ? f(a.data(), "audio", i.gA(e[0], "key")) : i[t].videos[a[0].id],
          o = {};
        0 === a.find("audio").length && (o.src = null != r.mp4 ? r.mp4 : "", o.pre = r.pload || "", this.id = void 0 === this.id || "" === this.id ? a.attr("audio-layer-" + Math.round(199999 * Math.random())) : this.id, o.id = this.id, o.status = "prepared", o.start = jQuery.now(), o.waittime = void 0 !== r.ploadwait ? 1e3 * r.ploadwait : 5e3, "auto" != o.pre && "canplaythrough" != o.pre && "canplay" != o.pre && "progress" != o.pre || (void 0 === i[t].audioqueue && (i[t].audioqueue = []), i[t].audioqueue.push(o), i.manageVideoLayer(a, t, i.gA(e[0], "key"), !0)));
      });
    },
    preLoadAudioDone: function preLoadAudioDone(e, t, a) {
      var r = i[t].videos[e[0].id];
      i[t].audioqueue && i[t].audioqueue.length > 0 && jQuery.each(i[t].audioqueue, function (e, i) {
        r.mp4 !== i.src || i.pre !== a && "auto" !== i.pre || (i.status = "loaded");
      });
    },
    checkfullscreenEnabled: function checkfullscreenEnabled(e) {
      if (void 0 !== window.fullScreen) return window.fullScreen;
      if (void 0 !== document.fullscreen) return document.fullscreen;
      if (void 0 !== document.mozFullScreen) return document.mozFullScreen;
      if (void 0 !== document.webkitIsFullScreen) return document.webkitIsFullScreen;
      var t = i.isWebkit() && /Apple Computer/.test(navigator.vendor) ? 42 : 5;
      return screen.width == i.winW && Math.abs(screen.height - i.getWinH(e)) < t;
    },
    showVideo: function showVideo(e) {
      tpGS.gsap.to(e, .3, {
        opacity: 1,
        display: "block",
        ease: "power3.inOut"
      });
    },
    resetVideo: function resetVideo(e, t, a) {
      if ("updateAndResize" !== a) {
        var r = i[t].videos[e[0].id];
        if ("resetVideo" !== r.cRS) switch (r.cRS = "resetVideo", r.type) {
          case "youtube":
            r.rwd && null != r.player && void 0 !== r.player.seekTo && (r.player.seekTo(-1 == r.ssec ? 0 : r.ssec), r.player.pauseVideo()), r.bgvideo || "preset" === a || 0 != r.jsposter.length || i.showVideo(e.find("iframe"));
            break;
          case "vimeo":
            void 0 !== r.vimeoplayer && r.rwd && (0 !== r.ssec && -1 !== r.ssec || r.bgvideo || r.jsposter.length > 0) && (r.vimeoplayer.setCurrentTime(-1 == r.ssec ? 0 : r.ssec), r.vimeoplayer.pause()), 0 != r.jsposter.length || r.bgvideo || "preset" === a || i.showVideo(e.find("iframe"));
            break;
          case "html5":
            if (i.ISM && r.notonmobile) return !1;
            r.bgvideo || i.showVideo(r.jvideo), r.rwd && "playing" !== r.cSS && !isNaN(r.video.duration) && (r.justReseted = !0, r.video.currentTime = -1 == r.ssec ? 0 : r.ssec), ("mute" == r.volume || i.lastToggleState(e.videomutetoggledby) || !0 === i[t].globalmute) && (r.video.muted = !0);
        }
      }
    },
    Mute: function Mute(e, t, a) {
      var r = !1,
        o = i[t].videos[e[0].id];
      switch (o.type) {
        case "youtube":
          o.player && (!0 === a && o.player.mute(), !1 === a && n(o, parseInt(o.volcache, 0)), r = o.player.isMuted());
          break;
        case "vimeo":
          o.volcachecheck || (o.volcache = o.volcache > 1 ? o.volcache / 100 : o.volcache, o.volcachecheck = !0), o.volume = !0 === a ? "mute" : !1 === a ? o.volcache : o.volume, void 0 !== a && null != o.vimeoplayer && s(o, !0 === a ? 0 : o.volcache), r = "mute" == o.volume || 0 === o.volume;
          break;
        case "html5":
          o.volcachecheck || (o.volcache = o.volcache > 1 ? o.volcache / 100 : o.volcache, o.volcachecheck = !0), o.video.volume = o.volcache, void 0 !== a && o.video && (o.video.muted = a), r = void 0 !== o.video ? o.video.muted : r;
      }
      if (void 0 === a) return r;
    },
    stopVideo: function stopVideo(e, t, a) {
      if (void 0 !== i[t] && void 0 !== i[t]) {
        var r = i[t].videos[e[0].id];
        if (void 0 !== r && ("stopVideo" !== r.cRS || "paused" !== r.cSS)) switch (r.cRS = "stopVideo", i[t].leaveViewPortBasedStop || (i[t].lastplayedvideos = []), i[t].leaveViewPortBasedStop = !1, r.type) {
          case "youtube":
            void 0 !== r.player && 2 !== r.player.getPlayerState() && 5 !== r.player.getPlayerState() && (r.player.pauseVideo(), void 0 !== a && p(t, r, "hide"));
            break;
          case "vimeo":
            void 0 !== r.vimeoplayer && (r.vimeoplayer.pause(), void 0 !== a && p(t, r, "hide"));
            break;
          case "html5":
            r.video && (r.video.pause(), i.ISM && b(r, 1));
        }
      }
    },
    playVideo: function playVideo(e, t, r) {
      var o = i[t].videos[e[0].id];
      if (clearTimeout(o.videoplaywait), "playVideo" !== o.cRS || "playing" !== o.cSS) switch (o.cRS = "playVideo", o.type) {
        case "youtube":
          if (0 == e.find("iframe").length) e.append(o.videomarkup), u(e, t, !0);else if (void 0 !== o.player && null != o.player.playVideo) {
            var s = o.player.getCurrentTime();
            o.nseTriggered && (s = -1, o.nseTriggered = !1), -1 != o.ssec && o.ssec > s && o.player.seekTo(o.ssec), c(o);
          } else o.videoplaywait = setTimeout(function () {
            i.playVideo(e, t);
          }, 50);
          break;
        case "vimeo":
          if (0 == e.find("iframe").length) delete o.vimeoplayer, e.append(o.videomarkup), u(e, t, !0);else if (e.hasClass("rs-apiready")) {
            if (o.vimeoplayer = null == o.vimeoplayer ? new Vimeo.Player(e.find("iframe").attr("id")) : o.vimeoplayer, o.vimeoplayer.getPaused()) {
              s = void 0 === o.currenttime ? 0 : o.currenttime;
              o.nseTriggered && (s = -1, o.nseTriggered = !1), -1 != o.ssec && o.ssec > s && o.vimeoplayer.setCurrentTime(o.ssec), ("mute" == o.volume || 0 === o.volume || i.lastToggleState(e.data("videomutetoggledby")) || !0 === i[t].globalmute) && (o.volumetoken = !0, o.vimeoplayer.setVolume(0)), l(o);
            } else o.videoplaywait = setTimeout(function () {
              i.playVideo(e, t);
            }, 50);
          } else o.videoplaywait = setTimeout(function () {
            i.playVideo(e, t);
          }, 50);
          break;
        case "html5":
          if (o.metaloaded) {
            if (("" + o.video.duration == "NaN" || o.video.readyState < 4) && !r) return o.loadRequested || (o.video.load(), o.loadRequested = !0), void setTimeout(function () {
              i.playVideo(e, t);
            }, 50);
            s = o.video.currentTime;
            o.nseTriggered && (s = -1, o.nseTriggered = !1), -1 != o.ssec && o.ssec > s && o.ssec < o.video.duration && (o.video.currentTime = o.ssec), d(o);
          } else a(o.video, "loadedmetadata", function (e) {
            i.playVideo(e, t);
          }(e));
      }
    },
    isVideoPlaying: function isVideoPlaying(e, t) {
      var a = !1;
      return null != i[t].playingvideos && jQuery.each(i[t].playingvideos, function (i, t) {
        e.attr("id") == t.attr("id") && (a = !0);
      }), a;
    },
    removeMediaFromList: function removeMediaFromList(e, i) {
      w(e, i);
    },
    prepareCoveredVideo: function prepareCoveredVideo(e) {
      clearTimeout(i[e].resizePrepareCoverVideolistener);
      var t = "carousel" === i[e].sliderType ? i[e].carousel.justify ? void 0 === i[e].carousel.slide_widths ? void 0 : i[e].carousel.slide_widths[i[e].carousel.focused] : i[e].carousel.slide_width : i[e].canv.width,
        a = "carousel" === i[e].sliderType ? i[e].carousel.slide_height : i[e].canv.height;
      if (0 !== t && 0 !== a && void 0 !== t && void 0 !== a) for (var r in i[e].videos) {
        var o = i[e].videos[r];
        if (void 0 !== o.jvideo && (o.bgvideo || o.jvideo.parent().hasClass("rs-fsv") || i.closestNode(o.video, "RS-LAYER") && i.closestNode(o.video, "RS-LAYER").classList.contains("rs-fsv")) && ("html5" === o.type && void 0 !== o.jvideo && tpGS.gsap.set(o.jvideo, {
          width: t
        }), void 0 === i[e].activeRSSlide || o.slideid === i.gA(i[e].slides[i[e].activeRSSlide], "key") || void 0 === i[e].pr_next_slide || o.slideid === i.gA(i[e].pr_next_slide[0], "key"))) {
          o.vd = o.ratio.split(":").length > 1 ? o.ratio.split(":")[0] / o.ratio.split(":")[1] : 1;
          var s,
            n = t / a,
            d = o.vd * n * 100,
            l = o.vd / n * 100;
          s = "Edge" === i.get_browser() || "IE" === i.get_browser() ? n > o.vd ? {
            minWidth: "100%",
            height: d + "%",
            x: "-50%",
            y: "-50%",
            top: "50%",
            left: "50%",
            position: "absolute"
          } : {
            minHeight: "100%",
            width: l + "%",
            x: "-50%",
            y: "-50%",
            top: "50%",
            left: "50%",
            position: "absolute"
          } : n > o.vd ? {
            height: (o.fitCover ? 100 : d) + "%",
            width: "100%",
            top: o.fitCover ? 0 : -(d - 100) / 2 + "%",
            left: "0px",
            position: "absolute"
          } : {
            width: (o.fitCover ? 100 : l) + "%",
            height: "100%",
            left: o.fitCover ? 0 : -(l - 100) / 2 + "%",
            top: "0px",
            position: "absolute"
          }, void 0 === o.vimeoid && void 0 === o.ytid || (s.maxWidth = "none", s.maxHeight = "none"), tpGS.gsap.set(o.jvideo, s);
        }
      } else i[e].resizePrepareCoverVideolistener = setTimeout(function () {
        i.prepareCoveredVideo(e);
      }, 100);
    },
    checkVideoApis: function checkVideoApis(e, t) {
      location.protocol;
      if (!i[t].youtubeapineeded) {
        var a = e.find("iframe");
        if ((null != e.data("ytid") || a.length > 0 && a.attr("src") && a.attr("src").toLowerCase().indexOf("youtube") > 0) && (i[t].youtubeapineeded = !0), i[t].youtubeapineeded && !window.rs_addedyt) {
          i[t].youtubestarttime = jQuery.now(), window.rs_addedyt = !0;
          var r = document.createElement("script"),
            o = i.getByTag(document, "script")[0],
            s = !0;
          r.src = "https://www.youtube.com/iframe_api", jQuery("head").find("*").each(function () {
            "https://www.youtube.com/iframe_api" == jQuery(this).attr("src") && (s = !1);
          }), s && o.parentNode.insertBefore(r, o);
        }
      }
      if (!i[t].vimeoapineeded) {
        var n = e.find("iframe");
        if ((null != e.data("vimeoid") || n.length > 0 && n.attr("src") && n.attr("src").toLowerCase().indexOf("vimeo") > 0) && (i[t].vimeoapineeded = !0), i[t].vimeoapineeded && !window.rs_addedvim) {
          i[t].vimeostarttime = jQuery.now(), window.rs_addedvim = !0;
          var d = document.createElement("script");
          o = i.getByTag(document, "script")[0], s = !0;
          d.src = "https://player.vimeo.com/api/player.js", jQuery("head").find("*").each(function () {
            "https://player.vimeo.com/api/player.js" == jQuery(this).attr("src") && (s = !1);
          }), s && o.parentNode.insertBefore(d, o);
        }
      }
    },
    manageVideoLayer: function manageVideoLayer(e, t, r, o) {
      if (i[t].videos = void 0 === i[t].videos ? {} : i[t].videos, void 0 === i[t].videos[e[0].id] || !0 === o) {
        var s = i[t].videos[e[0].id] = void 0 === i[t].videos[e[0].id] ? f(e.data(), void 0, r) : i[t].videos[e[0].id];
        if (s.audio = void 0 !== s.audio && s.audio, i.ISM && s.opom) 0 == e.find("rs-poster").length && e.append('<rs-poster class="noSwipe" style="background-image:url(' + s.poster + ');"></rs-poster>');else {
          s.jsposter = e.find("rs-poster"), s.id = e[0].id, s.pload = "auto" === s.pload || "canplay" === s.pload || "canplaythrough" === s.pload || "progress" === s.pload ? "auto" : s.pload, s.type = null != s.mp4 || null != s.webm ? "html5" : null != s.ytid && String(s.ytid).length > 1 ? "youtube" : null != s.vimeoid && String(s.vimeoid).length > 1 ? "vimeo" : "none", s.newtype = "html5" == s.type && 0 == e.find(s.audio ? "audio" : "video").length ? "html5" : "youtube" == s.type && 0 == e.find("iframe").length ? "youtube" : "vimeo" == s.type && 0 == e.find("iframe").length ? "vimeo" : "none", s.extras = "", s.posterMarkup = void 0 === s.posterMarkup ? "" : s.posterMarkup, !s.audio && "1sttime" == s.aplay && s.pausetimer && s.bgvideo && i.sA(e.closest("rs-slide")[0], "rspausetimeronce", 1), s.audio || !s.bgvideo || !s.pausetimer || 1 != s.aplay && "true" != s.aplay && "no1sttime" != s.aplay || i.sA(e.closest("rs-slide")[0], "rspausetimeralways", 1), s.noInt && e.addClass("rs-nointeraction"), !(null != s.poster && s.poster.length > 2) || i.ISM && s.npom || 0 == s.jsposter.length && (s.posterMarkup += '<rs-poster class="noSwipe" style="background-image:url(' + s.poster + ');"></rs-poster>');
          var n = !0;
          switch (s.cSS = "created", s.cRS = "created", s.newtype) {
            case "html5":
              1 == window.isSafari11 && (i[t].slideHasIframe = !0), s.audio && e.addClass("rs-audio"), s.tag = s.audio ? "audio" : "video";
              var d = "video" === s.tag && (i.is_mobile() || i.isSafari11()) ? s.aplay || "true" === s.aplay ? "muted playsinline autoplay" : s.inline ? " playsinline" : "" : "",
                l = '<div class="html5vid rs_html5vidbasicstyles ' + (!1 === s.afs ? "hidefullscreen" : "") + '">';
              l += "<" + s.tag + " " + d + " " + (s.controls && "none" !== s.controls ? " controls" : "") + (s.bgvideo && -1 == d.indexOf("autoplay") ? " autoplay" : "") + (s.bgvideo && -1 == d.indexOf("muted") ? " muted" : "") + ' style="' + ("Edge" !== i.get_browser() ? (s.fitCover ? "object-fit:cover;background-size:cover;" : "") + "opacity:0;width:100%; height:100%" : "") + '" class="" ' + (s.loop ? "loop" : "") + ' preload="' + s.pload + '">', "video" === s.tag && null != s.webm && "firefox" == i.get_browser().toLowerCase() && (l = l + '<source src="' + s.webm + '" type="video/webm" />'), null != s.mp4 && (l = l + '<source src="' + s.mp4 + '" type="' + ("video" === s.tag ? "video/mp4" : s.mp4.toLowerCase().indexOf("m4a") > 0 ? "audio/x-m4a" : "audio/mpeg") + '" />'), null != s.ogv && (l = l + '<source src="' + s.mp4 + '" type="' + s.tag + '/ogg" />'), l += "</" + s.tag + "></div>", l += s.posterMarkup, s.controls && !s.audio && void 0 === s.poster || s.bgvideo || (l += '<div class="tp-video-play-button"><i class="revicon-right-dir"></i><span class="tp-revstop">&nbsp;</span></div>'), s.videomarkup = l, n = !1, i.ISM && s.notonmobile || i.isIE(8) || e.append(l), s.jvideo = e.find(s.tag), s.video = s.jvideo[0], s.html5vid = s.jvideo.parent(), a(s.video, "canplay", function (e) {
                m(e, t), i.resetVideo(e, t);
              }(e));
              break;
            case "youtube":
              i[t].slideHasIframe = !0, s.controls && "none" !== s.controls || (s.vatr = s.vatr.replace("controls=1", "controls=0"), -1 == s.vatr.toLowerCase().indexOf("controls") && (s.vatr = s.vatr + "&controls=0")), (s.inline || "RS-BGVIDEO" === e[0].tagName) && (s.vatr = s.vatr + "&playsinline=1"), -1 != s.ssec && (s.vatr += "&start=" + s.ssec), -1 != s.esec && (s.vatr += "&end=" + s.esec);
              var c = s.vatr.split("origin=https://");
              s.vatrnew = c.length > 1 ? c[0] + "origin=https://" + (self.location.href.match(/www/gi) && !c[1].match(/www/gi) ? "www." + c[1] : c[1]) : s.vatr, s.videomarkup = '<iframe allow="autoplay; ' + (!0 === s.afs ? "fullscreen" : "") + '" type="text/html" src="https://www.youtube-nocookie.com/embed/' + s.ytid + "?" + s.vatrnew + '" ' + (!0 === s.afs ? "allowfullscreen" : "") + ' width="100%" height="100%" class="intrinsic-ignore" style="opacity:0;visibility:visible;width:100%;height:100%"></iframe>';
              break;
            case "vimeo":
              i[t].slideHasIframe = !0, s.controls && "none" !== s.controls ? (s.vatr = s.vatr.replace("background=0", "background=1"), -1 == s.vatr.toLowerCase().indexOf("background") && (s.vatr = s.vatr + "&background=1")) : (s.vatr = s.vatr.replace("background=1", "background=0"), -1 == s.vatr.toLowerCase().indexOf("background") && (s.vatr = s.vatr + "&background=0")), s.vatr = "autoplay=" + (!0 === s.aplay ? 1 : 0) + "&" + s.vatr, s.bgvideo && (s.prePlayForaWhile = !0), i.ISM && !0 === s.aplay && (s.vatr = "muted=1&" + s.vatr), s.loop && (s.vatr = "loop=1&" + s.vatr), s.videomarkup = '<iframe  allow="autoplay; ' + (!0 === s.afs ? "fullscreen" : "") + '" src="https://player.vimeo.com/video/' + s.vimeoid + "?" + s.vatr + '" ' + (!0 === s.afs ? "webkitallowfullscreen mozallowfullscreen allowfullscreen" : "") + ' width="100%" height="100%" class="intrinsic-ignore" style="opacity:0;visibility:visible;width:100%;height:100%"></iframe>';
          }
          if (!(null != s.poster && s.poster.length > 2) || i.ISM && s.npom) {
            if (i.ISM && s.notonmobile) return !1;
            0 != e.find("iframe").length || "youtube" != s.type && "vimeo" != s.type || (delete s.vimeoplayer, e.append(s.videomarkup), u(e, t, !("vimeo" !== s.newtype || !s.bgvideo), !0));
          } else n && 0 == e.find("rs-poster").length && e.append(s.posterMarkup), 0 == e.find("iframe").length && (s.jsposter = e.find("rs-poster"), s.jsposter.on("click", function () {
            if (i.playVideo(e, t, !0), i.ISM) {
              if (s.notonmobile) return !1;
              tpGS.gsap.to(s.jsposter, .3, {
                opacity: 0,
                visibility: "hidden",
                force3D: "auto",
                ease: "power3.inOut"
              }), i.showVideo(e.find("iframe"));
            }
          }));
          if ("none" !== s.doverlay && void 0 !== s.doverlay) {
            var p = i.createOverlay(t, s.doverlay, s.doverlaysize, {
              0: s.doverlaycolora,
              1: s.doverlaycolorb
            });
            s.bgvideo && 1 != e.closest("rs-sbg-wrap").find("rs-dotted").length ? e.closest("rs-sbg-wrap").append('<rs-dotted style="background-image:' + p + '"></rs-dotted>') : s.bgvideo || 1 == e.find("rs-dotted").length || e.append('<rs-dotted style="background-image:' + p + '"></rs-dotted>');
          }
          s.bgvideo && (e[0].style.display = "none", e[0].style.zIndex = 0, tpGS.gsap.set(e.find("video, iframe"), {
            opacity: 0
          }));
        }
      }
    }
  });
  var a = function a(e, i, t) {
      e.addEventListener ? e.addEventListener(i, t, {
        capture: !1,
        passive: !0
      }) : e.attachEvent(i, t, {
        capture: !1,
        passive: !0
      });
    },
    r = function r(e, i, t) {
      var a = {};
      return a.video = e, a.type = i, a.settings = t, a;
    },
    o = function o(e, t) {
      var a = i[e].videos[t[0].id];
      (a.bgvideo || t.hasClass("rs-fsv")) && ((void 0 === a.ratio || a.ratio.split(":").length <= 1) && (a.ratio = "16:9"), requestAnimationFrame(function () {
        i.prepareCoveredVideo(e);
      }));
    },
    s = function s(e, t) {
      var a = e.vimeoplayer;
      a.getPaused().then(function (r) {
        e.volumetoken = !0;
        var o = !r,
          s = a.setVolume(t);
        void 0 !== s && s.then(function (i) {
          a.getPaused().then(function (i) {
            o === i && (e.volume = "mute", e.volumetoken = !0, a.setVolume(0), a.play());
          }).catch(function (e) {
            console.log("Get Paused Function Failed for Vimeo Volume Changes Inside the Promise");
          });
        }).catch(function (t) {
          o && (e.volume = "mute", e.volumetoken = !0, a.setVolume(0), a.play()), i.ISM && b(e, 0);
        });
      }).catch(function () {
        console.log("Get Paused Function Failed for Vimeo Volume Changes");
      });
    },
    n = function n(e, i) {
      var t = e.player.getPlayerState();
      "mute" === i ? e.player.mute() : (e.player.unMute(), e.player.setVolume(i)), setTimeout(function () {
        1 === t && 1 !== e.player.getPlayerState() && (e.player.mute(), e.player.playVideo());
      }, 39);
    },
    d = function d(e, t) {
      if ("playVideo" === e.cRS) {
        var a = e.video.play();
        void 0 !== a && a.then(function (e) {}).catch(function (i) {
          e.video.pause(), !0 !== t && d(e, !0);
        }), i.ISM && b(e, 0);
      }
    },
    l = function l(e) {
      if ("playVideo" === e.cRS) {
        var i = e.vimeoplayer.play();
        void 0 !== i && i.then(function (e) {}).catch(function (i) {
          e.vimeoplayer.volumetoken = !0, e.vimeoplayer.setVolume(0), e.vimeoplayer.play();
        });
      }
    },
    c = function c(e) {
      "playVideo" === e.cRS && e.player.playVideo();
    },
    p = function p(e, t, a, r) {
      clearTimeout(t.repeatedPosterCalls), t.repeatedPosterCalls = setTimeout(function () {
        "show" === a || "playing" === t.cSS && !0 !== t.VideoIsVisible ? (void 0 !== t.showhideposter && t.showhideposter.pause(), t.showhideposter = tpGS.gsap.timeline(), t.jsposter.length > 0 && t.showhideposter.add(tpGS.gsap.to(t.jsposter, .3, {
          zIndex: 5,
          autoAlpha: 0,
          force3D: "auto",
          ease: "power3.inOut"
        }), 0), t.jvideo.length > 0 && t.showhideposter.add(tpGS.gsap.to(t.jvideo, void 0 !== r ? r : .001, {
          opacity: 1,
          display: "block",
          ease: t.jsposter.length > 0 ? "power3.inOut" : "power3.out"
        }), 0), t.VideoIsVisible = !0) : ("hide" === a || "paused" === t.cSS && 1 != i.checkfullscreenEnabled(e) && t.jsposter.length > 0 && !1 !== t.VideoIsVisible && !0 !== t.seeking) && (void 0 !== t.showhideposter && t.showhideposter.pause(), t.showhideposter = tpGS.gsap.timeline(), t.jsposter.length > 0 && t.showhideposter.add(tpGS.gsap.to(t.jsposter, .3, {
          zIndex: 5,
          autoAlpha: 1,
          force3D: "auto",
          ease: "power3.inOut"
        }), 0), t.jvideo.length > 0 && t.showhideposter.add(tpGS.gsap.to(t.jvideo, void 0 !== r ? r : .001, {
          opacity: 0,
          ease: t.jsposter.length > 0 ? "power3.inOut" : "power3.out"
        }), .3), t.bgvideo && void 0 !== t.nBG && void 0 !== t.nBG.loadobj && (t.nBG.video = t.nBG.loadobj.img), t.VideoIsVisible = !1);
      }, void 0 !== a ? 0 : 100);
    },
    g = function g(e, t, a) {
      e.cSS = "playing", e.vimeostarted = !0, e.nextslidecalled = !1, e.jsposter = void 0 === e.jsposter || 0 === e.jsposter.length ? t.find("rs-poster") : e.jsposter, e.jvideo = t.find("iframe"), i[a].c.trigger("revolution.slide.onvideoplay", r(e.vimeoplayer, "vimeo", e)), i[a].stopByVideo = e.pausetimer, y(t, a), "mute" == e.volume || 0 === e.volume || i.lastToggleState(t.data("videomutetoggledby")) || !0 === i[a].globalmute ? (e.volumetoken = !0, e.vimeoplayer.setVolume(0)) : s(e, parseInt(e.volcache, 0) / 100 || .75), i.toggleState(e.videotoggledby);
    },
    u = function u(e, t, a, s) {
      var d = i[t].videos[e[0].id],
        l = "iframe" + Math.round(1e5 * Math.random() + 1);
      if (d.jvideo = e.find("iframe"), o(t, e), d.jvideo.attr("id", l), d.startvideonow = a, d.videolistenerexist) {
        if (a) switch (d.type) {
          case "youtube":
            i.playVideo(e, t), -1 != d.ssec && d.player.seekTo(d.ssec);
            break;
          case "vimeo":
            i.playVideo(e, t), -1 != d.ssec && d.vimeoplayer.seekTo(d.ssec);
        }
      } else switch (d.type) {
        case "youtube":
          if ("undefined" == typeof YT || void 0 === YT.Player) return i.checkVideoApis(e, t), void setTimeout(function () {
            u(e, t, a, s);
          }, 50);
          d.player = new YT.Player(l, {
            events: {
              onStateChange: function onStateChange(a) {
                a.data == YT.PlayerState.PLAYING ? (d.cSS = "playing", i[t].onceVideoPlayed = !0, "mute" == d.volume || 0 === d.volume || i.lastToggleState(e.data("videomutetoggledby")) || !0 === i[t].globalmute ? d.player.mute() : n(d, parseInt(d.volcache, 0) || 75), i[t].stopByVideo = !0, y(e, t), d.pausetimer ? i[t].c.trigger("stoptimer") : i[t].stopByVideo = !1, i[t].c.trigger("revolution.slide.onvideoplay", r(d.player, "youtube", d)), i.toggleState(d.videotoggledby)) : (d.cSS = "paused", 0 == a.data && d.loop && (-1 != d.ssec && d.player.seekTo(d.ssec), i.playVideo(e, t), i.toggleState(d.videotoggledby)), -1 != a.data && 3 != a.data && (i[t].stopByVideo = !1, i[t].tonpause = !1, w(e, t), i[t].c.trigger("starttimer"), i[t].c.trigger("revolution.slide.onvideostop", r(d.player, "youtube", d)), null != i[t].videoIsPlaying && i[t].videoIsPlaying.attr("id") != e.attr("id") || i.unToggleState(d.videotoggledby)), 0 == a.data && d.nse ? (h(), d.nseTriggered = !0, i[t].c.revnext(), w(e, t)) : (w(e, t), i[t].stopByVideo = !1, 3 !== a.data && (-1 != d.lasteventdata && 3 != d.lasteventdata && void 0 !== d.lasteventdata || -1 != a.data && 3 != a.data) && i[t].c.trigger("starttimer"), i[t].c.trigger("revolution.slide.onvideostop", r(d.player, "youtube", d)), null != i[t].videoIsPlaying && i[t].videoIsPlaying.attr("id") != e.attr("id") || i.unToggleState(d.videotoggledby))), clearTimeout(d.postOrVideoTimer), 3 !== a.data && (d.postOrVideoTimer = setTimeout(function () {
                  p(t, d);
                }, 1 === d.lasteventdata && 2 === a.data || 2 === d.lasteventdata && 3 !== a.data ? 1e3 : 0), d.lasteventdata = a.data);
              },
              onReady: function onReady(a) {
                var r,
                  o = i.is_mobile(),
                  n = e.hasClass("rs-layer-video");
                d.ready = !0, !o && (!i.isSafari11() || o && n) || "RS-BGVIDEO" !== e[0].tagName && (!n || !0 !== d.aplay && "true" !== d.aplay) || (r = !0, d.player.setVolume(0), d.volume = "mute", d.player.mute(), clearTimeout(e.data("mobilevideotimr")), 2 !== d.player.getPlayerState() && -1 !== d.player.getPlayerState() || e.data("mobilevideotimr", setTimeout(function () {
                  i.playVideo(e, t);
                }, 500))), r || "mute" != d.volume || (d.player.setVolume(0), d.player.mute()), e.addClass("rs-apiready"), null == d.speed && 1 === d.speed || a.target.setPlaybackRate(parseFloat(d.speed)), d.jsposter.unbind("click"), d.jsposter.on("click", function () {
                  i.playVideo(e, t, !0);
                }), d.startvideonow ? (i.playVideo(e, t), -1 != d.ssec && d.player.seekTo(d.ssec)) : s && p(t, d, "show", .2), d.videolistenerexist = !0;
              }
            }
          });
          break;
        case "vimeo":
          if ("undefined" == typeof Vimeo || void 0 === Vimeo.Player) return i.checkVideoApis(e, t), void setTimeout(function () {
            u(e, t, a, s);
          }, 50);
          for (var c, m = d.jvideo.attr("src"), v = {}, f = m, b = /([^&=]+)=([^&]*)/g; c = b.exec(f);) v[decodeURIComponent(c[1])] = decodeURIComponent(c[2]);
          m = (m = null != v.player_id ? m.replace(v.player_id, l) : m + "&player_id=" + l).replace(/&api=0|&api=1/g, "");
          var _,
            S = i.is_mobile() || i.isSafari11(),
            x = "RS-BGVIDEO" === e[0].tagName;
          if (S && x && (m += "&background=1"), d.jvideo.attr("src", m), d.vimeoplayer = void 0 === d.vimeoplayer || !1 === d.vimeoplayer ? new Vimeo.Player(l) : d.vimeoplayer, S) x ? _ = !0 : (d.aplay || "true" === d.aplay) && (_ = !0), _ && (d.volumetoken = !0, d.vimeoplayer.setVolume(0), d.volume = "mute");
          d.vimeoplayer.on("play", function (a) {
            i[t].onceVideoPlayed = !0, d.cSS = "playing", d.vimeostarted || g(d, e, t);
          }), d.vimeoplayer.on("loaded", function (a) {
            var r = {};
            d.vimeoplayer.getVideoWidth().then(function (i) {
              r.width = i, void 0 !== r.width && void 0 !== r.height && (d.ratio = r.width + ":" + r.height, d.vimeoplayerloaded = !0, o(t, e));
            }), d.vimeoplayer.getVideoHeight().then(function (i) {
              r.height = i, void 0 !== r.width && void 0 !== r.height && (d.ratio = r.width + ":" + r.height, d.vimeoplayerloaded = !0, o(t, e));
            }), d.startvideonow ? ("mute" === d.volume && (d.volumetoken = !0, d.vimeoplayer.setVolume(0)), i.playVideo(e, t), -1 != d.ssec && d.vimeoplayer.setCurrentTime(d.ssec)) : s && p(t, d, "show", .2);
          }), e.addClass("rs-apiready"), d.vimeoplayer.on("volumechange", function (e) {
            d.volumetoken && (d.volume = e.volume), d.volumetoken = !1;
          }), d.vimeoplayer.on("timeupdate", function (a) {
            p(t, d), d.vimeostarted || 0 === a.percent || void 0 !== i[t].activeRSSlide && d.slideid !== i.gA(i[t].slides[i[t].activeRSSlide], "key") || g(d, e, t), d.pausetimer && "playing" == i[t].sliderstatus && (i[t].stopByVideo = !0, i[t].c.trigger("stoptimer")), d.currenttime = a.seconds, 0 != d.esec && -1 !== d.esec && d.esec < a.seconds && !0 !== d.nextslidecalled && (d.loop ? (i.playVideo(e, t), d.vimeoplayer.setCurrentTime(-1 !== d.ssec ? d.ssec : 0)) : (d.nse && (d.nseTriggered = !0, d.nextslidecalled = !0, i[t].c.revnext()), d.vimeoplayer.pause())), d.prePlayForaWhile && d.vimeoplayer.pause();
          }), d.vimeoplayer.on("ended", function (a) {
            d.cSS = "paused", p(t, d), d.vimeostarted = !1, w(e, t), i[t].stopByVideo = !1, i[t].c.trigger("starttimer"), i[t].c.trigger("revolution.slide.onvideostop", r(d.vimeoplayer, "vimeo", d)), d.nse && (d.nseTriggered = !0, i[t].c.revnext()), null != i[t].videoIsPlaying && i[t].videoIsPlaying.attr("id") != e.attr("id") || i.unToggleState(d.videotoggledby);
          }), d.vimeoplayer.on("pause", function (a) {
            d.vimeostarted = !1, d.cSS = "paused", p(t, d), i[t].stopByVideo = !1, i[t].tonpause = !1, w(e, t), i[t].c.trigger("starttimer"), i[t].c.trigger("revolution.slide.onvideostop", r(d.vimeoplayer, "vimeo", d)), null != i[t].videoIsPlaying && i[t].videoIsPlaying.attr("id") != e.attr("id") || i.unToggleState(d.videotoggledby);
          }), d.jsposter.unbind("click"), d.jsposter.on("click", function () {
            if (!i.ISM) return i.playVideo(e, t, !0), !1;
          }), d.videolistenerexist = !0;
      }
    },
    h = function h() {
      document.exitFullscreen && document.fullscreen ? document.exitFullscreen() : document.mozCancelFullScreen && document.mozFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen && document.webkitIsFullScreen && document.webkitExitFullscreen();
    },
    m = function m(e, t, o) {
      var s = i[t].videos[e[0].id];
      if (i.ISM && s.notonmobile) return !1;
      if (s.metaloaded = !0, "html5" === s.newtype && s.bgvideo && (s.nBG = i[t].sbgs[e[0].dataset.key], void 0 === s.nBG.shadowCanvas && (s.nBG.shadowCanvas = document.createElement("canvas"), s.nBG.shadowCTX = s.nBG.shadowCanvas.getContext("2d"), s.nBG.shadowCanvas.style.background = "transparent", s.nBG.shadowCanvas.style.opacity = 1), s.nBG.isHTML5 = !0, s.nBG.video = void 0 !== s.nBG.loadobj && void 0 !== s.nBG.loadobj.img ? s.nBG.loadobj.img : s.video, s.nBG.drawVideoCanvasImagesRecall = !1), !s.controls || s.audio || void 0 !== s.poster) {
        0 != e.find(".tp-video-play-button").length || i.ISM || e.append('<div class="tp-video-play-button"><i class="revicon-right-dir"></i><span class="tp-revstop">&nbsp;</span></div>');
        var n = "video, rs-poster, .tp-video-play-button";
        void 0 !== s.poster && s.controls && (n = ".tp-video-play-button"), e.find(n).on("click", function () {
          !1 === s.loop && s.esec > 0 && s.esec <= s.video.currentTime || (e.hasClass("videoisplaying") ? i.stopVideo(e, t) : i.playVideo(e, t, !0));
        });
      }
      (e.hasClass("rs-fsv") || s.bgvideo) && (s.bgvideo || e.hasClass("rs-fsv") ? (s.html5vid.addClass("fullcoveredvideo"), void 0 !== s.ratio && 1 != s.ratio.split(":").length || (s.ratio = "16:9"), i.prepareCoveredVideo(t)) : s.html5vid.addClass("rs-fsv")), a(s.video, "canplaythrough", function () {
        i.preLoadAudioDone(e, t, "canplaythrough");
      }), a(s.video, "canplay", function () {
        i.preLoadAudioDone(e, t, "canplay");
      }), a(s.video, "progress", function () {
        i.preLoadAudioDone(e, t, "progress");
      }), a(s.video, "pause", function () {
        i.ISM && b(s, 1);
      }), a(s.video, "timeupdate", function (e) {
        this.BGrendered = !0, p(t, s), -1 === s.esec && s.loop && 1 == window.isSafari11 && (s.esec = s.video.duration - .075), void 0 !== s.lastCurrentTime ? s.fps = s.video.currentTime - s.lastCurrentTime : s.fps = .1, s.lastCurrentTime = s.video.currentTime, 0 != s.esec && -1 != s.esec && s.esec < s.video.currentTime && !s.nextslidecalled && (s.loop ? (d(s), s.video.currentTime = -1 === s.ssec ? .5 : s.ssec) : (s.nse && (s.nseTriggered = !0, s.nextslidecalled = !0, i[t].jcnah = !0, i[t].c.revnext(), setTimeout(function () {
          i[t].jcnah = !1;
        }, 1e3)), s.video.pause()));
      }), a(s.video, "play", function () {
        s.cSS = "playing", p(t, s), s.bgvideo && (s.nBG.drawVideoCanvasImagesRecall = !0, s.nBG.videoisplaying = !0, s.nBG.video = s.video, i.updateVideoFrames(t, s.nBG)), i[t].onceVideoPlayed = !0, s.nextslidecalled = !1, s.volume = null != s.volume && "mute" != s.volume ? parseFloat(s.volcache) : s.volume, s.volcache = null != s.volcache && "mute" != s.volcache ? parseFloat(s.volcache) : s.volcache, i.is_mobile() || i.isSafari11() || (!0 === i[t].globalmute ? s.video.muted = !0 : s.video.muted = "mute" == s.volume, s.volcache = i.isNumeric(s.volcache) && s.volcache > 1 ? s.volcache / 100 : s.volcache, "mute" == s.volume ? s.video.muted = !0 : null != s.volcache && (s.video.volume = s.volcache)), e.addClass("videoisplaying"), y(e, t), clearTimeout(s.showCoverSoon), !0 !== s.pausetimer || "audio" == s.tag ? (i[t].stopByVideo = !1, i[t].c.trigger("revolution.slide.onvideostop", r(s.video, "html5", s))) : (i[t].stopByVideo = !0, i[t].c.trigger("revolution.slide.onvideoplay", r(s.video, "html5", s))), s.pausetimer && "playing" == i[t].sliderstatus && (i[t].stopByVideo = !0, i[t].c.trigger("stoptimer")), i.toggleState(s.videotoggledby);
      }), a(s.video, "seeked", function () {
        s.seeking = !1;
      }), a(s.video, "seeking", function () {
        s.seeking = !0;
      }), a(s.video, "pause", function (a) {
        s.cSS = "paused", p(t, s), e.removeClass("videoisplaying"), s.bgvideo && (s.nBG.drawVideoCanvasImagesRecall = !1, s.nBG.videoisplaying = !1), i[t].stopByVideo = !1, w(e, t), "audio" != s.tag && i[t].c.trigger("starttimer"), i[t].c.trigger("revolution.slide.onvideostop", r(s.video, "html5", s)), null != i[t].videoIsPlaying && i[t].videoIsPlaying.attr("id") != e.attr("id") || i.unToggleState(s.videotoggledby);
      }), a(s.video, "ended", function () {
        s.cSS = "paused", h(), p(t, s), w(e, t), i[t].stopByVideo = !1, w(e, t), "audio" != s.tag && i[t].c.trigger("starttimer"), i[t].c.trigger("revolution.slide.onvideostop", r(s.video, "html5", e.data())), s.nse && s.video.currentTime > 0 && (1 == !i[t].jcnah && (s.nseTriggered = !0, i[t].c.revnext(), i[t].jcnah = !0), setTimeout(function () {
          i[t].jcnah = !1;
        }, 1500)), e.removeClass("videoisplaying"), s.bgvideo && (s.nBG.drawVideoCanvasImagesRecall = !1, s.nBG.videoisplaying = !1), !0 !== i[t].inviewport && void 0 !== i[t].inviewport || (i[t].lastplayedvideos = []);
      });
    },
    v = function v(e) {
      return "t" === e || !0 === e || "true" === e || "f" !== e && !1 !== e && "false" !== e && e;
    },
    f = function f(e, i, a) {
      e.audio = "audio" === i;
      var r = void 0 === e.video ? [] : e.video.split(";"),
        o = {
          volume: e.audio ? 1 : "mute",
          pload: "auto",
          ratio: "16:9",
          loop: !0,
          aplay: "true",
          fitCover: !0,
          afs: !0,
          controls: !1,
          nse: !0,
          npom: !1,
          opom: !1,
          inline: !0,
          notonmobile: !1,
          start: -1,
          end: -1,
          doverlay: "none",
          doverlaysize: 1,
          doverlaycolora: "transparent",
          doverlaycolorb: "#000000",
          scop: !1,
          rwd: !0,
          speed: 1,
          ploadwait: 5,
          stopAV: 1 !== e.bgvideo,
          noInt: !1,
          volcache: 75
        };
      for (var s in r) if (r.hasOwnProperty(s)) {
        var n = r[s].split(":");
        switch (n[0]) {
          case "v":
            o.volume = n[1];
            break;
          case "vd":
            o.volcache = n[1];
            break;
          case "p":
            o.pload = n[1];
            break;
          case "ar":
            o.ratio = n[1] + (void 0 !== n[2] ? ":" + n[2] : "");
            break;
          case "ap":
            o.aplay = v(n[1]);
            break;
          case "vfc":
            o.fitCover = v(n[1]);
            break;
          case "afs":
            o.afs = v(n[1]);
            break;
          case "vc":
            o.controls = n[1];
            break;
          case "nse":
            o.nse = v(n[1]);
            break;
          case "npom":
            o.npom = v(n[1]);
            break;
          case "opom":
            o.opom = v(n[1]);
            break;
          case "t":
            o.vtype = n[1];
            break;
          case "inl":
            o.inline = v(n[1]);
            break;
          case "nomo":
            o.notonmobile = v(n[1]);
            break;
          case "sta":
            o.start = n[1] + (void 0 !== n[2] ? ":" + n[2] : "");
            break;
          case "end":
            o.end = n[1] + (void 0 !== n[2] ? ":" + n[2] : "");
            break;
          case "do":
            o.doverlay = n[1];
            break;
          case "dos":
            o.doverlaysize = n[1];
            break;
          case "doca":
            o.doverlaycolora = n[1];
            break;
          case "docb":
            o.doverlaycolorb = n[1];
            break;
          case "scop":
            o.scop = v(n[1]);
            break;
          case "rwd":
            o.rwd = v(n[1]);
            break;
          case "sp":
            o.speed = n[1];
            break;
          case "vw":
            o.ploadwait = parseInt(n[1], 0) || 5;
            break;
          case "sav":
            o.stopAV = v(n[1]);
            break;
          case "noint":
            o.noInt = v(n[1]);
            break;
          case "l":
            o.loopcache = n[1], o.loop = "loop" === n[1] || "loopandnoslidestop" === n[1] || "none" !== n[1] && v(n[1]);
            break;
          case "ptimer":
            o.pausetimer = v(n[1]);
            break;
          case "sat":
            o.waitToSlideTrans = v(n[1]);
        }
      }
      return null == e.mp4 && null == e.webm && (o.fitCover = !1), void 0 !== e.bgvideo && (o.bgvideo = e.bgvideo), o.noInt && (o.controls = !1), void 0 !== e.mp4 && (o.mp4 = e.mp4), void 0 !== e.videomp4 && (o.mp4 = e.videomp4), void 0 !== e.ytid && (o.ytid = e.ytid), void 0 !== e.ogv && (o.ogv = e.ogv), void 0 !== e.webm && (o.webm = e.webm), void 0 !== e.vimeoid && (o.vimeoid = e.vimeoid), void 0 !== e.vatr && (o.vatr = e.vatr), void 0 !== e.videoattributes && (o.vatr = e.videoattributes), void 0 !== e.poster && (o.poster = e.poster), o.slideid = a, o.aplay = "true" === o.aplay || o.aplay, 1 === o.bgvideo && (o.volume = "mute"), o.ssec = t(o.start), o.esec = t(o.end), o.pausetimer = void 0 === o.pausetimer ? "loopandnoslidestop" !== o.loopcache : o.pausetimer, o.inColumn = e._incolumn, o.audio = e.audio, !0 !== o.loop && "true" !== o.loop || !0 !== o.nse && "true" !== o.nse || (o.loop = !1), o;
    },
    y = function y(e, t) {
      if (i[t].playingvideos = void 0 === i[t].playingvideos ? new Array() : i[t].playingvideos, i[t].videos[e[0].id].stopAV && void 0 !== i[t].playingvideos && i[t].playingvideos.length > 0) for (var a in i[t].lastplayedvideos = jQuery.extend(!0, [], i[t].playingvideos), i[t].playingvideos) i[t].playingvideos.hasOwnProperty(a) && i.stopVideo(i[t].playingvideos[a], t);
      i[t].playingvideos.push(e), i[t].videoIsPlaying = e;
    },
    w = function w(e, t) {
      void 0 !== i[t] && void 0 !== i[t] && null != i[t].playingvideos && jQuery.inArray(e, i[t].playingvideos) >= 0 && i[t].playingvideos.splice(jQuery.inArray(e, i[t].playingvideos), 1);
    },
    b = function b(e, t) {
      if (void 0 !== e && (void 0 === t && (t = 0), i.ISM && !e.bgvideo)) {
        e.playPauseBtnTween && e.playPauseBtnTween.kill && e.playPauseBtnTween.kill();
        var a = i.closestNode(e.video, "RS-LAYER"),
          r = e.controls ? 1 : 0,
          o = e.controls ? 0 : .3;
        e.controls && e.poster && 0 === t && (o = 0, r = 0), a && (e.playPauseBtnTween = tpGS.gsap.to(a.querySelector(".tp-video-play-button"), {
          duration: o,
          delay: r,
          opacity: t
        }));
      }
    };
  window.RS_MODULES = window.RS_MODULES || {}, window.RS_MODULES.video = {
    loaded: !0,
    version: "6.5.4"
  }, window.RS_MODULES.checkMinimal && window.RS_MODULES.checkMinimal();
}(jQuery);
/*!
  * Bootstrap v4.0.0 (//getbootstrap.com)
  * Copyright 2011-2018 The Bootstrap Authors (//github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (//github.com/twbs/bootstrap/blob/master/LICENSE)
  */
!function (t, e) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "undefined" != typeof module ? e(exports, require("jquery"), require("popper.js")) : "function" == typeof define && define.amd ? define(["exports", "jquery", "popper.js"], e) : e(t.bootstrap = {}, t.jQuery, t.Popper);
}(this, function (t, e, n) {
  "use strict";

  function i(t, e) {
    for (var n = 0; n < e.length; n++) {
      var i = e[n];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);
    }
  }
  function s(t, e, n) {
    return e && i(t.prototype, e), n && i(t, n), t;
  }
  function r() {
    return (r = Object.assign || function (t) {
      for (var e = 1; e < arguments.length; e++) {
        var n = arguments[e];
        for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
      }
      return t;
    }).apply(this, arguments);
  }
  e = e && e.hasOwnProperty("default") ? e.default : e, n = n && n.hasOwnProperty("default") ? n.default : n;
  var o,
    a,
    l,
    h,
    c,
    u,
    f,
    d,
    _,
    g,
    p,
    m,
    v,
    E,
    T,
    y,
    C,
    I,
    A,
    b,
    D,
    S,
    w,
    N,
    O,
    k,
    P = function (t) {
      var e = !1;
      function n(e) {
        var n = this,
          s = !1;
        return t(this).one(i.TRANSITION_END, function () {
          s = !0;
        }), setTimeout(function () {
          s || i.triggerTransitionEnd(n);
        }, e), this;
      }
      var i = {
        TRANSITION_END: "bsTransitionEnd",
        getUID: function getUID(t) {
          do {
            t += ~~(1e6 * Math.random());
          } while (document.getElementById(t));
          return t;
        },
        getSelectorFromElement: function getSelectorFromElement(e) {
          var n,
            i = e.getAttribute("data-target");
          i && "#" !== i || (i = e.getAttribute("href") || ""), "#" === i.charAt(0) && (n = i, i = n = "function" == typeof t.escapeSelector ? t.escapeSelector(n).substr(1) : n.replace(/(:|\.|\[|\]|,|=|@)/g, "\\$1"));
          try {
            return t(document).find(i).length > 0 ? i : null;
          } catch (t) {
            return null;
          }
        },
        reflow: function reflow(t) {
          return t.offsetHeight;
        },
        triggerTransitionEnd: function triggerTransitionEnd(n) {
          t(n).trigger(e.end);
        },
        supportsTransitionEnd: function supportsTransitionEnd() {
          return Boolean(e);
        },
        isElement: function isElement(t) {
          return (t[0] || t).nodeType;
        },
        typeCheckConfig: function typeCheckConfig(t, e, n) {
          for (var s in n) if (Object.prototype.hasOwnProperty.call(n, s)) {
            var r = n[s],
              o = e[s],
              a = o && i.isElement(o) ? "element" : (l = o, {}.toString.call(l).match(/\s([a-zA-Z]+)/)[1].toLowerCase());
            if (!new RegExp(r).test(a)) throw new Error(t.toUpperCase() + ': Option "' + s + '" provided type "' + a + '" but expected type "' + r + '".');
          }
          var l;
        }
      };
      return e = ("undefined" == typeof window || !window.QUnit) && {
        end: "transitionend"
      }, t.fn.emulateTransitionEnd = n, i.supportsTransitionEnd() && (t.event.special[i.TRANSITION_END] = {
        bindType: e.end,
        delegateType: e.end,
        handle: function handle(e) {
          if (t(e.target).is(this)) return e.handleObj.handler.apply(this, arguments);
        }
      }), i;
    }(e),
    L = (a = "alert", h = "." + (l = "bs.alert"), c = (o = e).fn[a], u = {
      CLOSE: "close" + h,
      CLOSED: "closed" + h,
      CLICK_DATA_API: "click" + h + ".data-api"
    }, f = "alert", d = "fade", _ = "show", g = function () {
      function t(t) {
        this._element = t;
      }
      var e = t.prototype;
      return e.close = function (t) {
        t = t || this._element;
        var e = this._getRootElement(t);
        this._triggerCloseEvent(e).isDefaultPrevented() || this._removeElement(e);
      }, e.dispose = function () {
        o.removeData(this._element, l), this._element = null;
      }, e._getRootElement = function (t) {
        var e = P.getSelectorFromElement(t),
          n = !1;
        return e && (n = o(e)[0]), n || (n = o(t).closest("." + f)[0]), n;
      }, e._triggerCloseEvent = function (t) {
        var e = o.Event(u.CLOSE);
        return o(t).trigger(e), e;
      }, e._removeElement = function (t) {
        var e = this;
        o(t).removeClass(_), P.supportsTransitionEnd() && o(t).hasClass(d) ? o(t).one(P.TRANSITION_END, function (n) {
          return e._destroyElement(t, n);
        }).emulateTransitionEnd(150) : this._destroyElement(t);
      }, e._destroyElement = function (t) {
        o(t).detach().trigger(u.CLOSED).remove();
      }, t._jQueryInterface = function (e) {
        return this.each(function () {
          var n = o(this),
            i = n.data(l);
          i || (i = new t(this), n.data(l, i)), "close" === e && i[e](this);
        });
      }, t._handleDismiss = function (t) {
        return function (e) {
          e && e.preventDefault(), t.close(this);
        };
      }, s(t, null, [{
        key: "VERSION",
        get: function get() {
          return "4.0.0";
        }
      }]), t;
    }(), o(document).on(u.CLICK_DATA_API, '[data-dismiss="alert"]', g._handleDismiss(new g())), o.fn[a] = g._jQueryInterface, o.fn[a].Constructor = g, o.fn[a].noConflict = function () {
      return o.fn[a] = c, g._jQueryInterface;
    }, g),
    R = (m = "button", E = "." + (v = "bs.button"), T = ".data-api", y = (p = e).fn[m], C = "active", I = "btn", A = "focus", b = '[data-toggle^="button"]', D = '[data-toggle="buttons"]', S = "input", w = ".active", N = ".btn", O = {
      CLICK_DATA_API: "click" + E + T,
      FOCUS_BLUR_DATA_API: "focus" + E + T + " blur" + E + T
    }, k = function () {
      function t(t) {
        this._element = t;
      }
      var e = t.prototype;
      return e.toggle = function () {
        var t = !0,
          e = !0,
          n = p(this._element).closest(D)[0];
        if (n) {
          var i = p(this._element).find(S)[0];
          if (i) {
            if ("radio" === i.type) if (i.checked && p(this._element).hasClass(C)) t = !1;else {
              var s = p(n).find(w)[0];
              s && p(s).removeClass(C);
            }
            if (t) {
              if (i.hasAttribute("disabled") || n.hasAttribute("disabled") || i.classList.contains("disabled") || n.classList.contains("disabled")) return;
              i.checked = !p(this._element).hasClass(C), p(i).trigger("change");
            }
            i.focus(), e = !1;
          }
        }
        e && this._element.setAttribute("aria-pressed", !p(this._element).hasClass(C)), t && p(this._element).toggleClass(C);
      }, e.dispose = function () {
        p.removeData(this._element, v), this._element = null;
      }, t._jQueryInterface = function (e) {
        return this.each(function () {
          var n = p(this).data(v);
          n || (n = new t(this), p(this).data(v, n)), "toggle" === e && n[e]();
        });
      }, s(t, null, [{
        key: "VERSION",
        get: function get() {
          return "4.0.0";
        }
      }]), t;
    }(), p(document).on(O.CLICK_DATA_API, b, function (t) {
      t.preventDefault();
      var e = t.target;
      p(e).hasClass(I) || (e = p(e).closest(N)), k._jQueryInterface.call(p(e), "toggle");
    }).on(O.FOCUS_BLUR_DATA_API, b, function (t) {
      var e = p(t.target).closest(N)[0];
      p(e).toggleClass(A, /^focus(in)?$/.test(t.type));
    }), p.fn[m] = k._jQueryInterface, p.fn[m].Constructor = k, p.fn[m].noConflict = function () {
      return p.fn[m] = y, k._jQueryInterface;
    }, k),
    j = function (t) {
      var e = "carousel",
        n = "bs.carousel",
        i = "." + n,
        o = t.fn[e],
        a = {
          interval: 5e3,
          keyboard: !0,
          slide: !1,
          pause: "hover",
          wrap: !0
        },
        l = {
          interval: "(number|boolean)",
          keyboard: "boolean",
          slide: "(boolean|string)",
          pause: "(string|boolean)",
          wrap: "boolean"
        },
        h = "next",
        c = "prev",
        u = "left",
        f = "right",
        d = {
          SLIDE: "slide" + i,
          SLID: "slid" + i,
          KEYDOWN: "keydown" + i,
          MOUSEENTER: "mouseenter" + i,
          MOUSELEAVE: "mouseleave" + i,
          TOUCHEND: "touchend" + i,
          LOAD_DATA_API: "load" + i + ".data-api",
          CLICK_DATA_API: "click" + i + ".data-api"
        },
        _ = "carousel",
        g = "active",
        p = "slide",
        m = "carousel-item-right",
        v = "carousel-item-left",
        E = "carousel-item-next",
        T = "carousel-item-prev",
        y = {
          ACTIVE: ".active",
          ACTIVE_ITEM: ".active.carousel-item",
          ITEM: ".carousel-item",
          NEXT_PREV: ".carousel-item-next, .carousel-item-prev",
          INDICATORS: ".carousel-indicators",
          DATA_SLIDE: "[data-slide], [data-slide-to]",
          DATA_RIDE: '[data-ride="carousel"]'
        },
        C = function () {
          function o(e, n) {
            this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this._config = this._getConfig(n), this._element = t(e)[0], this._indicatorsElement = t(this._element).find(y.INDICATORS)[0], this._addEventListeners();
          }
          var C = o.prototype;
          return C.next = function () {
            this._isSliding || this._slide(h);
          }, C.nextWhenVisible = function () {
            !document.hidden && t(this._element).is(":visible") && "hidden" !== t(this._element).css("visibility") && this.next();
          }, C.prev = function () {
            this._isSliding || this._slide(c);
          }, C.pause = function (e) {
            e || (this._isPaused = !0), t(this._element).find(y.NEXT_PREV)[0] && P.supportsTransitionEnd() && (P.triggerTransitionEnd(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null;
          }, C.cycle = function (t) {
            t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config.interval && !this._isPaused && (this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval));
          }, C.to = function (e) {
            var n = this;
            this._activeElement = t(this._element).find(y.ACTIVE_ITEM)[0];
            var i = this._getItemIndex(this._activeElement);
            if (!(e > this._items.length - 1 || e < 0)) if (this._isSliding) t(this._element).one(d.SLID, function () {
              return n.to(e);
            });else {
              if (i === e) return this.pause(), void this.cycle();
              var s = e > i ? h : c;
              this._slide(s, this._items[e]);
            }
          }, C.dispose = function () {
            t(this._element).off(i), t.removeData(this._element, n), this._items = null, this._config = null, this._element = null, this._interval = null, this._isPaused = null, this._isSliding = null, this._activeElement = null, this._indicatorsElement = null;
          }, C._getConfig = function (t) {
            return t = r({}, a, t), P.typeCheckConfig(e, t, l), t;
          }, C._addEventListeners = function () {
            var e = this;
            this._config.keyboard && t(this._element).on(d.KEYDOWN, function (t) {
              return e._keydown(t);
            }), "hover" === this._config.pause && (t(this._element).on(d.MOUSEENTER, function (t) {
              return e.pause(t);
            }).on(d.MOUSELEAVE, function (t) {
              return e.cycle(t);
            }), "ontouchstart" in document.documentElement && t(this._element).on(d.TOUCHEND, function () {
              e.pause(), e.touchTimeout && clearTimeout(e.touchTimeout), e.touchTimeout = setTimeout(function (t) {
                return e.cycle(t);
              }, 500 + e._config.interval);
            }));
          }, C._keydown = function (t) {
            if (!/input|textarea/i.test(t.target.tagName)) switch (t.which) {
              case 37:
                t.preventDefault(), this.prev();
                break;
              case 39:
                t.preventDefault(), this.next();
            }
          }, C._getItemIndex = function (e) {
            return this._items = t.makeArray(t(e).parent().find(y.ITEM)), this._items.indexOf(e);
          }, C._getItemByDirection = function (t, e) {
            var n = t === h,
              i = t === c,
              s = this._getItemIndex(e),
              r = this._items.length - 1;
            if ((i && 0 === s || n && s === r) && !this._config.wrap) return e;
            var o = (s + (t === c ? -1 : 1)) % this._items.length;
            return -1 === o ? this._items[this._items.length - 1] : this._items[o];
          }, C._triggerSlideEvent = function (e, n) {
            var i = this._getItemIndex(e),
              s = this._getItemIndex(t(this._element).find(y.ACTIVE_ITEM)[0]),
              r = t.Event(d.SLIDE, {
                relatedTarget: e,
                direction: n,
                from: s,
                to: i
              });
            return t(this._element).trigger(r), r;
          }, C._setActiveIndicatorElement = function (e) {
            if (this._indicatorsElement) {
              t(this._indicatorsElement).find(y.ACTIVE).removeClass(g);
              var n = this._indicatorsElement.children[this._getItemIndex(e)];
              n && t(n).addClass(g);
            }
          }, C._slide = function (e, n) {
            var i,
              s,
              r,
              o = this,
              a = t(this._element).find(y.ACTIVE_ITEM)[0],
              l = this._getItemIndex(a),
              c = n || a && this._getItemByDirection(e, a),
              _ = this._getItemIndex(c),
              C = Boolean(this._interval);
            if (e === h ? (i = v, s = E, r = u) : (i = m, s = T, r = f), c && t(c).hasClass(g)) this._isSliding = !1;else if (!this._triggerSlideEvent(c, r).isDefaultPrevented() && a && c) {
              this._isSliding = !0, C && this.pause(), this._setActiveIndicatorElement(c);
              var I = t.Event(d.SLID, {
                relatedTarget: c,
                direction: r,
                from: l,
                to: _
              });
              P.supportsTransitionEnd() && t(this._element).hasClass(p) ? (t(c).addClass(s), P.reflow(c), t(a).addClass(i), t(c).addClass(i), t(a).one(P.TRANSITION_END, function () {
                t(c).removeClass(i + " " + s).addClass(g), t(a).removeClass(g + " " + s + " " + i), o._isSliding = !1, setTimeout(function () {
                  return t(o._element).trigger(I);
                }, 0);
              }).emulateTransitionEnd(600)) : (t(a).removeClass(g), t(c).addClass(g), this._isSliding = !1, t(this._element).trigger(I)), C && this.cycle();
            }
          }, o._jQueryInterface = function (e) {
            return this.each(function () {
              var i = t(this).data(n),
                s = r({}, a, t(this).data());
              "object" == _typeof(e) && (s = r({}, s, e));
              var l = "string" == typeof e ? e : s.slide;
              if (i || (i = new o(this, s), t(this).data(n, i)), "number" == typeof e) i.to(e);else if ("string" == typeof l) {
                if ("undefined" == typeof i[l]) throw new TypeError('No method named "' + l + '"');
                i[l]();
              } else s.interval && (i.pause(), i.cycle());
            });
          }, o._dataApiClickHandler = function (e) {
            var i = P.getSelectorFromElement(this);
            if (i) {
              var s = t(i)[0];
              if (s && t(s).hasClass(_)) {
                var a = r({}, t(s).data(), t(this).data()),
                  l = this.getAttribute("data-slide-to");
                l && (a.interval = !1), o._jQueryInterface.call(t(s), a), l && t(s).data(n).to(l), e.preventDefault();
              }
            }
          }, s(o, null, [{
            key: "VERSION",
            get: function get() {
              return "4.0.0";
            }
          }, {
            key: "Default",
            get: function get() {
              return a;
            }
          }]), o;
        }();
      return t(document).on(d.CLICK_DATA_API, y.DATA_SLIDE, C._dataApiClickHandler), t(window).on(d.LOAD_DATA_API, function () {
        t(y.DATA_RIDE).each(function () {
          var e = t(this);
          C._jQueryInterface.call(e, e.data());
        });
      }), t.fn[e] = C._jQueryInterface, t.fn[e].Constructor = C, t.fn[e].noConflict = function () {
        return t.fn[e] = o, C._jQueryInterface;
      }, C;
    }(e),
    H = function (t) {
      var e = "collapse",
        n = "bs.collapse",
        i = "." + n,
        o = t.fn[e],
        a = {
          toggle: !0,
          parent: ""
        },
        l = {
          toggle: "boolean",
          parent: "(string|element)"
        },
        h = {
          SHOW: "show" + i,
          SHOWN: "shown" + i,
          HIDE: "hide" + i,
          HIDDEN: "hidden" + i,
          CLICK_DATA_API: "click" + i + ".data-api"
        },
        c = "show",
        u = "collapse",
        f = "collapsing",
        d = "collapsed",
        _ = "width",
        g = "height",
        p = {
          ACTIVES: ".show, .collapsing",
          DATA_TOGGLE: '[data-toggle="collapse"]'
        },
        m = function () {
          function i(e, n) {
            this._isTransitioning = !1, this._element = e, this._config = this._getConfig(n), this._triggerArray = t.makeArray(t('[data-toggle="collapse"][href="#' + e.id + '"],[data-toggle="collapse"][data-target="#' + e.id + '"]'));
            for (var i = t(p.DATA_TOGGLE), s = 0; s < i.length; s++) {
              var r = i[s],
                o = P.getSelectorFromElement(r);
              null !== o && t(o).filter(e).length > 0 && (this._selector = o, this._triggerArray.push(r));
            }
            this._parent = this._config.parent ? this._getParent() : null, this._config.parent || this._addAriaAndCollapsedClass(this._element, this._triggerArray), this._config.toggle && this.toggle();
          }
          var o = i.prototype;
          return o.toggle = function () {
            t(this._element).hasClass(c) ? this.hide() : this.show();
          }, o.show = function () {
            var e,
              s,
              r = this;
            if (!this._isTransitioning && !t(this._element).hasClass(c) && (this._parent && 0 === (e = t.makeArray(t(this._parent).find(p.ACTIVES).filter('[data-parent="' + this._config.parent + '"]'))).length && (e = null), !(e && (s = t(e).not(this._selector).data(n)) && s._isTransitioning))) {
              var o = t.Event(h.SHOW);
              if (t(this._element).trigger(o), !o.isDefaultPrevented()) {
                e && (i._jQueryInterface.call(t(e).not(this._selector), "hide"), s || t(e).data(n, null));
                var a = this._getDimension();
                t(this._element).removeClass(u).addClass(f), this._element.style[a] = 0, this._triggerArray.length > 0 && t(this._triggerArray).removeClass(d).attr("aria-expanded", !0), this.setTransitioning(!0);
                var l = function l() {
                  t(r._element).removeClass(f).addClass(u).addClass(c), r._element.style[a] = "", r.setTransitioning(!1), t(r._element).trigger(h.SHOWN);
                };
                if (P.supportsTransitionEnd()) {
                  var _ = "scroll" + (a[0].toUpperCase() + a.slice(1));
                  t(this._element).one(P.TRANSITION_END, l).emulateTransitionEnd(600), this._element.style[a] = this._element[_] + "px";
                } else l();
              }
            }
          }, o.hide = function () {
            var e = this;
            if (!this._isTransitioning && t(this._element).hasClass(c)) {
              var n = t.Event(h.HIDE);
              if (t(this._element).trigger(n), !n.isDefaultPrevented()) {
                var i = this._getDimension();
                if (this._element.style[i] = this._element.getBoundingClientRect()[i] + "px", P.reflow(this._element), t(this._element).addClass(f).removeClass(u).removeClass(c), this._triggerArray.length > 0) for (var s = 0; s < this._triggerArray.length; s++) {
                  var r = this._triggerArray[s],
                    o = P.getSelectorFromElement(r);
                  if (null !== o) t(o).hasClass(c) || t(r).addClass(d).attr("aria-expanded", !1);
                }
                this.setTransitioning(!0);
                var a = function a() {
                  e.setTransitioning(!1), t(e._element).removeClass(f).addClass(u).trigger(h.HIDDEN);
                };
                this._element.style[i] = "", P.supportsTransitionEnd() ? t(this._element).one(P.TRANSITION_END, a).emulateTransitionEnd(600) : a();
              }
            }
          }, o.setTransitioning = function (t) {
            this._isTransitioning = t;
          }, o.dispose = function () {
            t.removeData(this._element, n), this._config = null, this._parent = null, this._element = null, this._triggerArray = null, this._isTransitioning = null;
          }, o._getConfig = function (t) {
            return (t = r({}, a, t)).toggle = Boolean(t.toggle), P.typeCheckConfig(e, t, l), t;
          }, o._getDimension = function () {
            return t(this._element).hasClass(_) ? _ : g;
          }, o._getParent = function () {
            var e = this,
              n = null;
            P.isElement(this._config.parent) ? (n = this._config.parent, "undefined" != typeof this._config.parent.jquery && (n = this._config.parent[0])) : n = t(this._config.parent)[0];
            var s = '[data-toggle="collapse"][data-parent="' + this._config.parent + '"]';
            return t(n).find(s).each(function (t, n) {
              e._addAriaAndCollapsedClass(i._getTargetFromElement(n), [n]);
            }), n;
          }, o._addAriaAndCollapsedClass = function (e, n) {
            if (e) {
              var i = t(e).hasClass(c);
              n.length > 0 && t(n).toggleClass(d, !i).attr("aria-expanded", i);
            }
          }, i._getTargetFromElement = function (e) {
            var n = P.getSelectorFromElement(e);
            return n ? t(n)[0] : null;
          }, i._jQueryInterface = function (e) {
            return this.each(function () {
              var s = t(this),
                o = s.data(n),
                l = r({}, a, s.data(), "object" == _typeof(e) && e);
              if (!o && l.toggle && /show|hide/.test(e) && (l.toggle = !1), o || (o = new i(this, l), s.data(n, o)), "string" == typeof e) {
                if ("undefined" == typeof o[e]) throw new TypeError('No method named "' + e + '"');
                o[e]();
              }
            });
          }, s(i, null, [{
            key: "VERSION",
            get: function get() {
              return "4.0.0";
            }
          }, {
            key: "Default",
            get: function get() {
              return a;
            }
          }]), i;
        }();
      return t(document).on(h.CLICK_DATA_API, p.DATA_TOGGLE, function (e) {
        "A" === e.currentTarget.tagName && e.preventDefault();
        var i = t(this),
          s = P.getSelectorFromElement(this);
        t(s).each(function () {
          var e = t(this),
            s = e.data(n) ? "toggle" : i.data();
          m._jQueryInterface.call(e, s);
        });
      }), t.fn[e] = m._jQueryInterface, t.fn[e].Constructor = m, t.fn[e].noConflict = function () {
        return t.fn[e] = o, m._jQueryInterface;
      }, m;
    }(e),
    W = function (t) {
      var e = "dropdown",
        i = "bs.dropdown",
        o = "." + i,
        a = ".data-api",
        l = t.fn[e],
        h = new RegExp("38|40|27"),
        c = {
          HIDE: "hide" + o,
          HIDDEN: "hidden" + o,
          SHOW: "show" + o,
          SHOWN: "shown" + o,
          CLICK: "click" + o,
          CLICK_DATA_API: "click" + o + a,
          KEYDOWN_DATA_API: "keydown" + o + a,
          KEYUP_DATA_API: "keyup" + o + a
        },
        u = "disabled",
        f = "show",
        d = "dropup",
        _ = "dropright",
        g = "dropleft",
        p = "dropdown-menu-right",
        m = "dropdown-menu-left",
        v = "position-static",
        E = '[data-toggle="dropdown"]',
        T = ".dropdown form",
        y = ".dropdown-menu",
        C = ".navbar-nav",
        I = ".dropdown-menu .dropdown-item:not(.disabled)",
        A = "top-start",
        b = "top-end",
        D = "bottom-start",
        S = "bottom-end",
        w = "right-start",
        N = "left-start",
        O = {
          offset: 0,
          flip: !0,
          boundary: "scrollParent"
        },
        k = {
          offset: "(number|string|function)",
          flip: "boolean",
          boundary: "(string|element)"
        },
        L = function () {
          function a(t, e) {
            this._element = t, this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._addEventListeners();
          }
          var l = a.prototype;
          return l.toggle = function () {
            if (!this._element.disabled && !t(this._element).hasClass(u)) {
              var e = a._getParentFromElement(this._element),
                i = t(this._menu).hasClass(f);
              if (a._clearMenus(), !i) {
                var s = {
                    relatedTarget: this._element
                  },
                  r = t.Event(c.SHOW, s);
                if (t(e).trigger(r), !r.isDefaultPrevented()) {
                  if (!this._inNavbar) {
                    if ("undefined" == typeof n) throw new TypeError("Bootstrap dropdown require Popper.js (//popper.js.org)");
                    var o = this._element;
                    t(e).hasClass(d) && (t(this._menu).hasClass(m) || t(this._menu).hasClass(p)) && (o = e), "scrollParent" !== this._config.boundary && t(e).addClass(v), this._popper = new n(o, this._menu, this._getPopperConfig());
                  }
                  "ontouchstart" in document.documentElement && 0 === t(e).closest(C).length && t("body").children().on("mouseover", null, t.noop), this._element.focus(), this._element.setAttribute("aria-expanded", !0), t(this._menu).toggleClass(f), t(e).toggleClass(f).trigger(t.Event(c.SHOWN, s));
                }
              }
            }
          }, l.dispose = function () {
            t.removeData(this._element, i), t(this._element).off(o), this._element = null, this._menu = null, null !== this._popper && (this._popper.destroy(), this._popper = null);
          }, l.update = function () {
            this._inNavbar = this._detectNavbar(), null !== this._popper && this._popper.scheduleUpdate();
          }, l._addEventListeners = function () {
            var e = this;
            t(this._element).on(c.CLICK, function (t) {
              t.preventDefault(), t.stopPropagation(), e.toggle();
            });
          }, l._getConfig = function (n) {
            return n = r({}, this.constructor.Default, t(this._element).data(), n), P.typeCheckConfig(e, n, this.constructor.DefaultType), n;
          }, l._getMenuElement = function () {
            if (!this._menu) {
              var e = a._getParentFromElement(this._element);
              this._menu = t(e).find(y)[0];
            }
            return this._menu;
          }, l._getPlacement = function () {
            var e = t(this._element).parent(),
              n = D;
            return e.hasClass(d) ? (n = A, t(this._menu).hasClass(p) && (n = b)) : e.hasClass(_) ? n = w : e.hasClass(g) ? n = N : t(this._menu).hasClass(p) && (n = S), n;
          }, l._detectNavbar = function () {
            return t(this._element).closest(".navbar").length > 0;
          }, l._getPopperConfig = function () {
            var t = this,
              e = {};
            return "function" == typeof this._config.offset ? e.fn = function (e) {
              return e.offsets = r({}, e.offsets, t._config.offset(e.offsets) || {}), e;
            } : e.offset = this._config.offset, {
              placement: this._getPlacement(),
              modifiers: {
                offset: e,
                flip: {
                  enabled: this._config.flip
                },
                preventOverflow: {
                  boundariesElement: this._config.boundary
                }
              }
            };
          }, a._jQueryInterface = function (e) {
            return this.each(function () {
              var n = t(this).data(i);
              if (n || (n = new a(this, "object" == _typeof(e) ? e : null), t(this).data(i, n)), "string" == typeof e) {
                if ("undefined" == typeof n[e]) throw new TypeError('No method named "' + e + '"');
                n[e]();
              }
            });
          }, a._clearMenus = function (e) {
            if (!e || 3 !== e.which && ("keyup" !== e.type || 9 === e.which)) for (var n = t.makeArray(t(E)), s = 0; s < n.length; s++) {
              var r = a._getParentFromElement(n[s]),
                o = t(n[s]).data(i),
                l = {
                  relatedTarget: n[s]
                };
              if (o) {
                var h = o._menu;
                if (t(r).hasClass(f) && !(e && ("click" === e.type && /input|textarea/i.test(e.target.tagName) || "keyup" === e.type && 9 === e.which) && t.contains(r, e.target))) {
                  var u = t.Event(c.HIDE, l);
                  t(r).trigger(u), u.isDefaultPrevented() || ("ontouchstart" in document.documentElement && t("body").children().off("mouseover", null, t.noop), n[s].setAttribute("aria-expanded", "false"), t(h).removeClass(f), t(r).removeClass(f).trigger(t.Event(c.HIDDEN, l)));
                }
              }
            }
          }, a._getParentFromElement = function (e) {
            var n,
              i = P.getSelectorFromElement(e);
            return i && (n = t(i)[0]), n || e.parentNode;
          }, a._dataApiKeydownHandler = function (e) {
            if ((/input|textarea/i.test(e.target.tagName) ? !(32 === e.which || 27 !== e.which && (40 !== e.which && 38 !== e.which || t(e.target).closest(y).length)) : h.test(e.which)) && (e.preventDefault(), e.stopPropagation(), !this.disabled && !t(this).hasClass(u))) {
              var n = a._getParentFromElement(this),
                i = t(n).hasClass(f);
              if ((i || 27 === e.which && 32 === e.which) && (!i || 27 !== e.which && 32 !== e.which)) {
                var s = t(n).find(I).get();
                if (0 !== s.length) {
                  var r = s.indexOf(e.target);
                  38 === e.which && r > 0 && r--, 40 === e.which && r < s.length - 1 && r++, r < 0 && (r = 0), s[r].focus();
                }
              } else {
                if (27 === e.which) {
                  var o = t(n).find(E)[0];
                  t(o).trigger("focus");
                }
                t(this).trigger("click");
              }
            }
          }, s(a, null, [{
            key: "VERSION",
            get: function get() {
              return "4.0.0";
            }
          }, {
            key: "Default",
            get: function get() {
              return O;
            }
          }, {
            key: "DefaultType",
            get: function get() {
              return k;
            }
          }]), a;
        }();
      return t(document).on(c.KEYDOWN_DATA_API, E, L._dataApiKeydownHandler).on(c.KEYDOWN_DATA_API, y, L._dataApiKeydownHandler).on(c.CLICK_DATA_API + " " + c.KEYUP_DATA_API, L._clearMenus).on(c.CLICK_DATA_API, E, function (e) {
        e.preventDefault(), e.stopPropagation(), L._jQueryInterface.call(t(this), "toggle");
      }).on(c.CLICK_DATA_API, T, function (t) {
        t.stopPropagation();
      }), t.fn[e] = L._jQueryInterface, t.fn[e].Constructor = L, t.fn[e].noConflict = function () {
        return t.fn[e] = l, L._jQueryInterface;
      }, L;
    }(e),
    M = function (t) {
      var e = "modal",
        n = "bs.modal",
        i = "." + n,
        o = t.fn.modal,
        a = {
          backdrop: !0,
          keyboard: !0,
          focus: !0,
          show: !0
        },
        l = {
          backdrop: "(boolean|string)",
          keyboard: "boolean",
          focus: "boolean",
          show: "boolean"
        },
        h = {
          HIDE: "hide" + i,
          HIDDEN: "hidden" + i,
          SHOW: "show" + i,
          SHOWN: "shown" + i,
          FOCUSIN: "focusin" + i,
          RESIZE: "resize" + i,
          CLICK_DISMISS: "click.dismiss" + i,
          KEYDOWN_DISMISS: "keydown.dismiss" + i,
          MOUSEUP_DISMISS: "mouseup.dismiss" + i,
          MOUSEDOWN_DISMISS: "mousedown.dismiss" + i,
          CLICK_DATA_API: "click" + i + ".data-api"
        },
        c = "modal-scrollbar-measure",
        u = "modal-backdrop",
        f = "modal-open",
        d = "fade",
        _ = "show",
        g = {
          DIALOG: ".modal-dialog",
          DATA_TOGGLE: '[data-toggle="modal"]',
          DATA_DISMISS: '[data-dismiss="modal"]',
          FIXED_CONTENT: ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
          STICKY_CONTENT: ".sticky-top",
          NAVBAR_TOGGLER: ".navbar-toggler"
        },
        p = function () {
          function o(e, n) {
            this._config = this._getConfig(n), this._element = e, this._dialog = t(e).find(g.DIALOG)[0], this._backdrop = null, this._isShown = !1, this._isBodyOverflowing = !1, this._ignoreBackdropClick = !1, this._originalBodyPadding = 0, this._scrollbarWidth = 0;
          }
          var p = o.prototype;
          return p.toggle = function (t) {
            return this._isShown ? this.hide() : this.show(t);
          }, p.show = function (e) {
            var n = this;
            if (!this._isTransitioning && !this._isShown) {
              P.supportsTransitionEnd() && t(this._element).hasClass(d) && (this._isTransitioning = !0);
              var i = t.Event(h.SHOW, {
                relatedTarget: e
              });
              t(this._element).trigger(i), this._isShown || i.isDefaultPrevented() || (this._isShown = !0, this._checkScrollbar(), this._setScrollbar(), this._adjustDialog(), t(document.body).addClass(f), this._setEscapeEvent(), this._setResizeEvent(), t(this._element).on(h.CLICK_DISMISS, g.DATA_DISMISS, function (t) {
                return n.hide(t);
              }), t(this._dialog).on(h.MOUSEDOWN_DISMISS, function () {
                t(n._element).one(h.MOUSEUP_DISMISS, function (e) {
                  t(e.target).is(n._element) && (n._ignoreBackdropClick = !0);
                });
              }), this._showBackdrop(function () {
                return n._showElement(e);
              }));
            }
          }, p.hide = function (e) {
            var n = this;
            if (e && e.preventDefault(), !this._isTransitioning && this._isShown) {
              var i = t.Event(h.HIDE);
              if (t(this._element).trigger(i), this._isShown && !i.isDefaultPrevented()) {
                this._isShown = !1;
                var s = P.supportsTransitionEnd() && t(this._element).hasClass(d);
                s && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), t(document).off(h.FOCUSIN), t(this._element).removeClass(_), t(this._element).off(h.CLICK_DISMISS), t(this._dialog).off(h.MOUSEDOWN_DISMISS), s ? t(this._element).one(P.TRANSITION_END, function (t) {
                  return n._hideModal(t);
                }).emulateTransitionEnd(300) : this._hideModal();
              }
            }
          }, p.dispose = function () {
            t.removeData(this._element, n), t(window, document, this._element, this._backdrop).off(i), this._config = null, this._element = null, this._dialog = null, this._backdrop = null, this._isShown = null, this._isBodyOverflowing = null, this._ignoreBackdropClick = null, this._scrollbarWidth = null;
          }, p.handleUpdate = function () {
            this._adjustDialog();
          }, p._getConfig = function (t) {
            return t = r({}, a, t), P.typeCheckConfig(e, t, l), t;
          }, p._showElement = function (e) {
            var n = this,
              i = P.supportsTransitionEnd() && t(this._element).hasClass(d);
            this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.scrollTop = 0, i && P.reflow(this._element), t(this._element).addClass(_), this._config.focus && this._enforceFocus();
            var s = t.Event(h.SHOWN, {
                relatedTarget: e
              }),
              r = function r() {
                n._config.focus && n._element.focus(), n._isTransitioning = !1, t(n._element).trigger(s);
              };
            i ? t(this._dialog).one(P.TRANSITION_END, r).emulateTransitionEnd(300) : r();
          }, p._enforceFocus = function () {
            var e = this;
            t(document).off(h.FOCUSIN).on(h.FOCUSIN, function (n) {
              document !== n.target && e._element !== n.target && 0 === t(e._element).has(n.target).length && e._element.focus();
            });
          }, p._setEscapeEvent = function () {
            var e = this;
            this._isShown && this._config.keyboard ? t(this._element).on(h.KEYDOWN_DISMISS, function (t) {
              27 === t.which && (t.preventDefault(), e.hide());
            }) : this._isShown || t(this._element).off(h.KEYDOWN_DISMISS);
          }, p._setResizeEvent = function () {
            var e = this;
            this._isShown ? t(window).on(h.RESIZE, function (t) {
              return e.handleUpdate(t);
            }) : t(window).off(h.RESIZE);
          }, p._hideModal = function () {
            var e = this;
            this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._isTransitioning = !1, this._showBackdrop(function () {
              t(document.body).removeClass(f), e._resetAdjustments(), e._resetScrollbar(), t(e._element).trigger(h.HIDDEN);
            });
          }, p._removeBackdrop = function () {
            this._backdrop && (t(this._backdrop).remove(), this._backdrop = null);
          }, p._showBackdrop = function (e) {
            var n = this,
              i = t(this._element).hasClass(d) ? d : "";
            if (this._isShown && this._config.backdrop) {
              var s = P.supportsTransitionEnd() && i;
              if (this._backdrop = document.createElement("div"), this._backdrop.className = u, i && t(this._backdrop).addClass(i), t(this._backdrop).appendTo(document.body), t(this._element).on(h.CLICK_DISMISS, function (t) {
                n._ignoreBackdropClick ? n._ignoreBackdropClick = !1 : t.target === t.currentTarget && ("static" === n._config.backdrop ? n._element.focus() : n.hide());
              }), s && P.reflow(this._backdrop), t(this._backdrop).addClass(_), !e) return;
              if (!s) return void e();
              t(this._backdrop).one(P.TRANSITION_END, e).emulateTransitionEnd(150);
            } else if (!this._isShown && this._backdrop) {
              t(this._backdrop).removeClass(_);
              var r = function r() {
                n._removeBackdrop(), e && e();
              };
              P.supportsTransitionEnd() && t(this._element).hasClass(d) ? t(this._backdrop).one(P.TRANSITION_END, r).emulateTransitionEnd(150) : r();
            } else e && e();
          }, p._adjustDialog = function () {
            var t = this._element.scrollHeight > document.documentElement.clientHeight;
            !this._isBodyOverflowing && t && (this._element.style.paddingLeft = this._scrollbarWidth + "px"), this._isBodyOverflowing && !t && (this._element.style.paddingRight = this._scrollbarWidth + "px");
          }, p._resetAdjustments = function () {
            this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
          }, p._checkScrollbar = function () {
            var t = document.body.getBoundingClientRect();
            this._isBodyOverflowing = t.left + t.right < window.innerWidth, this._scrollbarWidth = this._getScrollbarWidth();
          }, p._setScrollbar = function () {
            var e = this;
            if (this._isBodyOverflowing) {
              t(g.FIXED_CONTENT).each(function (n, i) {
                var s = t(i)[0].style.paddingRight,
                  r = t(i).css("padding-right");
                t(i).data("padding-right", s).css("padding-right", parseFloat(r) + e._scrollbarWidth + "px");
              }), t(g.STICKY_CONTENT).each(function (n, i) {
                var s = t(i)[0].style.marginRight,
                  r = t(i).css("margin-right");
                t(i).data("margin-right", s).css("margin-right", parseFloat(r) - e._scrollbarWidth + "px");
              }), t(g.NAVBAR_TOGGLER).each(function (n, i) {
                var s = t(i)[0].style.marginRight,
                  r = t(i).css("margin-right");
                t(i).data("margin-right", s).css("margin-right", parseFloat(r) + e._scrollbarWidth + "px");
              });
              var n = document.body.style.paddingRight,
                i = t("body").css("padding-right");
              t("body").data("padding-right", n).css("padding-right", parseFloat(i) + this._scrollbarWidth + "px");
            }
          }, p._resetScrollbar = function () {
            t(g.FIXED_CONTENT).each(function (e, n) {
              var i = t(n).data("padding-right");
              "undefined" != typeof i && t(n).css("padding-right", i).removeData("padding-right");
            }), t(g.STICKY_CONTENT + ", " + g.NAVBAR_TOGGLER).each(function (e, n) {
              var i = t(n).data("margin-right");
              "undefined" != typeof i && t(n).css("margin-right", i).removeData("margin-right");
            });
            var e = t("body").data("padding-right");
            "undefined" != typeof e && t("body").css("padding-right", e).removeData("padding-right");
          }, p._getScrollbarWidth = function () {
            var t = document.createElement("div");
            t.className = c, document.body.appendChild(t);
            var e = t.getBoundingClientRect().width - t.clientWidth;
            return document.body.removeChild(t), e;
          }, o._jQueryInterface = function (e, i) {
            return this.each(function () {
              var s = t(this).data(n),
                a = r({}, o.Default, t(this).data(), "object" == _typeof(e) && e);
              if (s || (s = new o(this, a), t(this).data(n, s)), "string" == typeof e) {
                if ("undefined" == typeof s[e]) throw new TypeError('No method named "' + e + '"');
                s[e](i);
              } else a.show && s.show(i);
            });
          }, s(o, null, [{
            key: "VERSION",
            get: function get() {
              return "4.0.0";
            }
          }, {
            key: "Default",
            get: function get() {
              return a;
            }
          }]), o;
        }();
      return t(document).on(h.CLICK_DATA_API, g.DATA_TOGGLE, function (e) {
        var i,
          s = this,
          o = P.getSelectorFromElement(this);
        o && (i = t(o)[0]);
        var a = t(i).data(n) ? "toggle" : r({}, t(i).data(), t(this).data());
        "A" !== this.tagName && "AREA" !== this.tagName || e.preventDefault();
        var l = t(i).one(h.SHOW, function (e) {
          e.isDefaultPrevented() || l.one(h.HIDDEN, function () {
            t(s).is(":visible") && s.focus();
          });
        });
        p._jQueryInterface.call(t(i), a, this);
      }), t.fn.modal = p._jQueryInterface, t.fn.modal.Constructor = p, t.fn.modal.noConflict = function () {
        return t.fn.modal = o, p._jQueryInterface;
      }, p;
    }(e),
    U = function (t) {
      var e = "tooltip",
        i = "bs.tooltip",
        o = "." + i,
        a = t.fn[e],
        l = new RegExp("(^|\\s)bs-tooltip\\S+", "g"),
        h = {
          animation: "boolean",
          template: "string",
          title: "(string|element|function)",
          trigger: "string",
          delay: "(number|object)",
          html: "boolean",
          selector: "(string|boolean)",
          placement: "(string|function)",
          offset: "(number|string)",
          container: "(string|element|boolean)",
          fallbackPlacement: "(string|array)",
          boundary: "(string|element)"
        },
        c = {
          AUTO: "auto",
          TOP: "top",
          RIGHT: "right",
          BOTTOM: "bottom",
          LEFT: "left"
        },
        u = {
          animation: !0,
          template: '<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>',
          trigger: "hover focus",
          title: "",
          delay: 0,
          html: !1,
          selector: !1,
          placement: "top",
          offset: 0,
          container: !1,
          fallbackPlacement: "flip",
          boundary: "scrollParent"
        },
        f = "show",
        d = "out",
        _ = {
          HIDE: "hide" + o,
          HIDDEN: "hidden" + o,
          SHOW: "show" + o,
          SHOWN: "shown" + o,
          INSERTED: "inserted" + o,
          CLICK: "click" + o,
          FOCUSIN: "focusin" + o,
          FOCUSOUT: "focusout" + o,
          MOUSEENTER: "mouseenter" + o,
          MOUSELEAVE: "mouseleave" + o
        },
        g = "fade",
        p = "show",
        m = ".tooltip-inner",
        v = ".arrow",
        E = "hover",
        T = "focus",
        y = "click",
        C = "manual",
        I = function () {
          function a(t, e) {
            if ("undefined" == typeof n) throw new TypeError("Bootstrap tooltips require Popper.js (//popper.js.org)");
            this._isEnabled = !0, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this.element = t, this.config = this._getConfig(e), this.tip = null, this._setListeners();
          }
          var I = a.prototype;
          return I.enable = function () {
            this._isEnabled = !0;
          }, I.disable = function () {
            this._isEnabled = !1;
          }, I.toggleEnabled = function () {
            this._isEnabled = !this._isEnabled;
          }, I.toggle = function (e) {
            if (this._isEnabled) if (e) {
              var n = this.constructor.DATA_KEY,
                i = t(e.currentTarget).data(n);
              i || (i = new this.constructor(e.currentTarget, this._getDelegateConfig()), t(e.currentTarget).data(n, i)), i._activeTrigger.click = !i._activeTrigger.click, i._isWithActiveTrigger() ? i._enter(null, i) : i._leave(null, i);
            } else {
              if (t(this.getTipElement()).hasClass(p)) return void this._leave(null, this);
              this._enter(null, this);
            }
          }, I.dispose = function () {
            clearTimeout(this._timeout), t.removeData(this.element, this.constructor.DATA_KEY), t(this.element).off(this.constructor.EVENT_KEY), t(this.element).closest(".modal").off("hide.bs.modal"), this.tip && t(this.tip).remove(), this._isEnabled = null, this._timeout = null, this._hoverState = null, this._activeTrigger = null, null !== this._popper && this._popper.destroy(), this._popper = null, this.element = null, this.config = null, this.tip = null;
          }, I.show = function () {
            var e = this;
            if ("none" === t(this.element).css("display")) throw new Error("Please use show on visible elements");
            var i = t.Event(this.constructor.Event.SHOW);
            if (this.isWithContent() && this._isEnabled) {
              t(this.element).trigger(i);
              var s = t.contains(this.element.ownerDocument.documentElement, this.element);
              if (i.isDefaultPrevented() || !s) return;
              var r = this.getTipElement(),
                o = P.getUID(this.constructor.NAME);
              r.setAttribute("id", o), this.element.setAttribute("aria-describedby", o), this.setContent(), this.config.animation && t(r).addClass(g);
              var l = "function" == typeof this.config.placement ? this.config.placement.call(this, r, this.element) : this.config.placement,
                h = this._getAttachment(l);
              this.addAttachmentClass(h);
              var c = !1 === this.config.container ? document.body : t(this.config.container);
              t(r).data(this.constructor.DATA_KEY, this), t.contains(this.element.ownerDocument.documentElement, this.tip) || t(r).appendTo(c), t(this.element).trigger(this.constructor.Event.INSERTED), this._popper = new n(this.element, r, {
                placement: h,
                modifiers: {
                  offset: {
                    offset: this.config.offset
                  },
                  flip: {
                    behavior: this.config.fallbackPlacement
                  },
                  arrow: {
                    element: v
                  },
                  preventOverflow: {
                    boundariesElement: this.config.boundary
                  }
                },
                onCreate: function onCreate(t) {
                  t.originalPlacement !== t.placement && e._handlePopperPlacementChange(t);
                },
                onUpdate: function onUpdate(t) {
                  e._handlePopperPlacementChange(t);
                }
              }), t(r).addClass(p), "ontouchstart" in document.documentElement && t("body").children().on("mouseover", null, t.noop);
              var u = function u() {
                e.config.animation && e._fixTransition();
                var n = e._hoverState;
                e._hoverState = null, t(e.element).trigger(e.constructor.Event.SHOWN), n === d && e._leave(null, e);
              };
              P.supportsTransitionEnd() && t(this.tip).hasClass(g) ? t(this.tip).one(P.TRANSITION_END, u).emulateTransitionEnd(a._TRANSITION_DURATION) : u();
            }
          }, I.hide = function (e) {
            var n = this,
              i = this.getTipElement(),
              s = t.Event(this.constructor.Event.HIDE),
              r = function r() {
                n._hoverState !== f && i.parentNode && i.parentNode.removeChild(i), n._cleanTipClass(), n.element.removeAttribute("aria-describedby"), t(n.element).trigger(n.constructor.Event.HIDDEN), null !== n._popper && n._popper.destroy(), e && e();
              };
            t(this.element).trigger(s), s.isDefaultPrevented() || (t(i).removeClass(p), "ontouchstart" in document.documentElement && t("body").children().off("mouseover", null, t.noop), this._activeTrigger[y] = !1, this._activeTrigger[T] = !1, this._activeTrigger[E] = !1, P.supportsTransitionEnd() && t(this.tip).hasClass(g) ? t(i).one(P.TRANSITION_END, r).emulateTransitionEnd(150) : r(), this._hoverState = "");
          }, I.update = function () {
            null !== this._popper && this._popper.scheduleUpdate();
          }, I.isWithContent = function () {
            return Boolean(this.getTitle());
          }, I.addAttachmentClass = function (e) {
            t(this.getTipElement()).addClass("bs-tooltip-" + e);
          }, I.getTipElement = function () {
            return this.tip = this.tip || t(this.config.template)[0], this.tip;
          }, I.setContent = function () {
            var e = t(this.getTipElement());
            this.setElementContent(e.find(m), this.getTitle()), e.removeClass(g + " " + p);
          }, I.setElementContent = function (e, n) {
            var i = this.config.html;
            "object" == _typeof(n) && (n.nodeType || n.jquery) ? i ? t(n).parent().is(e) || e.empty().append(n) : e.text(t(n).text()) : e[i ? "html" : "text"](n);
          }, I.getTitle = function () {
            var t = this.element.getAttribute("data-original-title");
            return t || (t = "function" == typeof this.config.title ? this.config.title.call(this.element) : this.config.title), t;
          }, I._getAttachment = function (t) {
            return c[t.toUpperCase()];
          }, I._setListeners = function () {
            var e = this;
            this.config.trigger.split(" ").forEach(function (n) {
              if ("click" === n) t(e.element).on(e.constructor.Event.CLICK, e.config.selector, function (t) {
                return e.toggle(t);
              });else if (n !== C) {
                var i = n === E ? e.constructor.Event.MOUSEENTER : e.constructor.Event.FOCUSIN,
                  s = n === E ? e.constructor.Event.MOUSELEAVE : e.constructor.Event.FOCUSOUT;
                t(e.element).on(i, e.config.selector, function (t) {
                  return e._enter(t);
                }).on(s, e.config.selector, function (t) {
                  return e._leave(t);
                });
              }
              t(e.element).closest(".modal").on("hide.bs.modal", function () {
                return e.hide();
              });
            }), this.config.selector ? this.config = r({}, this.config, {
              trigger: "manual",
              selector: ""
            }) : this._fixTitle();
          }, I._fixTitle = function () {
            var t = _typeof(this.element.getAttribute("data-original-title"));
            (this.element.getAttribute("title") || "string" !== t) && (this.element.setAttribute("data-original-title", this.element.getAttribute("title") || ""), this.element.setAttribute("title", ""));
          }, I._enter = function (e, n) {
            var i = this.constructor.DATA_KEY;
            (n = n || t(e.currentTarget).data(i)) || (n = new this.constructor(e.currentTarget, this._getDelegateConfig()), t(e.currentTarget).data(i, n)), e && (n._activeTrigger["focusin" === e.type ? T : E] = !0), t(n.getTipElement()).hasClass(p) || n._hoverState === f ? n._hoverState = f : (clearTimeout(n._timeout), n._hoverState = f, n.config.delay && n.config.delay.show ? n._timeout = setTimeout(function () {
              n._hoverState === f && n.show();
            }, n.config.delay.show) : n.show());
          }, I._leave = function (e, n) {
            var i = this.constructor.DATA_KEY;
            (n = n || t(e.currentTarget).data(i)) || (n = new this.constructor(e.currentTarget, this._getDelegateConfig()), t(e.currentTarget).data(i, n)), e && (n._activeTrigger["focusout" === e.type ? T : E] = !1), n._isWithActiveTrigger() || (clearTimeout(n._timeout), n._hoverState = d, n.config.delay && n.config.delay.hide ? n._timeout = setTimeout(function () {
              n._hoverState === d && n.hide();
            }, n.config.delay.hide) : n.hide());
          }, I._isWithActiveTrigger = function () {
            for (var t in this._activeTrigger) if (this._activeTrigger[t]) return !0;
            return !1;
          }, I._getConfig = function (n) {
            return "number" == typeof (n = r({}, this.constructor.Default, t(this.element).data(), n)).delay && (n.delay = {
              show: n.delay,
              hide: n.delay
            }), "number" == typeof n.title && (n.title = n.title.toString()), "number" == typeof n.content && (n.content = n.content.toString()), P.typeCheckConfig(e, n, this.constructor.DefaultType), n;
          }, I._getDelegateConfig = function () {
            var t = {};
            if (this.config) for (var e in this.config) this.constructor.Default[e] !== this.config[e] && (t[e] = this.config[e]);
            return t;
          }, I._cleanTipClass = function () {
            var e = t(this.getTipElement()),
              n = e.attr("class").match(l);
            null !== n && n.length > 0 && e.removeClass(n.join(""));
          }, I._handlePopperPlacementChange = function (t) {
            this._cleanTipClass(), this.addAttachmentClass(this._getAttachment(t.placement));
          }, I._fixTransition = function () {
            var e = this.getTipElement(),
              n = this.config.animation;
            null === e.getAttribute("x-placement") && (t(e).removeClass(g), this.config.animation = !1, this.hide(), this.show(), this.config.animation = n);
          }, a._jQueryInterface = function (e) {
            return this.each(function () {
              var n = t(this).data(i),
                s = "object" == _typeof(e) && e;
              if ((n || !/dispose|hide/.test(e)) && (n || (n = new a(this, s), t(this).data(i, n)), "string" == typeof e)) {
                if ("undefined" == typeof n[e]) throw new TypeError('No method named "' + e + '"');
                n[e]();
              }
            });
          }, s(a, null, [{
            key: "VERSION",
            get: function get() {
              return "4.0.0";
            }
          }, {
            key: "Default",
            get: function get() {
              return u;
            }
          }, {
            key: "NAME",
            get: function get() {
              return e;
            }
          }, {
            key: "DATA_KEY",
            get: function get() {
              return i;
            }
          }, {
            key: "Event",
            get: function get() {
              return _;
            }
          }, {
            key: "EVENT_KEY",
            get: function get() {
              return o;
            }
          }, {
            key: "DefaultType",
            get: function get() {
              return h;
            }
          }]), a;
        }();
      return t.fn[e] = I._jQueryInterface, t.fn[e].Constructor = I, t.fn[e].noConflict = function () {
        return t.fn[e] = a, I._jQueryInterface;
      }, I;
    }(e),
    x = function (t) {
      var e = "popover",
        n = "bs.popover",
        i = "." + n,
        o = t.fn[e],
        a = new RegExp("(^|\\s)bs-popover\\S+", "g"),
        l = r({}, U.Default, {
          placement: "right",
          trigger: "click",
          content: "",
          template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
        }),
        h = r({}, U.DefaultType, {
          content: "(string|element|function)"
        }),
        c = "fade",
        u = "show",
        f = ".popover-header",
        d = ".popover-body",
        _ = {
          HIDE: "hide" + i,
          HIDDEN: "hidden" + i,
          SHOW: "show" + i,
          SHOWN: "shown" + i,
          INSERTED: "inserted" + i,
          CLICK: "click" + i,
          FOCUSIN: "focusin" + i,
          FOCUSOUT: "focusout" + i,
          MOUSEENTER: "mouseenter" + i,
          MOUSELEAVE: "mouseleave" + i
        },
        g = function (r) {
          var o, g;
          function p() {
            return r.apply(this, arguments) || this;
          }
          g = r, (o = p).prototype = Object.create(g.prototype), o.prototype.constructor = o, o.__proto__ = g;
          var m = p.prototype;
          return m.isWithContent = function () {
            return this.getTitle() || this._getContent();
          }, m.addAttachmentClass = function (e) {
            t(this.getTipElement()).addClass("bs-popover-" + e);
          }, m.getTipElement = function () {
            return this.tip = this.tip || t(this.config.template)[0], this.tip;
          }, m.setContent = function () {
            var e = t(this.getTipElement());
            this.setElementContent(e.find(f), this.getTitle());
            var n = this._getContent();
            "function" == typeof n && (n = n.call(this.element)), this.setElementContent(e.find(d), n), e.removeClass(c + " " + u);
          }, m._getContent = function () {
            return this.element.getAttribute("data-content") || this.config.content;
          }, m._cleanTipClass = function () {
            var e = t(this.getTipElement()),
              n = e.attr("class").match(a);
            null !== n && n.length > 0 && e.removeClass(n.join(""));
          }, p._jQueryInterface = function (e) {
            return this.each(function () {
              var i = t(this).data(n),
                s = "object" == _typeof(e) ? e : null;
              if ((i || !/destroy|hide/.test(e)) && (i || (i = new p(this, s), t(this).data(n, i)), "string" == typeof e)) {
                if ("undefined" == typeof i[e]) throw new TypeError('No method named "' + e + '"');
                i[e]();
              }
            });
          }, s(p, null, [{
            key: "VERSION",
            get: function get() {
              return "4.0.0";
            }
          }, {
            key: "Default",
            get: function get() {
              return l;
            }
          }, {
            key: "NAME",
            get: function get() {
              return e;
            }
          }, {
            key: "DATA_KEY",
            get: function get() {
              return n;
            }
          }, {
            key: "Event",
            get: function get() {
              return _;
            }
          }, {
            key: "EVENT_KEY",
            get: function get() {
              return i;
            }
          }, {
            key: "DefaultType",
            get: function get() {
              return h;
            }
          }]), p;
        }(U);
      return t.fn[e] = g._jQueryInterface, t.fn[e].Constructor = g, t.fn[e].noConflict = function () {
        return t.fn[e] = o, g._jQueryInterface;
      }, g;
    }(e),
    K = function (t) {
      var e = "scrollspy",
        n = "bs.scrollspy",
        i = "." + n,
        o = t.fn[e],
        a = {
          offset: 10,
          method: "auto",
          target: ""
        },
        l = {
          offset: "number",
          method: "string",
          target: "(string|element)"
        },
        h = {
          ACTIVATE: "activate" + i,
          SCROLL: "scroll" + i,
          LOAD_DATA_API: "load" + i + ".data-api"
        },
        c = "dropdown-item",
        u = "active",
        f = {
          DATA_SPY: '[data-spy="scroll"]',
          ACTIVE: ".active",
          NAV_LIST_GROUP: ".nav, .list-group",
          NAV_LINKS: ".nav-link",
          NAV_ITEMS: ".nav-item",
          LIST_ITEMS: ".list-group-item",
          DROPDOWN: ".dropdown",
          DROPDOWN_ITEMS: ".dropdown-item",
          DROPDOWN_TOGGLE: ".dropdown-toggle"
        },
        d = "offset",
        _ = "position",
        g = function () {
          function o(e, n) {
            var i = this;
            this._element = e, this._scrollElement = "BODY" === e.tagName ? window : e, this._config = this._getConfig(n), this._selector = this._config.target + " " + f.NAV_LINKS + "," + this._config.target + " " + f.LIST_ITEMS + "," + this._config.target + " " + f.DROPDOWN_ITEMS, this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, t(this._scrollElement).on(h.SCROLL, function (t) {
              return i._process(t);
            }), this.refresh(), this._process();
          }
          var g = o.prototype;
          return g.refresh = function () {
            var e = this,
              n = this._scrollElement === this._scrollElement.window ? d : _,
              i = "auto" === this._config.method ? n : this._config.method,
              s = i === _ ? this._getScrollTop() : 0;
            this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), t.makeArray(t(this._selector)).map(function (e) {
              var n,
                r = P.getSelectorFromElement(e);
              if (r && (n = t(r)[0]), n) {
                var o = n.getBoundingClientRect();
                if (o.width || o.height) return [t(n)[i]().top + s, r];
              }
              return null;
            }).filter(function (t) {
              return t;
            }).sort(function (t, e) {
              return t[0] - e[0];
            }).forEach(function (t) {
              e._offsets.push(t[0]), e._targets.push(t[1]);
            });
          }, g.dispose = function () {
            t.removeData(this._element, n), t(this._scrollElement).off(i), this._element = null, this._scrollElement = null, this._config = null, this._selector = null, this._offsets = null, this._targets = null, this._activeTarget = null, this._scrollHeight = null;
          }, g._getConfig = function (n) {
            if ("string" != typeof (n = r({}, a, n)).target) {
              var i = t(n.target).attr("id");
              i || (i = P.getUID(e), t(n.target).attr("id", i)), n.target = "#" + i;
            }
            return P.typeCheckConfig(e, n, l), n;
          }, g._getScrollTop = function () {
            return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
          }, g._getScrollHeight = function () {
            return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
          }, g._getOffsetHeight = function () {
            return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
          }, g._process = function () {
            var t = this._getScrollTop() + this._config.offset,
              e = this._getScrollHeight(),
              n = this._config.offset + e - this._getOffsetHeight();
            if (this._scrollHeight !== e && this.refresh(), t >= n) {
              var i = this._targets[this._targets.length - 1];
              this._activeTarget !== i && this._activate(i);
            } else {
              if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, void this._clear();
              for (var s = this._offsets.length; s--;) {
                this._activeTarget !== this._targets[s] && t >= this._offsets[s] && ("undefined" == typeof this._offsets[s + 1] || t < this._offsets[s + 1]) && this._activate(this._targets[s]);
              }
            }
          }, g._activate = function (e) {
            this._activeTarget = e, this._clear();
            var n = this._selector.split(",");
            n = n.map(function (t) {
              return t + '[data-target="' + e + '"],' + t + '[href="' + e + '"]';
            });
            var i = t(n.join(","));
            i.hasClass(c) ? (i.closest(f.DROPDOWN).find(f.DROPDOWN_TOGGLE).addClass(u), i.addClass(u)) : (i.addClass(u), i.parents(f.NAV_LIST_GROUP).prev(f.NAV_LINKS + ", " + f.LIST_ITEMS).addClass(u), i.parents(f.NAV_LIST_GROUP).prev(f.NAV_ITEMS).children(f.NAV_LINKS).addClass(u)), t(this._scrollElement).trigger(h.ACTIVATE, {
              relatedTarget: e
            });
          }, g._clear = function () {
            t(this._selector).filter(f.ACTIVE).removeClass(u);
          }, o._jQueryInterface = function (e) {
            return this.each(function () {
              var i = t(this).data(n);
              if (i || (i = new o(this, "object" == _typeof(e) && e), t(this).data(n, i)), "string" == typeof e) {
                if ("undefined" == typeof i[e]) throw new TypeError('No method named "' + e + '"');
                i[e]();
              }
            });
          }, s(o, null, [{
            key: "VERSION",
            get: function get() {
              return "4.0.0";
            }
          }, {
            key: "Default",
            get: function get() {
              return a;
            }
          }]), o;
        }();
      return t(window).on(h.LOAD_DATA_API, function () {
        for (var e = t.makeArray(t(f.DATA_SPY)), n = e.length; n--;) {
          var i = t(e[n]);
          g._jQueryInterface.call(i, i.data());
        }
      }), t.fn[e] = g._jQueryInterface, t.fn[e].Constructor = g, t.fn[e].noConflict = function () {
        return t.fn[e] = o, g._jQueryInterface;
      }, g;
    }(e),
    V = function (t) {
      var e = "bs.tab",
        n = "." + e,
        i = t.fn.tab,
        r = {
          HIDE: "hide" + n,
          HIDDEN: "hidden" + n,
          SHOW: "show" + n,
          SHOWN: "shown" + n,
          CLICK_DATA_API: "click.bs.tab.data-api"
        },
        o = "dropdown-menu",
        a = "active",
        l = "disabled",
        h = "fade",
        c = "show",
        u = ".dropdown",
        f = ".nav, .list-group",
        d = ".active",
        _ = "> li > .active",
        g = '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',
        p = ".dropdown-toggle",
        m = "> .dropdown-menu .active",
        v = function () {
          function n(t) {
            this._element = t;
          }
          var i = n.prototype;
          return i.show = function () {
            var e = this;
            if (!(this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && t(this._element).hasClass(a) || t(this._element).hasClass(l))) {
              var n,
                i,
                s = t(this._element).closest(f)[0],
                o = P.getSelectorFromElement(this._element);
              if (s) {
                var h = "UL" === s.nodeName ? _ : d;
                i = (i = t.makeArray(t(s).find(h)))[i.length - 1];
              }
              var c = t.Event(r.HIDE, {
                  relatedTarget: this._element
                }),
                u = t.Event(r.SHOW, {
                  relatedTarget: i
                });
              if (i && t(i).trigger(c), t(this._element).trigger(u), !u.isDefaultPrevented() && !c.isDefaultPrevented()) {
                o && (n = t(o)[0]), this._activate(this._element, s);
                var g = function g() {
                  var n = t.Event(r.HIDDEN, {
                      relatedTarget: e._element
                    }),
                    s = t.Event(r.SHOWN, {
                      relatedTarget: i
                    });
                  t(i).trigger(n), t(e._element).trigger(s);
                };
                n ? this._activate(n, n.parentNode, g) : g();
              }
            }
          }, i.dispose = function () {
            t.removeData(this._element, e), this._element = null;
          }, i._activate = function (e, n, i) {
            var s = this,
              r = ("UL" === n.nodeName ? t(n).find(_) : t(n).children(d))[0],
              o = i && P.supportsTransitionEnd() && r && t(r).hasClass(h),
              a = function a() {
                return s._transitionComplete(e, r, i);
              };
            r && o ? t(r).one(P.TRANSITION_END, a).emulateTransitionEnd(150) : a();
          }, i._transitionComplete = function (e, n, i) {
            if (n) {
              t(n).removeClass(c + " " + a);
              var s = t(n.parentNode).find(m)[0];
              s && t(s).removeClass(a), "tab" === n.getAttribute("role") && n.setAttribute("aria-selected", !1);
            }
            if (t(e).addClass(a), "tab" === e.getAttribute("role") && e.setAttribute("aria-selected", !0), P.reflow(e), t(e).addClass(c), e.parentNode && t(e.parentNode).hasClass(o)) {
              var r = t(e).closest(u)[0];
              r && t(r).find(p).addClass(a), e.setAttribute("aria-expanded", !0);
            }
            i && i();
          }, n._jQueryInterface = function (i) {
            return this.each(function () {
              var s = t(this),
                r = s.data(e);
              if (r || (r = new n(this), s.data(e, r)), "string" == typeof i) {
                if ("undefined" == typeof r[i]) throw new TypeError('No method named "' + i + '"');
                r[i]();
              }
            });
          }, s(n, null, [{
            key: "VERSION",
            get: function get() {
              return "4.0.0";
            }
          }]), n;
        }();
      return t(document).on(r.CLICK_DATA_API, g, function (e) {
        e.preventDefault(), v._jQueryInterface.call(t(this), "show");
      }), t.fn.tab = v._jQueryInterface, t.fn.tab.Constructor = v, t.fn.tab.noConflict = function () {
        return t.fn.tab = i, v._jQueryInterface;
      }, v;
    }(e);
  !function (t) {
    if ("undefined" == typeof t) throw new TypeError("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript.");
    var e = t.fn.jquery.split(" ")[0].split(".");
    if (e[0] < 2 && e[1] < 9 || 1 === e[0] && 9 === e[1] && e[2] < 1 || e[0] >= 4) throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0");
  }(e), t.Util = P, t.Alert = L, t.Button = R, t.Carousel = j, t.Collapse = H, t.Dropdown = W, t.Modal = M, t.Popover = x, t.Scrollspy = K, t.Tab = V, t.Tooltip = U, Object.defineProperty(t, "__esModule", {
    value: !0
  });
});
;
!function (e) {
  e.fn.niceSelect = function (t) {
    function s(t) {
      t.after(e("<div></div>").addClass("nice-select").addClass(t.attr("class") || "").addClass(t.attr("disabled") ? "disabled" : "").attr("tabindex", t.attr("disabled") ? null : "0").html('<span class="current"></span><ul class="list"></ul>'));
      var s = t.next(),
        n = t.find("option"),
        i = t.find("option:selected");
      s.find(".current").html(i.data("display") || i.text()), n.each(function (t) {
        var n = e(this),
          i = n.data("display");
        s.find("ul").append(e("<li></li>").attr("data-value", n.val()).attr("data-display", i || null).addClass("option" + (n.is(":selected") ? " selected" : "") + (n.is(":disabled") ? " disabled" : "")).html(n.text()));
      });
    }
    if ("string" == typeof t) return "update" == t ? this.each(function () {
      var t = e(this),
        n = e(this).next(".nice-select"),
        i = n.hasClass("open");
      n.length && (n.remove(), s(t), i && t.next().trigger("click"));
    }) : "destroy" == t ? (this.each(function () {
      var t = e(this),
        s = e(this).next(".nice-select");
      s.length && (s.remove(), t.css("display", ""));
    }), 0 == e(".nice-select").length && e(document).off(".nice_select")) : console.log('Method "' + t + '" does not exist.'), this;
    this.hide(), this.each(function () {
      var t = e(this);
      t.next().hasClass("nice-select") || s(t);
    }), e(document).off(".nice_select"), e(document).on("click.nice_select", ".nice-select", function (t) {
      var s = e(this);
      e(".nice-select").not(s).removeClass("open"), s.toggleClass("open"), s.hasClass("open") ? (s.find(".option"), s.find(".focus").removeClass("focus"), s.find(".selected").addClass("focus")) : s.focus();
    }), e(document).on("click.nice_select", function (t) {
      0 === e(t.target).closest(".nice-select").length && e(".nice-select").removeClass("open").find(".option");
    }), e(document).on("click.nice_select", ".nice-select .option:not(.disabled)", function (t) {
      var s = e(this),
        n = s.closest(".nice-select");
      n.find(".selected").removeClass("selected"), s.addClass("selected");
      var i = s.data("display") || s.text();
      n.find(".current").text(i), n.prev("select").val(s.data("value")).trigger("change");
    }), e(document).on("keydown.nice_select", ".nice-select", function (t) {
      var s = e(this),
        n = e(s.find(".focus") || s.find(".list .option.selected"));
      if (32 == t.keyCode || 13 == t.keyCode) return s.hasClass("open") ? n.trigger("click") : s.trigger("click"), !1;
      if (40 == t.keyCode) {
        if (s.hasClass("open")) {
          var i = n.nextAll(".option:not(.disabled)").first();
          i.length > 0 && (s.find(".focus").removeClass("focus"), i.addClass("focus"));
        } else s.trigger("click");
        return !1;
      }
      if (38 == t.keyCode) {
        if (s.hasClass("open")) {
          var l = n.prevAll(".option:not(.disabled)").first();
          l.length > 0 && (s.find(".focus").removeClass("focus"), l.addClass("focus"));
        } else s.trigger("click");
        return !1;
      }
      if (27 == t.keyCode) s.hasClass("open") && s.trigger("click");else if (9 == t.keyCode && s.hasClass("open")) return !1;
    });
    var n = document.createElement("a").style;
    return n.cssText = "pointer-events:auto", "auto" !== n.pointerEvents && e("html").addClass("no-csspointerevents"), this;
  };
}(jQuery);
;
(function (factory) {
  // eslint-disable-line no-extra-semi
  'use strict';

  if (typeof define === 'function' && define.amd) {
    define(['jquery'], factory);
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = factory(require('jquery'));
  } else {
    factory(jQuery);
  }
})(function ($) {
  /*
  *  internal
  */
  var _previousResizeWidth = -1,
    _updateTimeout = -1;
  /*
  *  _parse
  *  value parse utility function
  */
  var _parse = function _parse(value) {
    return parseFloat(value) || 0;
  };
  /*
  *  _rows
  *  utility function returns array of jQuery selections representing each row
  *  (as displayed after float wrapping applied by browser)
  */
  var _rows = function _rows(elements) {
    var tolerance = 1,
      $elements = $(elements),
      lastTop = null,
      rows = [];
    $elements.each(function () {
      var $that = $(this),
        top = $that.offset().top - _parse($that.css('margin-top')),
        lastRow = rows.length > 0 ? rows[rows.length - 1] : null;
      if (lastRow === null) {
        rows.push($that);
      } else {
        if (Math.floor(Math.abs(lastTop - top)) <= tolerance) {
          rows[rows.length - 1] = lastRow.add($that);
        } else {
          rows.push($that);
        }
      }
      lastTop = top;
    });
    return rows;
  };
  /*
  *  _parseOptions
  *  handle plugin options
  */
  var _parseOptions = function _parseOptions(options) {
    var opts = {
      byRow: true,
      property: 'height',
      target: null,
      remove: false
    };
    if (_typeof(options) === 'object') {
      return $.extend(opts, options);
    }
    if (typeof options === 'boolean') {
      opts.byRow = options;
    } else if (options === 'remove') {
      opts.remove = true;
    }
    return opts;
  };
  /*
  *  matchHeight
  *  plugin definition
  */
  var matchHeight = $.fn.matchHeight = function (options) {
    var opts = _parseOptions(options);
    if (opts.remove) {
      var that = this;
      this.css(opts.property, '');
      $.each(matchHeight._groups, function (key, group) {
        group.elements = group.elements.not(that);
      });
      return this;
    }
    if (this.length <= 1 && !opts.target) {
      return this;
    }
    matchHeight._groups.push({
      elements: this,
      options: opts
    });
    matchHeight._apply(this, opts);
    return this;
  };
  /*
  *  plugin global options
  */
  matchHeight.version = 'master';
  matchHeight._groups = [];
  matchHeight._throttle = 80;
  matchHeight._maintainScroll = false;
  matchHeight._beforeUpdate = null;
  matchHeight._afterUpdate = null;
  matchHeight._rows = _rows;
  matchHeight._parse = _parse;
  matchHeight._parseOptions = _parseOptions;
  /*
  *  matchHeight._apply
  *  apply matchHeight to given elements
  */
  matchHeight._apply = function (elements, options) {
    var opts = _parseOptions(options),
      $elements = $(elements),
      rows = [$elements];
    var scrollTop = $(window).scrollTop(),
      htmlHeight = $('html').outerHeight(true);
    var $hiddenParents = $elements.parents().filter(':hidden');
    $hiddenParents.each(function () {
      var $that = $(this);
      $that.data('style-cache', $that.attr('style'));
    });
    $hiddenParents.css('display', 'block');
    if (opts.byRow && !opts.target) {
      $elements.each(function () {
        var $that = $(this),
          display = $that.css('display');
        if (display !== 'inline-block' && display !== 'flex' && display !== 'inline-flex') {
          display = 'block';
        }
        $that.data('style-cache', $that.attr('style'));
        $that.css({
          'display': display,
          'padding-top': '0',
          'padding-bottom': '0',
          'margin-top': '0',
          'margin-bottom': '0',
          'border-top-width': '0',
          'border-bottom-width': '0',
          'height': '100px',
          'overflow': 'hidden'
        });
      });
      rows = _rows($elements);
      $elements.each(function () {
        var $that = $(this);
        $that.attr('style', $that.data('style-cache') || '');
      });
    }
    $.each(rows, function (key, row) {
      var $row = $(row),
        targetHeight = 0;
      if (!opts.target) {
        if (opts.byRow && $row.length <= 1) {
          $row.css(opts.property, '');
          return;
        }
        $row.each(function () {
          var $that = $(this),
            style = $that.attr('style'),
            display = $that.css('display');
          if (display !== 'inline-block' && display !== 'flex' && display !== 'inline-flex') {
            display = 'block';
          }
          var css = {
            'display': display
          };
          css[opts.property] = '';
          $that.css(css);
          if ($that.outerHeight(false) > targetHeight) {
            targetHeight = $that.outerHeight(false);
          }
          if (style) {
            $that.attr('style', style);
          } else {
            $that.css('display', '');
          }
        });
      } else {
        targetHeight = opts.target.outerHeight(false);
      }
      $row.each(function () {
        var $that = $(this),
          verticalPadding = 0;
        if (opts.target && $that.is(opts.target)) {
          return;
        }
        if ($that.css('box-sizing') !== 'border-box') {
          verticalPadding += _parse($that.css('border-top-width')) + _parse($that.css('border-bottom-width'));
          verticalPadding += _parse($that.css('padding-top')) + _parse($that.css('padding-bottom'));
        }
        $that.css(opts.property, targetHeight - verticalPadding + 'px');
      });
    });
    $hiddenParents.each(function () {
      var $that = $(this);
      $that.attr('style', $that.data('style-cache') || null);
    });
    if (matchHeight._maintainScroll) {
      $(window).scrollTop(scrollTop / htmlHeight * $('html').outerHeight(true));
    }
    return this;
  };
  /*
  *  matchHeight._applyDataApi
  *  applies matchHeight to all elements with a data-match-height attribute
  */
  matchHeight._applyDataApi = function () {
    var groups = {};
    $('[data-match-height], [data-mh]').each(function () {
      var $this = $(this),
        groupId = $this.attr('data-mh') || $this.attr('data-match-height');
      if (groupId in groups) {
        groups[groupId] = groups[groupId].add($this);
      } else {
        groups[groupId] = $this;
      }
    });
    $.each(groups, function () {
      this.matchHeight(true);
    });
  };
  /*
  *  matchHeight._update
  *  updates matchHeight on all current groups with their correct options
  */
  var _update = function _update(event) {
    if (matchHeight._beforeUpdate) {
      matchHeight._beforeUpdate(event, matchHeight._groups);
    }
    $.each(matchHeight._groups, function () {
      matchHeight._apply(this.elements, this.options);
    });
    if (matchHeight._afterUpdate) {
      matchHeight._afterUpdate(event, matchHeight._groups);
    }
  };
  matchHeight._update = function (throttle, event) {
    if (event && event.type === 'resize') {
      var windowWidth = $(window).width();
      if (windowWidth === _previousResizeWidth) {
        return;
      }
      _previousResizeWidth = windowWidth;
    }
    if (!throttle) {
      _update(event);
    } else if (_updateTimeout === -1) {
      _updateTimeout = setTimeout(function () {
        _update(event);
        _updateTimeout = -1;
      }, matchHeight._throttle);
    }
  };
  /*
  *  bind events
  */
  $(matchHeight._applyDataApi);
  var on = $.fn.on ? 'on' : 'bind';
  $(window)[on]('load', function (event) {
    matchHeight._update(false, event);
  });
  $(window)[on]('resize orientationchange', function (event) {
    matchHeight._update(true, event);
  });
});
/*! Magnific Popup - v1.0.0 - 2015-01-03
* //dimsemenov.com/plugins/magnific-popup/
* Copyright (c) 2015 Dmitry Semenov; */
;
(function (factory) {
  if (typeof define === 'function' && define.amd) {
    define(['jquery'], factory);
  } else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object') {
    factory(require('jquery'));
  } else {
    factory(window.jQuery || window.Zepto);
  }
})(function ($) {
  /*>>core*/
  /**
   * 
   * Magnific Popup Core JS file
   * 
   */
  /**
   * Private static constants
   */
  var CLOSE_EVENT = 'Close',
    BEFORE_CLOSE_EVENT = 'BeforeClose',
    AFTER_CLOSE_EVENT = 'AfterClose',
    BEFORE_APPEND_EVENT = 'BeforeAppend',
    MARKUP_PARSE_EVENT = 'MarkupParse',
    OPEN_EVENT = 'Open',
    CHANGE_EVENT = 'Change',
    NS = 'mfp',
    EVENT_NS = '.' + NS,
    READY_CLASS = 'mfp-ready',
    REMOVING_CLASS = 'mfp-removing',
    PREVENT_CLOSE_CLASS = 'mfp-prevent-close';
  /**
   * Private vars 
   */
  /*jshint -W079 */
  var mfp,
    // As we have only one instance of MagnificPopup object, we define it locally to not to use 'this'
    MagnificPopup = function MagnificPopup() {},
    _isJQ = !!window.jQuery,
    _prevStatus,
    _window = $(window),
    _document,
    _prevContentType,
    _wrapClasses,
    _currPopupType;
  /**
   * Private functions
   */
  var _mfpOn = function _mfpOn(name, f) {
      mfp.ev.on(NS + name + EVENT_NS, f);
    },
    _getEl = function _getEl(className, appendTo, html, raw) {
      var el = document.createElement('div');
      el.className = 'mfp-' + className;
      if (html) {
        el.innerHTML = html;
      }
      if (!raw) {
        el = $(el);
        if (appendTo) {
          el.appendTo(appendTo);
        }
      } else if (appendTo) {
        appendTo.appendChild(el);
      }
      return el;
    },
    _mfpTrigger = function _mfpTrigger(e, data) {
      mfp.ev.triggerHandler(NS + e, data);
      if (mfp.st.callbacks) {
        e = e.charAt(0).toLowerCase() + e.slice(1);
        if (mfp.st.callbacks[e]) {
          mfp.st.callbacks[e].apply(mfp, $.isArray(data) ? data : [data]);
        }
      }
    },
    _getCloseBtn = function _getCloseBtn(type) {
      if (type !== _currPopupType || !mfp.currTemplate.closeBtn) {
        mfp.currTemplate.closeBtn = $(mfp.st.closeMarkup.replace('%title%', mfp.st.tClose));
        _currPopupType = type;
      }
      return mfp.currTemplate.closeBtn;
    },
    _checkInstance = function _checkInstance() {
      if (!$.magnificPopup.instance) {
        /*jshint -W020 */
        mfp = new MagnificPopup();
        mfp.init();
        $.magnificPopup.instance = mfp;
      }
    },
    supportsTransitions = function supportsTransitions() {
      var s = document.createElement('p').style,
        // 's' for style. better to create an element if body yet to exist
        v = ['ms', 'O', 'Moz', 'Webkit']; // 'v' for vendor
      if (s['transition'] !== undefined) {
        return true;
      }
      while (v.length) {
        if (v.pop() + 'Transition' in s) {
          return true;
        }
      }
      return false;
    };
  /**
   * Public functions
   */
  MagnificPopup.prototype = {
    constructor: MagnificPopup,
    /**
     * Initializes Magnific Popup plugin. 
     * This function is triggered only once when $.fn.magnificPopup or $.magnificPopup is executed
     */
    init: function init() {
      var appVersion = navigator.appVersion;
      mfp.isIE7 = appVersion.indexOf("MSIE 7.") !== -1;
      mfp.isIE8 = appVersion.indexOf("MSIE 8.") !== -1;
      mfp.isLowIE = mfp.isIE7 || mfp.isIE8;
      mfp.isAndroid = /android/gi.test(appVersion);
      mfp.isIOS = /iphone|ipad|ipod/gi.test(appVersion);
      mfp.supportsTransition = supportsTransitions();
      mfp.probablyMobile = mfp.isAndroid || mfp.isIOS || /(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent);
      _document = $(document);
      mfp.popupsCache = {};
    },
    /**
     * Opens popup
     * @param  data [description]
     */
    open: function open(data) {
      var i;
      if (data.isObj === false) {
        mfp.items = data.items.toArray();
        mfp.index = 0;
        var items = data.items,
          item;
        for (i = 0; i < items.length; i++) {
          item = items[i];
          if (item.parsed) {
            item = item.el[0];
          }
          if (item === data.el[0]) {
            mfp.index = i;
            break;
          }
        }
      } else {
        mfp.items = $.isArray(data.items) ? data.items : [data.items];
        mfp.index = data.index || 0;
      }
      if (mfp.isOpen) {
        mfp.updateItemHTML();
        return;
      }
      mfp.types = [];
      _wrapClasses = '';
      if (data.mainEl && data.mainEl.length) {
        mfp.ev = data.mainEl.eq(0);
      } else {
        mfp.ev = _document;
      }
      if (data.key) {
        if (!mfp.popupsCache[data.key]) {
          mfp.popupsCache[data.key] = {};
        }
        mfp.currTemplate = mfp.popupsCache[data.key];
      } else {
        mfp.currTemplate = {};
      }
      mfp.st = $.extend(true, {}, $.magnificPopup.defaults, data);
      mfp.fixedContentPos = mfp.st.fixedContentPos === 'auto' ? !mfp.probablyMobile : mfp.st.fixedContentPos;
      if (mfp.st.modal) {
        mfp.st.closeOnContentClick = false;
        mfp.st.closeOnBgClick = false;
        mfp.st.showCloseBtn = false;
        mfp.st.enableEscapeKey = false;
      }
      if (!mfp.bgOverlay) {
        mfp.bgOverlay = _getEl('bg').on('click' + EVENT_NS, function () {
          mfp.close();
        });
        mfp.wrap = _getEl('wrap').attr('tabindex', -1).on('click' + EVENT_NS, function (e) {
          if (mfp._checkIfClose(e.target)) {
            mfp.close();
          }
        });
        mfp.container = _getEl('container', mfp.wrap);
      }
      mfp.contentContainer = _getEl('content');
      if (mfp.st.preloader) {
        mfp.preloader = _getEl('preloader', mfp.container, mfp.st.tLoading);
      }
      var modules = $.magnificPopup.modules;
      for (i = 0; i < modules.length; i++) {
        var n = modules[i];
        n = n.charAt(0).toUpperCase() + n.slice(1);
        mfp['init' + n].call(mfp);
      }
      _mfpTrigger('BeforeOpen');
      if (mfp.st.showCloseBtn) {
        if (!mfp.st.closeBtnInside) {
          mfp.wrap.append(_getCloseBtn());
        } else {
          _mfpOn(MARKUP_PARSE_EVENT, function (e, template, values, item) {
            values.close_replaceWith = _getCloseBtn(item.type);
          });
          _wrapClasses += ' mfp-close-btn-in';
        }
      }
      if (mfp.st.alignTop) {
        _wrapClasses += ' mfp-align-top';
      }
      if (mfp.fixedContentPos) {
        mfp.wrap.css({
          overflow: mfp.st.overflowY,
          overflowX: 'hidden',
          overflowY: mfp.st.overflowY
        });
      } else {
        mfp.wrap.css({
          top: _window.scrollTop(),
          position: 'absolute'
        });
      }
      if (mfp.st.fixedBgPos === false || mfp.st.fixedBgPos === 'auto' && !mfp.fixedContentPos) {
        mfp.bgOverlay.css({
          height: _document.height(),
          position: 'absolute'
        });
      }
      if (mfp.st.enableEscapeKey) {
        _document.on('keyup' + EVENT_NS, function (e) {
          if (e.keyCode === 27) {
            mfp.close();
          }
        });
      }
      _window.on('resize' + EVENT_NS, function () {
        mfp.updateSize();
      });
      if (!mfp.st.closeOnContentClick) {
        _wrapClasses += ' mfp-auto-cursor';
      }
      if (_wrapClasses) mfp.wrap.addClass(_wrapClasses);
      var windowHeight = mfp.wH = _window.height();
      var windowStyles = {};
      if (mfp.fixedContentPos) {
        if (mfp._hasScrollBar(windowHeight)) {
          var s = mfp._getScrollbarSize();
          if (s) {
            windowStyles.marginRight = s;
          }
        }
      }
      if (mfp.fixedContentPos) {
        if (!mfp.isIE7) {
          windowStyles.overflow = 'hidden';
        } else {
          $('body, html').css('overflow', 'hidden');
        }
      }
      var classesToadd = mfp.st.mainClass;
      if (mfp.isIE7) {
        classesToadd += ' mfp-ie7';
      }
      if (classesToadd) {
        mfp._addClassToMFP(classesToadd);
      }
      mfp.updateItemHTML();
      _mfpTrigger('BuildControls');
      $('html').css(windowStyles);
      mfp.bgOverlay.add(mfp.wrap).prependTo(mfp.st.prependTo || $(document.body));
      mfp._lastFocusedEl = document.activeElement;
      setTimeout(function () {
        if (mfp.content) {
          mfp._addClassToMFP(READY_CLASS);
          mfp._setFocus();
        } else {
          mfp.bgOverlay.addClass(READY_CLASS);
        }
        _document.on('focusin' + EVENT_NS, mfp._onFocusIn);
      }, 16);
      mfp.isOpen = true;
      mfp.updateSize(windowHeight);
      _mfpTrigger(OPEN_EVENT);
      return data;
    },
    /**
     * Closes the popup
     */
    close: function close() {
      if (!mfp.isOpen) return;
      _mfpTrigger(BEFORE_CLOSE_EVENT);
      mfp.isOpen = false;
      if (mfp.st.removalDelay && !mfp.isLowIE && mfp.supportsTransition) {
        mfp._addClassToMFP(REMOVING_CLASS);
        setTimeout(function () {
          mfp._close();
        }, mfp.st.removalDelay);
      } else {
        mfp._close();
      }
    },
    /**
     * Helper for close() function
     */
    _close: function _close() {
      _mfpTrigger(CLOSE_EVENT);
      var classesToRemove = REMOVING_CLASS + ' ' + READY_CLASS + ' ';
      mfp.bgOverlay.detach();
      mfp.wrap.detach();
      mfp.container.empty();
      if (mfp.st.mainClass) {
        classesToRemove += mfp.st.mainClass + ' ';
      }
      mfp._removeClassFromMFP(classesToRemove);
      if (mfp.fixedContentPos) {
        var windowStyles = {
          marginRight: ''
        };
        if (mfp.isIE7) {
          $('body, html').css('overflow', '');
        } else {
          windowStyles.overflow = '';
        }
        $('html').css(windowStyles);
      }
      _document.off('keyup' + EVENT_NS + ' focusin' + EVENT_NS);
      mfp.ev.off(EVENT_NS);
      mfp.wrap.attr('class', 'mfp-wrap').removeAttr('style');
      mfp.bgOverlay.attr('class', 'mfp-bg');
      mfp.container.attr('class', 'mfp-container');
      if (mfp.st.showCloseBtn && (!mfp.st.closeBtnInside || mfp.currTemplate[mfp.currItem.type] === true)) {
        if (mfp.currTemplate.closeBtn) mfp.currTemplate.closeBtn.detach();
      }
      if (mfp._lastFocusedEl) {
        $(mfp._lastFocusedEl).focus(); // put tab focus back
      }

      mfp.currItem = null;
      mfp.content = null;
      mfp.currTemplate = null;
      mfp.prevHeight = 0;
      _mfpTrigger(AFTER_CLOSE_EVENT);
    },
    updateSize: function updateSize(winHeight) {
      if (mfp.isIOS) {
        var zoomLevel = document.documentElement.clientWidth / window.innerWidth;
        var height = window.innerHeight * zoomLevel;
        mfp.wrap.css('height', height);
        mfp.wH = height;
      } else {
        mfp.wH = winHeight || _window.height();
      }
      if (!mfp.fixedContentPos) {
        mfp.wrap.css('height', mfp.wH);
      }
      _mfpTrigger('Resize');
    },
    /**
     * Set content of popup based on current index
     */
    updateItemHTML: function updateItemHTML() {
      var item = mfp.items[mfp.index];
      mfp.contentContainer.detach();
      if (mfp.content) mfp.content.detach();
      if (!item.parsed) {
        item = mfp.parseEl(mfp.index);
      }
      var type = item.type;
      _mfpTrigger('BeforeChange', [mfp.currItem ? mfp.currItem.type : '', type]);
      mfp.currItem = item;
      if (!mfp.currTemplate[type]) {
        var markup = mfp.st[type] ? mfp.st[type].markup : false;
        _mfpTrigger('FirstMarkupParse', markup);
        if (markup) {
          mfp.currTemplate[type] = $(markup);
        } else {
          mfp.currTemplate[type] = true;
        }
      }
      if (_prevContentType && _prevContentType !== item.type) {
        mfp.container.removeClass('mfp-' + _prevContentType + '-holder');
      }
      var newContent = mfp['get' + type.charAt(0).toUpperCase() + type.slice(1)](item, mfp.currTemplate[type]);
      mfp.appendContent(newContent, type);
      item.preloaded = true;
      _mfpTrigger(CHANGE_EVENT, item);
      _prevContentType = item.type;
      mfp.container.prepend(mfp.contentContainer);
      _mfpTrigger('AfterChange');
    },
    /**
     * Set HTML content of popup
     */
    appendContent: function appendContent(newContent, type) {
      mfp.content = newContent;
      if (newContent) {
        if (mfp.st.showCloseBtn && mfp.st.closeBtnInside && mfp.currTemplate[type] === true) {
          if (!mfp.content.find('.mfp-close').length) {
            mfp.content.append(_getCloseBtn());
          }
        } else {
          mfp.content = newContent;
        }
      } else {
        mfp.content = '';
      }
      _mfpTrigger(BEFORE_APPEND_EVENT);
      mfp.container.addClass('mfp-' + type + '-holder');
      mfp.contentContainer.append(mfp.content);
    },
    /**
     * Creates Magnific Popup data object based on given data
     * @param  {int} index Index of item to parse
     */
    parseEl: function parseEl(index) {
      var item = mfp.items[index],
        type;
      if (item.tagName) {
        item = {
          el: $(item)
        };
      } else {
        type = item.type;
        item = {
          data: item,
          src: item.src
        };
      }
      if (item.el) {
        var types = mfp.types;
        for (var i = 0; i < types.length; i++) {
          if (item.el.hasClass('mfp-' + types[i])) {
            type = types[i];
            break;
          }
        }
        item.src = item.el.attr('data-mfp-src');
        if (!item.src) {
          item.src = item.el.attr('href');
        }
      }
      item.type = type || mfp.st.type || 'inline';
      item.index = index;
      item.parsed = true;
      mfp.items[index] = item;
      _mfpTrigger('ElementParse', item);
      return mfp.items[index];
    },
    /**
     * Initializes single popup or a group of popups
     */
    addGroup: function addGroup(el, options) {
      var eHandler = function eHandler(e) {
        e.mfpEl = this;
        mfp._openClick(e, el, options);
      };
      if (!options) {
        options = {};
      }
      var eName = 'click.magnificPopup';
      options.mainEl = el;
      if (options.items) {
        options.isObj = true;
        el.off(eName).on(eName, eHandler);
      } else {
        options.isObj = false;
        if (options.delegate) {
          el.off(eName).on(eName, options.delegate, eHandler);
        } else {
          options.items = el;
          el.off(eName).on(eName, eHandler);
        }
      }
    },
    _openClick: function _openClick(e, el, options) {
      var midClick = options.midClick !== undefined ? options.midClick : $.magnificPopup.defaults.midClick;
      if (!midClick && (e.which === 2 || e.ctrlKey || e.metaKey)) {
        return;
      }
      var disableOn = options.disableOn !== undefined ? options.disableOn : $.magnificPopup.defaults.disableOn;
      if (disableOn) {
        if ($.isFunction(disableOn)) {
          if (!disableOn.call(mfp)) {
            return true;
          }
        } else {
          // else it's number
          if (_window.width() < disableOn) {
            return true;
          }
        }
      }
      if (e.type) {
        e.preventDefault();
        if (mfp.isOpen) {
          e.stopPropagation();
        }
      }
      options.el = $(e.mfpEl);
      if (options.delegate) {
        options.items = el.find(options.delegate);
      }
      mfp.open(options);
    },
    /**
     * Updates text on preloader
     */
    updateStatus: function updateStatus(status, text) {
      if (mfp.preloader) {
        if (_prevStatus !== status) {
          mfp.container.removeClass('mfp-s-' + _prevStatus);
        }
        if (!text && status === 'loading') {
          text = mfp.st.tLoading;
        }
        var data = {
          status: status,
          text: text
        };
        _mfpTrigger('UpdateStatus', data);
        status = data.status;
        text = data.text;
        mfp.preloader.html(text);
        mfp.preloader.find('a').on('click', function (e) {
          e.stopImmediatePropagation();
        });
        mfp.container.addClass('mfp-s-' + status);
        _prevStatus = status;
      }
    },
    /*
    	"Private" helpers that aren't private at all
     */
    _checkIfClose: function _checkIfClose(target) {
      if ($(target).hasClass(PREVENT_CLOSE_CLASS)) {
        return;
      }
      var closeOnContent = mfp.st.closeOnContentClick;
      var closeOnBg = mfp.st.closeOnBgClick;
      if (closeOnContent && closeOnBg) {
        return true;
      } else {
        if (!mfp.content || $(target).hasClass('mfp-close') || mfp.preloader && target === mfp.preloader[0]) {
          return true;
        }
        if (target !== mfp.content[0] && !$.contains(mfp.content[0], target)) {
          if (closeOnBg) {
            if ($.contains(document, target)) {
              return true;
            }
          }
        } else if (closeOnContent) {
          return true;
        }
      }
      return false;
    },
    _addClassToMFP: function _addClassToMFP(cName) {
      mfp.bgOverlay.addClass(cName);
      mfp.wrap.addClass(cName);
    },
    _removeClassFromMFP: function _removeClassFromMFP(cName) {
      this.bgOverlay.removeClass(cName);
      mfp.wrap.removeClass(cName);
    },
    _hasScrollBar: function _hasScrollBar(winHeight) {
      return (mfp.isIE7 ? _document.height() : document.body.scrollHeight) > (winHeight || _window.height());
    },
    _setFocus: function _setFocus() {
      (mfp.st.focus ? mfp.content.find(mfp.st.focus).eq(0) : mfp.wrap).focus();
    },
    _onFocusIn: function _onFocusIn(e) {
      if (e.target !== mfp.wrap[0] && !$.contains(mfp.wrap[0], e.target)) {
        mfp._setFocus();
        return false;
      }
    },
    _parseMarkup: function _parseMarkup(template, values, item) {
      var arr;
      if (item.data) {
        values = $.extend(item.data, values);
      }
      _mfpTrigger(MARKUP_PARSE_EVENT, [template, values, item]);
      $.each(values, function (key, value) {
        if (value === undefined || value === false) {
          return true;
        }
        arr = key.split('_');
        if (arr.length > 1) {
          var el = template.find(EVENT_NS + '-' + arr[0]);
          if (el.length > 0) {
            var attr = arr[1];
            if (attr === 'replaceWith') {
              if (el[0] !== value[0]) {
                el.replaceWith(value);
              }
            } else if (attr === 'img') {
              if (el.is('img')) {
                el.attr('src', value);
              } else {
                el.replaceWith('<img src="' + value + '" class="' + el.attr('class') + '" />');
              }
            } else {
              el.attr(arr[1], value);
            }
          }
        } else {
          template.find(EVENT_NS + '-' + key).html(value);
        }
      });
    },
    _getScrollbarSize: function _getScrollbarSize() {
      if (mfp.scrollbarSize === undefined) {
        var scrollDiv = document.createElement("div");
        scrollDiv.style.cssText = 'width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;';
        document.body.appendChild(scrollDiv);
        mfp.scrollbarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
      }
      return mfp.scrollbarSize;
    }
  }; /* MagnificPopup core prototype end */
  /**
   * Public static functions
   */
  $.magnificPopup = {
    instance: null,
    proto: MagnificPopup.prototype,
    modules: [],
    open: function open(options, index) {
      _checkInstance();
      if (!options) {
        options = {};
      } else {
        options = $.extend(true, {}, options);
      }
      options.isObj = true;
      options.index = index || 0;
      return this.instance.open(options);
    },
    close: function close() {
      return $.magnificPopup.instance && $.magnificPopup.instance.close();
    },
    registerModule: function registerModule(name, module) {
      if (module.options) {
        $.magnificPopup.defaults[name] = module.options;
      }
      $.extend(this.proto, module.proto);
      this.modules.push(name);
    },
    defaults: {
      disableOn: 0,
      key: null,
      midClick: false,
      mainClass: '',
      preloader: true,
      focus: '',
      // CSS selector of input to focus after popup is opened
      closeOnContentClick: false,
      closeOnBgClick: true,
      closeBtnInside: true,
      showCloseBtn: true,
      enableEscapeKey: true,
      modal: false,
      alignTop: false,
      removalDelay: 0,
      prependTo: null,
      fixedContentPos: 'auto',
      fixedBgPos: 'auto',
      overflowY: 'auto',
      closeMarkup: '<button title="%title%" type="button" class="mfp-close">&times;</button>',
      tClose: 'Close (Esc)',
      tLoading: 'Loading...'
    }
  };
  $.fn.magnificPopup = function (options) {
    _checkInstance();
    var jqEl = $(this);
    if (typeof options === "string") {
      if (options === 'open') {
        var items,
          itemOpts = _isJQ ? jqEl.data('magnificPopup') : jqEl[0].magnificPopup,
          index = parseInt(arguments[1], 10) || 0;
        if (itemOpts.items) {
          items = itemOpts.items[index];
        } else {
          items = jqEl;
          if (itemOpts.delegate) {
            items = items.find(itemOpts.delegate);
          }
          items = items.eq(index);
        }
        mfp._openClick({
          mfpEl: items
        }, jqEl, itemOpts);
      } else {
        if (mfp.isOpen) mfp[options].apply(mfp, Array.prototype.slice.call(arguments, 1));
      }
    } else {
      options = $.extend(true, {}, options);
      /*
       * As Zepto doesn't support .data() method for objects 
       * and it works only in normal browsers
       * we assign "options" object directly to the DOM element. FTW!
       */
      if (_isJQ) {
        jqEl.data('magnificPopup', options);
      } else {
        jqEl[0].magnificPopup = options;
      }
      mfp.addGroup(jqEl, options);
    }
    return jqEl;
  };
  /*>>core*/
  /*>>inline*/
  var INLINE_NS = 'inline',
    _hiddenClass,
    _inlinePlaceholder,
    _lastInlineElement,
    _putInlineElementsBack = function _putInlineElementsBack() {
      if (_lastInlineElement) {
        _inlinePlaceholder.after(_lastInlineElement.addClass(_hiddenClass)).detach();
        _lastInlineElement = null;
      }
    };
  $.magnificPopup.registerModule(INLINE_NS, {
    options: {
      hiddenClass: 'hide',
      // will be appended with `mfp-` prefix
      markup: '',
      tNotFound: 'Content not found'
    },
    proto: {
      initInline: function initInline() {
        mfp.types.push(INLINE_NS);
        _mfpOn(CLOSE_EVENT + '.' + INLINE_NS, function () {
          _putInlineElementsBack();
        });
      },
      getInline: function getInline(item, template) {
        _putInlineElementsBack();
        if (item.src) {
          var inlineSt = mfp.st.inline,
            el = $(item.src);
          if (el.length) {
            var parent = el[0].parentNode;
            if (parent && parent.tagName) {
              if (!_inlinePlaceholder) {
                _hiddenClass = inlineSt.hiddenClass;
                _inlinePlaceholder = _getEl(_hiddenClass);
                _hiddenClass = 'mfp-' + _hiddenClass;
              }
              _lastInlineElement = el.after(_inlinePlaceholder).detach().removeClass(_hiddenClass);
            }
            mfp.updateStatus('ready');
          } else {
            mfp.updateStatus('error', inlineSt.tNotFound);
            el = $('<div>');
          }
          item.inlineElement = el;
          return el;
        }
        mfp.updateStatus('ready');
        mfp._parseMarkup(template, {}, item);
        return template;
      }
    }
  });
  /*>>inline*/
  /*>>ajax*/
  var AJAX_NS = 'ajax',
    _ajaxCur,
    _removeAjaxCursor = function _removeAjaxCursor() {
      if (_ajaxCur) {
        $(document.body).removeClass(_ajaxCur);
      }
    },
    _destroyAjaxRequest = function _destroyAjaxRequest() {
      _removeAjaxCursor();
      if (mfp.req) {
        mfp.req.abort();
      }
    };
  $.magnificPopup.registerModule(AJAX_NS, {
    options: {
      settings: null,
      cursor: 'mfp-ajax-cur',
      tError: '<a href="%url%">The content</a> could not be loaded.'
    },
    proto: {
      initAjax: function initAjax() {
        mfp.types.push(AJAX_NS);
        _ajaxCur = mfp.st.ajax.cursor;
        _mfpOn(CLOSE_EVENT + '.' + AJAX_NS, _destroyAjaxRequest);
        _mfpOn('BeforeChange.' + AJAX_NS, _destroyAjaxRequest);
      },
      getAjax: function getAjax(item) {
        if (_ajaxCur) {
          $(document.body).addClass(_ajaxCur);
        }
        mfp.updateStatus('loading');
        var opts = $.extend({
          url: item.src,
          success: function success(data, textStatus, jqXHR) {
            var temp = {
              data: data,
              xhr: jqXHR
            };
            _mfpTrigger('ParseAjax', temp);
            mfp.appendContent($(temp.data), AJAX_NS);
            item.finished = true;
            _removeAjaxCursor();
            mfp._setFocus();
            setTimeout(function () {
              mfp.wrap.addClass(READY_CLASS);
            }, 16);
            mfp.updateStatus('ready');
            _mfpTrigger('AjaxContentAdded');
          },
          error: function error() {
            _removeAjaxCursor();
            item.finished = item.loadError = true;
            mfp.updateStatus('error', mfp.st.ajax.tError.replace('%url%', item.src));
          }
        }, mfp.st.ajax.settings);
        mfp.req = $.ajax(opts);
        return '';
      }
    }
  });
  /*>>ajax*/
  /*>>image*/
  var _imgInterval,
    _getTitle = function _getTitle(item) {
      if (item.data && item.data.title !== undefined) return item.data.title;
      var src = mfp.st.image.titleSrc;
      if (src) {
        if ($.isFunction(src)) {
          return src.call(mfp, item);
        } else if (item.el) {
          return item.el.attr(src) || '';
        }
      }
      return '';
    };
  $.magnificPopup.registerModule('image', {
    options: {
      markup: '<div class="mfp-figure">' + '<div class="mfp-close"></div>' + '<figure>' + '<div class="mfp-img"></div>' + '<figcaption>' + '<div class="mfp-bottom-bar">' + '<div class="mfp-title"></div>' + '<div class="mfp-counter"></div>' + '</div>' + '</figcaption>' + '</figure>' + '</div>',
      cursor: 'mfp-zoom-out-cur',
      titleSrc: 'title',
      verticalFit: true,
      tError: '<a href="%url%">The image</a> could not be loaded.'
    },
    proto: {
      initImage: function initImage() {
        var imgSt = mfp.st.image,
          ns = '.image';
        mfp.types.push('image');
        _mfpOn(OPEN_EVENT + ns, function () {
          if (mfp.currItem.type === 'image' && imgSt.cursor) {
            $(document.body).addClass(imgSt.cursor);
          }
        });
        _mfpOn(CLOSE_EVENT + ns, function () {
          if (imgSt.cursor) {
            $(document.body).removeClass(imgSt.cursor);
          }
          _window.off('resize' + EVENT_NS);
        });
        _mfpOn('Resize' + ns, mfp.resizeImage);
        if (mfp.isLowIE) {
          _mfpOn('AfterChange', mfp.resizeImage);
        }
      },
      resizeImage: function resizeImage() {
        var item = mfp.currItem;
        if (!item || !item.img) return;
        if (mfp.st.image.verticalFit) {
          var decr = 0;
          if (mfp.isLowIE) {
            decr = parseInt(item.img.css('padding-top'), 10) + parseInt(item.img.css('padding-bottom'), 10);
          }
          item.img.css('max-height', mfp.wH - decr);
        }
      },
      _onImageHasSize: function _onImageHasSize(item) {
        if (item.img) {
          item.hasSize = true;
          if (_imgInterval) {
            clearInterval(_imgInterval);
          }
          item.isCheckingImgSize = false;
          _mfpTrigger('ImageHasSize', item);
          if (item.imgHidden) {
            if (mfp.content) mfp.content.removeClass('mfp-loading');
            item.imgHidden = false;
          }
        }
      },
      /**
       * Function that loops until the image has size to display elements that rely on it asap
       */
      findImageSize: function findImageSize(item) {
        var counter = 0,
          img = item.img[0],
          mfpSetInterval = function mfpSetInterval(delay) {
            if (_imgInterval) {
              clearInterval(_imgInterval);
            }
            _imgInterval = setInterval(function () {
              if (img.naturalWidth > 0) {
                mfp._onImageHasSize(item);
                return;
              }
              if (counter > 200) {
                clearInterval(_imgInterval);
              }
              counter++;
              if (counter === 3) {
                mfpSetInterval(10);
              } else if (counter === 40) {
                mfpSetInterval(50);
              } else if (counter === 100) {
                mfpSetInterval(500);
              }
            }, delay);
          };
        mfpSetInterval(1);
      },
      getImage: function getImage(item, template) {
        var guard = 0,
          onLoadComplete = function onLoadComplete() {
            if (item) {
              if (item.img[0].complete) {
                item.img.off('.mfploader');
                if (item === mfp.currItem) {
                  mfp._onImageHasSize(item);
                  mfp.updateStatus('ready');
                }
                item.hasSize = true;
                item.loaded = true;
                _mfpTrigger('ImageLoadComplete');
              } else {
                guard++;
                if (guard < 200) {
                  setTimeout(onLoadComplete, 100);
                } else {
                  onLoadError();
                }
              }
            }
          },
          onLoadError = function onLoadError() {
            if (item) {
              item.img.off('.mfploader');
              if (item === mfp.currItem) {
                mfp._onImageHasSize(item);
                mfp.updateStatus('error', imgSt.tError.replace('%url%', item.src));
              }
              item.hasSize = true;
              item.loaded = true;
              item.loadError = true;
            }
          },
          imgSt = mfp.st.image;
        var el = template.find('.mfp-img');
        if (el.length) {
          var img = document.createElement('img');
          img.className = 'mfp-img';
          if (item.el && item.el.find('img').length) {
            img.alt = item.el.find('img').attr('alt');
          }
          item.img = $(img).on('load.mfploader', onLoadComplete).on('error.mfploader', onLoadError);
          img.src = item.src;
          if (el.is('img')) {
            item.img = item.img.clone();
          }
          img = item.img[0];
          if (img.naturalWidth > 0) {
            item.hasSize = true;
          } else if (!img.width) {
            item.hasSize = false;
          }
        }
        mfp._parseMarkup(template, {
          title: _getTitle(item),
          img_replaceWith: item.img
        }, item);
        mfp.resizeImage();
        if (item.hasSize) {
          if (_imgInterval) clearInterval(_imgInterval);
          if (item.loadError) {
            template.addClass('mfp-loading');
            mfp.updateStatus('error', imgSt.tError.replace('%url%', item.src));
          } else {
            template.removeClass('mfp-loading');
            mfp.updateStatus('ready');
          }
          return template;
        }
        mfp.updateStatus('loading');
        item.loading = true;
        if (!item.hasSize) {
          item.imgHidden = true;
          template.addClass('mfp-loading');
          mfp.findImageSize(item);
        }
        return template;
      }
    }
  });
  /*>>image*/
  /*>>zoom*/
  var hasMozTransform,
    getHasMozTransform = function getHasMozTransform() {
      if (hasMozTransform === undefined) {
        hasMozTransform = document.createElement('p').style.MozTransform !== undefined;
      }
      return hasMozTransform;
    };
  $.magnificPopup.registerModule('zoom', {
    options: {
      enabled: false,
      easing: 'ease-in-out',
      duration: 300,
      opener: function opener(element) {
        return element.is('img') ? element : element.find('img');
      }
    },
    proto: {
      initZoom: function initZoom() {
        var zoomSt = mfp.st.zoom,
          ns = '.zoom',
          image;
        if (!zoomSt.enabled || !mfp.supportsTransition) {
          return;
        }
        var duration = zoomSt.duration,
          getElToAnimate = function getElToAnimate(image) {
            var newImg = image.clone().removeAttr('style').removeAttr('class').addClass('mfp-animated-image'),
              transition = 'all ' + zoomSt.duration / 1000 + 's ' + zoomSt.easing,
              cssObj = {
                position: 'fixed',
                zIndex: 9999,
                left: 0,
                top: 0,
                '-webkit-backface-visibility': 'hidden'
              },
              t = 'transition';
            cssObj['-webkit-' + t] = cssObj['-moz-' + t] = cssObj['-o-' + t] = cssObj[t] = transition;
            newImg.css(cssObj);
            return newImg;
          },
          showMainContent = function showMainContent() {
            mfp.content.css('visibility', 'visible');
          },
          openTimeout,
          animatedImg;
        _mfpOn('BuildControls' + ns, function () {
          if (mfp._allowZoom()) {
            clearTimeout(openTimeout);
            mfp.content.css('visibility', 'hidden');
            image = mfp._getItemToZoom();
            if (!image) {
              showMainContent();
              return;
            }
            animatedImg = getElToAnimate(image);
            animatedImg.css(mfp._getOffset());
            mfp.wrap.append(animatedImg);
            openTimeout = setTimeout(function () {
              animatedImg.css(mfp._getOffset(true));
              openTimeout = setTimeout(function () {
                showMainContent();
                setTimeout(function () {
                  animatedImg.remove();
                  image = animatedImg = null;
                  _mfpTrigger('ZoomAnimationEnded');
                }, 16); // avoid blink when switching images 
              }, duration); // this timeout equals animation duration
            }, 16); // by adding this timeout we avoid short glitch at the beginning of animation
          }
        });

        _mfpOn(BEFORE_CLOSE_EVENT + ns, function () {
          if (mfp._allowZoom()) {
            clearTimeout(openTimeout);
            mfp.st.removalDelay = duration;
            if (!image) {
              image = mfp._getItemToZoom();
              if (!image) {
                return;
              }
              animatedImg = getElToAnimate(image);
            }
            animatedImg.css(mfp._getOffset(true));
            mfp.wrap.append(animatedImg);
            mfp.content.css('visibility', 'hidden');
            setTimeout(function () {
              animatedImg.css(mfp._getOffset());
            }, 16);
          }
        });
        _mfpOn(CLOSE_EVENT + ns, function () {
          if (mfp._allowZoom()) {
            showMainContent();
            if (animatedImg) {
              animatedImg.remove();
            }
            image = null;
          }
        });
      },
      _allowZoom: function _allowZoom() {
        return mfp.currItem.type === 'image';
      },
      _getItemToZoom: function _getItemToZoom() {
        if (mfp.currItem.hasSize) {
          return mfp.currItem.img;
        } else {
          return false;
        }
      },
      _getOffset: function _getOffset(isLarge) {
        var el;
        if (isLarge) {
          el = mfp.currItem.img;
        } else {
          el = mfp.st.zoom.opener(mfp.currItem.el || mfp.currItem);
        }
        var offset = el.offset();
        var paddingTop = parseInt(el.css('padding-top'), 10);
        var paddingBottom = parseInt(el.css('padding-bottom'), 10);
        offset.top -= $(window).scrollTop() - paddingTop;
        /*
        Animating left + top + width/height looks glitchy in Firefox, but perfect in Chrome. And vice-versa.
         */
        var obj = {
          width: el.width(),
          height: (_isJQ ? el.innerHeight() : el[0].offsetHeight) - paddingBottom - paddingTop
        };
        if (getHasMozTransform()) {
          obj['-moz-transform'] = obj['transform'] = 'translate(' + offset.left + 'px,' + offset.top + 'px)';
        } else {
          obj.left = offset.left;
          obj.top = offset.top;
        }
        return obj;
      }
    }
  });
  /*>>zoom*/
  /*>>iframe*/
  var IFRAME_NS = 'iframe',
    _emptyPage = '//about:blank',
    _fixIframeBugs = function _fixIframeBugs(isShowing) {
      if (mfp.currTemplate[IFRAME_NS]) {
        var el = mfp.currTemplate[IFRAME_NS].find('iframe');
        if (el.length) {
          if (!isShowing) {
            el[0].src = _emptyPage;
          }
          if (mfp.isIE8) {
            el.css('display', isShowing ? 'block' : 'none');
          }
        }
      }
    };
  $.magnificPopup.registerModule(IFRAME_NS, {
    options: {
      markup: '<div class="mfp-iframe-scaler">' + '<div class="mfp-close"></div>' + '<iframe class="mfp-iframe" src="//about:blank" frameborder="0" allowfullscreen></iframe>' + '</div>',
      srcAction: 'iframe_src',
      patterns: {
        youtube: {
          index: 'youtube.com',
          id: 'v=',
          src: '//www.youtube.com/embed/%id%?autoplay=1'
        },
        vimeo: {
          index: 'vimeo.com/',
          id: '/',
          src: '//player.vimeo.com/video/%id%?autoplay=1'
        },
        gmaps: {
          index: '//maps.google.',
          src: '%id%&output=embed'
        }
      }
    },
    proto: {
      initIframe: function initIframe() {
        mfp.types.push(IFRAME_NS);
        _mfpOn('BeforeChange', function (e, prevType, newType) {
          if (prevType !== newType) {
            if (prevType === IFRAME_NS) {
              _fixIframeBugs(); // iframe if removed
            } else if (newType === IFRAME_NS) {
              _fixIframeBugs(true); // iframe is showing
            }
          } // else {
        });

        _mfpOn(CLOSE_EVENT + '.' + IFRAME_NS, function () {
          _fixIframeBugs();
        });
      },
      getIframe: function getIframe(item, template) {
        var embedSrc = item.src;
        var iframeSt = mfp.st.iframe;
        $.each(iframeSt.patterns, function () {
          if (embedSrc.indexOf(this.index) > -1) {
            if (this.id) {
              if (typeof this.id === 'string') {
                embedSrc = embedSrc.substr(embedSrc.lastIndexOf(this.id) + this.id.length, embedSrc.length);
              } else {
                embedSrc = this.id.call(this, embedSrc);
              }
            }
            embedSrc = this.src.replace('%id%', embedSrc);
            return false; // break;
          }
        });

        var dataObj = {};
        if (iframeSt.srcAction) {
          dataObj[iframeSt.srcAction] = embedSrc;
        }
        mfp._parseMarkup(template, dataObj, item);
        mfp.updateStatus('ready');
        return template;
      }
    }
  });
  /*>>iframe*/
  /*>>gallery*/
  /**
   * Get looped index depending on number of slides
   */
  var _getLoopedId = function _getLoopedId(index) {
      var numSlides = mfp.items.length;
      if (index > numSlides - 1) {
        return index - numSlides;
      } else if (index < 0) {
        return numSlides + index;
      }
      return index;
    },
    _replaceCurrTotal = function _replaceCurrTotal(text, curr, total) {
      return text.replace(/%curr%/gi, curr + 1).replace(/%total%/gi, total);
    };
  $.magnificPopup.registerModule('gallery', {
    options: {
      enabled: false,
      arrowMarkup: '<button title="%title%" type="button" class="mfp-arrow mfp-arrow-%dir%"></button>',
      preload: [0, 2],
      navigateByImgClick: true,
      arrows: true,
      tPrev: 'Previous (Left arrow key)',
      tNext: 'Next (Right arrow key)',
      tCounter: '%curr% of %total%'
    },
    proto: {
      initGallery: function initGallery() {
        var gSt = mfp.st.gallery,
          ns = '.mfp-gallery',
          supportsFastClick = Boolean($.fn.mfpFastClick);
        mfp.direction = true; // true - next, false - prev
        if (!gSt || !gSt.enabled) return false;
        _wrapClasses += ' mfp-gallery';
        _mfpOn(OPEN_EVENT + ns, function () {
          if (gSt.navigateByImgClick) {
            mfp.wrap.on('click' + ns, '.mfp-img', function () {
              if (mfp.items.length > 1) {
                mfp.next();
                return false;
              }
            });
          }
          _document.on('keydown' + ns, function (e) {
            if (e.keyCode === 37) {
              mfp.prev();
            } else if (e.keyCode === 39) {
              mfp.next();
            }
          });
        });
        _mfpOn('UpdateStatus' + ns, function (e, data) {
          if (data.text) {
            data.text = _replaceCurrTotal(data.text, mfp.currItem.index, mfp.items.length);
          }
        });
        _mfpOn(MARKUP_PARSE_EVENT + ns, function (e, element, values, item) {
          var l = mfp.items.length;
          values.counter = l > 1 ? _replaceCurrTotal(gSt.tCounter, item.index, l) : '';
        });
        _mfpOn('BuildControls' + ns, function () {
          if (mfp.items.length > 1 && gSt.arrows && !mfp.arrowLeft) {
            var markup = gSt.arrowMarkup,
              arrowLeft = mfp.arrowLeft = $(markup.replace(/%title%/gi, gSt.tPrev).replace(/%dir%/gi, 'left')).addClass(PREVENT_CLOSE_CLASS),
              arrowRight = mfp.arrowRight = $(markup.replace(/%title%/gi, gSt.tNext).replace(/%dir%/gi, 'right')).addClass(PREVENT_CLOSE_CLASS);
            var eName = supportsFastClick ? 'mfpFastClick' : 'click';
            arrowLeft[eName](function () {
              mfp.prev();
            });
            arrowRight[eName](function () {
              mfp.next();
            });
            if (mfp.isIE7) {
              _getEl('b', arrowLeft[0], false, true);
              _getEl('a', arrowLeft[0], false, true);
              _getEl('b', arrowRight[0], false, true);
              _getEl('a', arrowRight[0], false, true);
            }
            mfp.container.append(arrowLeft.add(arrowRight));
          }
        });
        _mfpOn(CHANGE_EVENT + ns, function () {
          if (mfp._preloadTimeout) clearTimeout(mfp._preloadTimeout);
          mfp._preloadTimeout = setTimeout(function () {
            mfp.preloadNearbyImages();
            mfp._preloadTimeout = null;
          }, 16);
        });
        _mfpOn(CLOSE_EVENT + ns, function () {
          _document.off(ns);
          mfp.wrap.off('click' + ns);
          if (mfp.arrowLeft && supportsFastClick) {
            mfp.arrowLeft.add(mfp.arrowRight).destroyMfpFastClick();
          }
          mfp.arrowRight = mfp.arrowLeft = null;
        });
      },
      next: function next() {
        mfp.direction = true;
        mfp.index = _getLoopedId(mfp.index + 1);
        mfp.updateItemHTML();
      },
      prev: function prev() {
        mfp.direction = false;
        mfp.index = _getLoopedId(mfp.index - 1);
        mfp.updateItemHTML();
      },
      goTo: function goTo(newIndex) {
        mfp.direction = newIndex >= mfp.index;
        mfp.index = newIndex;
        mfp.updateItemHTML();
      },
      preloadNearbyImages: function preloadNearbyImages() {
        var p = mfp.st.gallery.preload,
          preloadBefore = Math.min(p[0], mfp.items.length),
          preloadAfter = Math.min(p[1], mfp.items.length),
          i;
        for (i = 1; i <= (mfp.direction ? preloadAfter : preloadBefore); i++) {
          mfp._preloadItem(mfp.index + i);
        }
        for (i = 1; i <= (mfp.direction ? preloadBefore : preloadAfter); i++) {
          mfp._preloadItem(mfp.index - i);
        }
      },
      _preloadItem: function _preloadItem(index) {
        index = _getLoopedId(index);
        if (mfp.items[index].preloaded) {
          return;
        }
        var item = mfp.items[index];
        if (!item.parsed) {
          item = mfp.parseEl(index);
        }
        _mfpTrigger('LazyLoad', item);
        if (item.type === 'image') {
          item.img = $('<img class="mfp-img" />').on('load.mfploader', function () {
            item.hasSize = true;
          }).on('error.mfploader', function () {
            item.hasSize = true;
            item.loadError = true;
            _mfpTrigger('LazyLoadError', item);
          }).attr('src', item.src);
        }
        item.preloaded = true;
      }
    }
  });
  /*
  Touch Support that might be implemented some day
  addSwipeGesture: function() {
  	var startX,
  		moved,
  		multipleTouches;
  		return;
  	var namespace = '.mfp',
  		addEventNames = function(pref, down, move, up, cancel) {
  			mfp._tStart = pref + down + namespace;
  			mfp._tMove = pref + move + namespace;
  			mfp._tEnd = pref + up + namespace;
  			mfp._tCancel = pref + cancel + namespace;
  		};
  	if(window.navigator.msPointerEnabled) {
  		addEventNames('MSPointer', 'Down', 'Move', 'Up', 'Cancel');
  	} else if('ontouchstart' in window) {
  		addEventNames('touch', 'start', 'move', 'end', 'cancel');
  	} else {
  		return;
  	}
  	_window.on(mfp._tStart, function(e) {
  		var oE = e.originalEvent;
  		multipleTouches = moved = false;
  		startX = oE.pageX || oE.changedTouches[0].pageX;
  	}).on(mfp._tMove, function(e) {
  		if(e.originalEvent.touches.length > 1) {
  			multipleTouches = e.originalEvent.touches.length;
  		} else {
  			moved = true;
  		}
  	}).on(mfp._tEnd + ' ' + mfp._tCancel, function(e) {
  		if(moved && !multipleTouches) {
  			var oE = e.originalEvent,
  				diff = startX - (oE.pageX || oE.changedTouches[0].pageX);
  			if(diff > 20) {
  				mfp.next();
  			} else if(diff < -20) {
  				mfp.prev();
  			}
  		}
  	});
  },
  */
  /*>>gallery*/
  /*>>retina*/
  var RETINA_NS = 'retina';
  $.magnificPopup.registerModule(RETINA_NS, {
    options: {
      replaceSrc: function replaceSrc(item) {
        return item.src.replace(/\.\w+$/, function (m) {
          return '@2x' + m;
        });
      },
      ratio: 1 // Function or number.  Set to 1 to disable.
    },

    proto: {
      initRetina: function initRetina() {
        if (window.devicePixelRatio > 1) {
          var st = mfp.st.retina,
            ratio = st.ratio;
          ratio = !isNaN(ratio) ? ratio : ratio();
          if (ratio > 1) {
            _mfpOn('ImageHasSize' + '.' + RETINA_NS, function (e, item) {
              item.img.css({
                'max-width': item.img[0].naturalWidth / ratio,
                'width': '100%'
              });
            });
            _mfpOn('ElementParse' + '.' + RETINA_NS, function (e, item) {
              item.src = st.replaceSrc(item, ratio);
            });
          }
        }
      }
    }
  });
  /*>>retina*/
  /*>>fastclick*/
  /**
   * FastClick event implementation. (removes 300ms delay on touch devices)
   * Based on //developers.google.com/mobile/articles/fast_buttons
   *
   * You may use it outside the Magnific Popup by calling just:
   *
   * $('.your-el').mfpFastClick(function() {
   *     console.log('Clicked!');
   * });
   *
   * To unbind:
   * $('.your-el').destroyMfpFastClick();
   * 
   * 
   * Note that it's a very basic and simple implementation, it blocks ghost click on the same element where it was bound.
   * If you need something more advanced, use plugin by FT Labs //github.com/ftlabs/fastclick
   * 
   */
  (function () {
    var ghostClickDelay = 1000,
      supportsTouch = ('ontouchstart' in window),
      unbindTouchMove = function unbindTouchMove() {
        _window.off('touchmove' + ns + ' touchend' + ns);
      },
      eName = 'mfpFastClick',
      ns = '.' + eName;
    $.fn.mfpFastClick = function (callback) {
      return $(this).each(function () {
        var elem = $(this),
          lock;
        if (supportsTouch) {
          var timeout, startX, startY, pointerMoved, point, numPointers;
          elem.on('touchstart' + ns, function (e) {
            pointerMoved = false;
            numPointers = 1;
            point = e.originalEvent ? e.originalEvent.touches[0] : e.touches[0];
            startX = point.clientX;
            startY = point.clientY;
            _window.on('touchmove' + ns, function (e) {
              point = e.originalEvent ? e.originalEvent.touches : e.touches;
              numPointers = point.length;
              point = point[0];
              if (Math.abs(point.clientX - startX) > 10 || Math.abs(point.clientY - startY) > 10) {
                pointerMoved = true;
                unbindTouchMove();
              }
            }).on('touchend' + ns, function (e) {
              unbindTouchMove();
              if (pointerMoved || numPointers > 1) {
                return;
              }
              lock = true;
              e.preventDefault();
              clearTimeout(timeout);
              timeout = setTimeout(function () {
                lock = false;
              }, ghostClickDelay);
              callback();
            });
          });
        }
        elem.on('click' + ns, function () {
          if (!lock) {
            callback();
          }
        });
      });
    };
    $.fn.destroyMfpFastClick = function () {
      $(this).off('touchstart' + ns + ' click' + ns);
      if (supportsTouch) _window.off('touchmove' + ns + ' touchend' + ns);
    };
  })();
  /*>>fastclick*/
  _checkInstance();
});
/*! bootstrap-progressbar v0.7.1 | Copyright (c) 2012-2014 Stephan Gross | MIT license | minddust.com */
!function (t) {
  "use strict";

  var e = function e(n, a) {
    this.$element = t(n), this.options = t.extend({}, e.defaults, a);
  };
  e.defaults = {
    transition_delay: 300,
    refresh_speed: 50,
    display_text: "none",
    use_percentage: !0,
    percent_format: function percent_format(t) {
      return t + "%";
    },
    amount_format: function amount_format(t, e) {
      return t + " / " + e;
    },
    update: t.noop,
    done: t.noop,
    fail: t.noop
  }, e.prototype.transition = function () {
    var n = this.$element,
      a = n.parent(),
      s = this.$back_text,
      i = this.$front_text,
      r = this.options,
      o = n.attr("data-valuetransitiongoal"),
      h = n.attr("data-valuemin") || 0,
      d = n.attr("data-valuemax") || 100,
      f = a.hasClass("vertical"),
      u = r.update && "function" == typeof r.update ? r.update : e.defaults.update,
      c = r.done && "function" == typeof r.done ? r.done : e.defaults.done,
      p = r.fail && "function" == typeof r.fail ? r.fail : e.defaults.fail;
    if (!o) return void p("aria-valuetransitiongoal not set");
    var l = Math.round(100 * (o - h) / (d - h));
    if ("center" === r.display_text && !s && !i) {
      this.$back_text = s = t("<span>").addClass("progressbar-back-text").prependTo(a), this.$front_text = i = t("<span>").addClass("progressbar-front-text").prependTo(n);
      var g;
      f ? (g = a.css("height"), s.css({
        height: g,
        "line-height": g
      }), i.css({
        height: g,
        "line-height": g
      }), t(window).resize(function () {
        g = a.css("height"), s.css({
          height: g,
          "line-height": g
        }), i.css({
          height: g,
          "line-height": g
        });
      })) : (g = a.css("width"), i.css({
        width: g
      }), t(window).resize(function () {
        g = a.css("width"), i.css({
          width: g
        });
      }));
    }
    setTimeout(function () {
      var t, e, p, g, _;
      f ? n.css("height", l + "%") : n.css("width", l + "%");
      var v = setInterval(function () {
        f ? (p = n.height(), g = a.height()) : (p = n.width(), g = a.width()), t = Math.round(100 * p / g), e = Math.round(p / g * (d - h)), t >= l && (t = l, e = o, c(), clearInterval(v)), "none" !== r.display_text && (_ = r.use_percentage ? r.percent_format(t) : r.amount_format(e, d), "fill" === r.display_text ? n.text(_) : "center" === r.display_text && (s.text(_), i.text(_))), n.attr("data-valuenow", e), u(t);
      }, r.refresh_speed);
    }, r.transition_delay);
  };
  var n = t.fn.progressbar;
  t.fn.progressbar = function (n) {
    return this.each(function () {
      var a = t(this),
        s = a.data("bs.progressbar"),
        i = "object" == _typeof(n) && n;
      s || a.data("bs.progressbar", s = new e(this, i)), s.transition();
    });
  }, t.fn.progressbar.Constructor = e, t.fn.progressbar.noConflict = function () {
    return t.fn.progressbar = n, this;
  };
}(window.jQuery);
/*! WOW wow.js - v1.3.0 - 2016-10-04
* https://wowjs.uk
* Copyright (c) 2016 Thomas Grainger; Licensed MIT */
!function (a, b) {
  if ("function" == typeof define && define.amd) define(["module", "exports"], b);else if ("undefined" != typeof exports) b(module, exports);else {
    var c = {
      exports: {}
    };
    b(c, c.exports), a.WOW = c.exports;
  }
}(this, function (a, b) {
  "use strict";

  function c(a, b) {
    if (!(a instanceof b)) throw new TypeError("Cannot call a class as a function");
  }
  function d(a, b) {
    return b.indexOf(a) >= 0;
  }
  function e(a, b) {
    for (var c in b) if (null == a[c]) {
      var d = b[c];
      a[c] = d;
    }
    return a;
  }
  function f(a) {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(a);
  }
  function g(a) {
    var b = arguments.length <= 1 || void 0 === arguments[1] ? !1 : arguments[1],
      c = arguments.length <= 2 || void 0 === arguments[2] ? !1 : arguments[2],
      d = arguments.length <= 3 || void 0 === arguments[3] ? null : arguments[3],
      e = void 0;
    return null != document.createEvent ? (e = document.createEvent("CustomEvent"), e.initCustomEvent(a, b, c, d)) : null != document.createEventObject ? (e = document.createEventObject(), e.eventType = a) : e.eventName = a, e;
  }
  function h(a, b) {
    null != a.dispatchEvent ? a.dispatchEvent(b) : b in (null != a) ? a[b]() : "on" + b in (null != a) && a["on" + b]();
  }
  function i(a, b, c) {
    null != a.addEventListener ? a.addEventListener(b, c, !1) : null != a.attachEvent ? a.attachEvent("on" + b, c) : a[b] = c;
  }
  function j(a, b, c) {
    null != a.removeEventListener ? a.removeEventListener(b, c, !1) : null != a.detachEvent ? a.detachEvent("on" + b, c) : delete a[b];
  }
  function k() {
    return "innerHeight" in window ? window.innerHeight : document.documentElement.clientHeight;
  }
  Object.defineProperty(b, "__esModule", {
    value: !0
  });
  var l,
    m,
    n = function () {
      function a(a, b) {
        for (var c = 0; c < b.length; c++) {
          var d = b[c];
          d.enumerable = d.enumerable || !1, d.configurable = !0, "value" in d && (d.writable = !0), Object.defineProperty(a, d.key, d);
        }
      }
      return function (b, c, d) {
        return c && a(b.prototype, c), d && a(b, d), b;
      };
    }(),
    o = window.WeakMap || window.MozWeakMap || function () {
      function a() {
        c(this, a), this.keys = [], this.values = [];
      }
      return n(a, [{
        key: "get",
        value: function value(a) {
          for (var b = 0; b < this.keys.length; b++) {
            var c = this.keys[b];
            if (c === a) return this.values[b];
          }
        }
      }, {
        key: "set",
        value: function value(a, b) {
          for (var c = 0; c < this.keys.length; c++) {
            var d = this.keys[c];
            if (d === a) return this.values[c] = b, this;
          }
          return this.keys.push(a), this.values.push(b), this;
        }
      }]), a;
    }(),
    p = window.MutationObserver || window.WebkitMutationObserver || window.MozMutationObserver || (m = l = function () {
      function a() {
        c(this, a), "undefined" != typeof console && null !== console && (console.warn("MutationObserver is not supported by your browser."), console.warn("WOW.js cannot detect dom mutations, please call .sync() after loading new content."));
      }
      return n(a, [{
        key: "observe",
        value: function value() {}
      }]), a;
    }(), l.notSupported = !0, m),
    q = window.getComputedStyle || function (a) {
      var b = /(\-([a-z]){1})/g;
      return {
        getPropertyValue: function getPropertyValue(c) {
          "float" === c && (c = "styleFloat"), b.test(c) && c.replace(b, function (a, b) {
            return b.toUpperCase();
          });
          var d = a.currentStyle;
          return (null != d ? d[c] : void 0) || null;
        }
      };
    },
    r = function () {
      function a() {
        var b = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0];
        c(this, a), this.defaults = {
          boxClass: "wow",
          animateClass: "animated",
          offset: 0,
          mobile: !0,
          live: !0,
          callback: null,
          scrollContainer: null,
          resetAnimation: !0
        }, this.animate = function () {
          return "requestAnimationFrame" in window ? function (a) {
            return window.requestAnimationFrame(a);
          } : function (a) {
            return a();
          };
        }(), this.vendors = ["moz", "webkit"], this.start = this.start.bind(this), this.resetAnimation = this.resetAnimation.bind(this), this.scrollHandler = this.scrollHandler.bind(this), this.scrollCallback = this.scrollCallback.bind(this), this.scrolled = !0, this.config = e(b, this.defaults), null != b.scrollContainer && (this.config.scrollContainer = document.querySelector(b.scrollContainer)), this.animationNameCache = new o(), this.wowEvent = g(this.config.boxClass);
      }
      return n(a, [{
        key: "init",
        value: function value() {
          this.element = window.document.documentElement, d(document.readyState, ["interactive", "complete"]) ? this.start() : i(document, "DOMContentLoaded", this.start), this.finished = [];
        }
      }, {
        key: "start",
        value: function value() {
          var a = this;
          if (this.stopped = !1, this.boxes = [].slice.call(this.element.querySelectorAll("." + this.config.boxClass)), this.all = this.boxes.slice(0), this.boxes.length) if (this.disabled()) this.resetStyle();else for (var b = 0; b < this.boxes.length; b++) {
            var c = this.boxes[b];
            this.applyStyle(c, !0);
          }
          if (this.disabled() || (i(this.config.scrollContainer || window, "scroll", this.scrollHandler), i(window, "resize", this.scrollHandler), this.interval = setInterval(this.scrollCallback, 50)), this.config.live) {
            var d = new p(function (b) {
              for (var c = 0; c < b.length; c++) for (var d = b[c], e = 0; e < d.addedNodes.length; e++) {
                var f = d.addedNodes[e];
                a.doSync(f);
              }
            });
            d.observe(document.body, {
              childList: !0,
              subtree: !0
            });
          }
        }
      }, {
        key: "stop",
        value: function value() {
          this.stopped = !0, j(this.config.scrollContainer || window, "scroll", this.scrollHandler), j(window, "resize", this.scrollHandler), null != this.interval && clearInterval(this.interval);
        }
      }, {
        key: "sync",
        value: function value() {
          p.notSupported && this.doSync(this.element);
        }
      }, {
        key: "doSync",
        value: function value(a) {
          if ("undefined" != typeof a && null !== a || (a = this.element), 1 === a.nodeType) {
            a = a.parentNode || a;
            for (var b = a.querySelectorAll("." + this.config.boxClass), c = 0; c < b.length; c++) {
              var e = b[c];
              d(e, this.all) || (this.boxes.push(e), this.all.push(e), this.stopped || this.disabled() ? this.resetStyle() : this.applyStyle(e, !0), this.scrolled = !0);
            }
          }
        }
      }, {
        key: "show",
        value: function value(a) {
          return this.applyStyle(a), a.className = a.className + " " + this.config.animateClass, null != this.config.callback && this.config.callback(a), h(a, this.wowEvent), this.config.resetAnimation && (i(a, "animationend", this.resetAnimation), i(a, "oanimationend", this.resetAnimation), i(a, "webkitAnimationEnd", this.resetAnimation), i(a, "MSAnimationEnd", this.resetAnimation)), a;
        }
      }, {
        key: "applyStyle",
        value: function value(a, b) {
          var c = this,
            d = a.getAttribute("data-wow-duration"),
            e = a.getAttribute("data-wow-delay"),
            f = a.getAttribute("data-wow-iteration");
          return this.animate(function () {
            return c.customStyle(a, b, d, e, f);
          });
        }
      }, {
        key: "resetStyle",
        value: function value() {
          for (var a = 0; a < this.boxes.length; a++) {
            var b = this.boxes[a];
            b.style.visibility = "visible";
          }
        }
      }, {
        key: "resetAnimation",
        value: function value(a) {
          if (a.type.toLowerCase().indexOf("animationend") >= 0) {
            var b = a.target || a.srcElement;
            b.className = b.className.replace(this.config.animateClass, "").trim();
          }
        }
      }, {
        key: "customStyle",
        value: function value(a, b, c, d, e) {
          return b && this.cacheAnimationName(a), a.style.visibility = b ? "hidden" : "visible", c && this.vendorSet(a.style, {
            animationDuration: c
          }), d && this.vendorSet(a.style, {
            animationDelay: d
          }), e && this.vendorSet(a.style, {
            animationIterationCount: e
          }), this.vendorSet(a.style, {
            animationName: b ? "none" : this.cachedAnimationName(a)
          }), a;
        }
      }, {
        key: "vendorSet",
        value: function value(a, b) {
          for (var c in b) if (b.hasOwnProperty(c)) {
            var d = b[c];
            a["" + c] = d;
            for (var e = 0; e < this.vendors.length; e++) {
              var f = this.vendors[e];
              a["" + f + c.charAt(0).toUpperCase() + c.substr(1)] = d;
            }
          }
        }
      }, {
        key: "vendorCSS",
        value: function value(a, b) {
          for (var c = q(a), d = c.getPropertyCSSValue(b), e = 0; e < this.vendors.length; e++) {
            var f = this.vendors[e];
            d = d || c.getPropertyCSSValue("-" + f + "-" + b);
          }
          return d;
        }
      }, {
        key: "animationName",
        value: function value(a) {
          var b = void 0;
          try {
            b = this.vendorCSS(a, "animation-name").cssText;
          } catch (c) {
            b = q(a).getPropertyValue("animation-name");
          }
          return "none" === b ? "" : b;
        }
      }, {
        key: "cacheAnimationName",
        value: function value(a) {
          return this.animationNameCache.set(a, this.animationName(a));
        }
      }, {
        key: "cachedAnimationName",
        value: function value(a) {
          return this.animationNameCache.get(a);
        }
      }, {
        key: "scrollHandler",
        value: function value() {
          this.scrolled = !0;
        }
      }, {
        key: "scrollCallback",
        value: function value() {
          if (this.scrolled) {
            this.scrolled = !1;
            for (var a = [], b = 0; b < this.boxes.length; b++) {
              var c = this.boxes[b];
              if (c) {
                if (this.isVisible(c)) {
                  this.show(c);
                  continue;
                }
                a.push(c);
              }
            }
            this.boxes = a, this.boxes.length || this.config.live || this.stop();
          }
        }
      }, {
        key: "offsetTop",
        value: function value(a) {
          for (; void 0 === a.offsetTop;) a = a.parentNode;
          for (var b = a.offsetTop; a.offsetParent;) a = a.offsetParent, b += a.offsetTop;
          return b;
        }
      }, {
        key: "isVisible",
        value: function value(a) {
          var b = a.getAttribute("data-wow-offset") || this.config.offset,
            c = this.config.scrollContainer && this.config.scrollContainer.scrollTop || window.pageYOffset,
            d = c + Math.min(this.element.clientHeight, k()) - b,
            e = this.offsetTop(a),
            f = e + a.clientHeight;
          return d >= e && f >= c;
        }
      }, {
        key: "disabled",
        value: function value() {
          return !this.config.mobile && f(navigator.userAgent);
        }
      }]), a;
    }();
  b["default"] = r, a.exports = b["default"];
});
/*! jQuery UI - v1.12.1 - 2020-09-25
* http://jqueryui.com
* Includes: data.js, disable-selection.js, escape-selector.js, focusable.js, form-reset-mixin.js, form.js, ie.js, jquery-1-7.js, keycode.js, labels.js, plugin.js, position.js, safe-active-element.js, safe-blur.js, scroll-parent.js, tabbable.js, unique-id.js, version.js, widget.js
* Copyright jQuery Foundation and other contributors; Licensed  */
!function (t) {
  "function" == typeof define && define.amd ? define(["jquery"], t) : t(jQuery);
}(function (x) {
  var t, e, n, W, C, o, s, r, l, a, i, h;
  function E(t, e, i) {
    return [parseFloat(t[0]) * (a.test(t[0]) ? e / 100 : 1), parseFloat(t[1]) * (a.test(t[1]) ? i / 100 : 1)];
  }
  function H(t, e) {
    return parseInt(x.css(t, e), 10) || 0;
  }
  x.ui = x.ui || {}, x.ui.version = "1.12.1",
  /*!
   * jQuery UI :data 1.12.1
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */
  x.extend(x.expr[":"], {
    data: x.expr.createPseudo ? x.expr.createPseudo(function (e) {
      return function (t) {
        return !!x.data(t, e);
      };
    }) : function (t, e, i) {
      return !!x.data(t, i[3]);
    }
  }),
  /*!
   * jQuery UI Disable Selection 1.12.1
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */
  x.fn.extend({
    disableSelection: (t = "onselectstart" in document.createElement("div") ? "selectstart" : "mousedown", function () {
      return this.on(t + ".ui-disableSelection", function (t) {
        t.preventDefault();
      });
    }),
    enableSelection: function enableSelection() {
      return this.off(".ui-disableSelection");
    }
  }), x.ui.escapeSelector = (e = /([!"#$%&'()*+,./:;<=>?@[\]^`{|}~])/g, function (t) {
    return t.replace(e, "\\$1");
  }),
  /*!
   * jQuery UI Focusable 1.12.1
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */
  x.ui.focusable = function (t, e) {
    var i,
      n,
      o,
      s,
      r = t.nodeName.toLowerCase();
    return "area" === r ? (n = (i = t.parentNode).name, !(!t.href || !n || "map" !== i.nodeName.toLowerCase()) && 0 < (n = x("img[usemap='#" + n + "']")).length && n.is(":visible")) : (/^(input|select|textarea|button|object)$/.test(r) ? (o = !t.disabled) && (s = x(t).closest("fieldset")[0]) && (o = !s.disabled) : o = "a" === r && t.href || e, o && x(t).is(":visible") && function (t) {
      var e = t.css("visibility");
      for (; "inherit" === e;) t = t.parent(), e = t.css("visibility");
      return "hidden" !== e;
    }(x(t)));
  }, x.extend(x.expr[":"], {
    focusable: function focusable(t) {
      return x.ui.focusable(t, null != x.attr(t, "tabindex"));
    }
  }), x.fn.form = function () {
    return "string" == typeof this[0].form ? this.closest("form") : x(this[0].form);
  },
  /*!
   * jQuery UI Form Reset Mixin 1.12.1
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */
  x.ui.formResetMixin = {
    _formResetHandler: function _formResetHandler() {
      var e = x(this);
      setTimeout(function () {
        var t = e.data("ui-form-reset-instances");
        x.each(t, function () {
          this.refresh();
        });
      });
    },
    _bindFormResetHandler: function _bindFormResetHandler() {
      var t;
      this.form = this.element.form(), this.form.length && ((t = this.form.data("ui-form-reset-instances") || []).length || this.form.on("reset.ui-form-reset", this._formResetHandler), t.push(this), this.form.data("ui-form-reset-instances", t));
    },
    _unbindFormResetHandler: function _unbindFormResetHandler() {
      var t;
      this.form.length && ((t = this.form.data("ui-form-reset-instances")).splice(x.inArray(this, t), 1), t.length ? this.form.data("ui-form-reset-instances", t) : this.form.removeData("ui-form-reset-instances").off("reset.ui-form-reset"));
    }
  }, x.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()),
  /*!
   * jQuery UI Support for jQuery core 1.7.x 1.12.1
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   */
  "1.7" === x.fn.jquery.substring(0, 3) && (x.each(["Width", "Height"], function (t, i) {
    var o = "Width" === i ? ["Left", "Right"] : ["Top", "Bottom"],
      n = i.toLowerCase(),
      s = {
        innerWidth: x.fn.innerWidth,
        innerHeight: x.fn.innerHeight,
        outerWidth: x.fn.outerWidth,
        outerHeight: x.fn.outerHeight
      };
    function r(t, e, i, n) {
      return x.each(o, function () {
        e -= parseFloat(x.css(t, "padding" + this)) || 0, i && (e -= parseFloat(x.css(t, "border" + this + "Width")) || 0), n && (e -= parseFloat(x.css(t, "margin" + this)) || 0);
      }), e;
    }
    x.fn["inner" + i] = function (t) {
      return void 0 === t ? s["inner" + i].call(this) : this.each(function () {
        x(this).css(n, r(this, t) + "px");
      });
    }, x.fn["outer" + i] = function (t, e) {
      return "number" != typeof t ? s["outer" + i].call(this, t) : this.each(function () {
        x(this).css(n, r(this, t, !0, e) + "px");
      });
    };
  }), x.fn.addBack = function (t) {
    return this.add(null == t ? this.prevObject : this.prevObject.filter(t));
  }),
  /*!
   * jQuery UI Keycode 1.12.1
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */
  x.ui.keyCode = {
    BACKSPACE: 8,
    COMMA: 188,
    DELETE: 46,
    DOWN: 40,
    END: 35,
    ENTER: 13,
    ESCAPE: 27,
    HOME: 36,
    LEFT: 37,
    PAGE_DOWN: 34,
    PAGE_UP: 33,
    PERIOD: 190,
    RIGHT: 39,
    SPACE: 32,
    TAB: 9,
    UP: 38
  },
  /*!
   * jQuery UI Labels 1.12.1
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */
  x.fn.labels = function () {
    var t, e, i;
    return this[0].labels && this[0].labels.length ? this.pushStack(this[0].labels) : (e = this.eq(0).parents("label"), (t = this.attr("id")) && (i = (i = this.eq(0).parents().last()).add((i.length ? i : this).siblings()), t = "label[for='" + x.ui.escapeSelector(t) + "']", e = e.add(i.find(t).addBack(t))), this.pushStack(e));
  }, x.ui.plugin = {
    add: function add(t, e, i) {
      var n,
        o = x.ui[t].prototype;
      for (n in i) o.plugins[n] = o.plugins[n] || [], o.plugins[n].push([e, i[n]]);
    },
    call: function call(t, e, i, n) {
      var o,
        s = t.plugins[e];
      if (s && (n || t.element[0].parentNode && 11 !== t.element[0].parentNode.nodeType)) for (o = 0; o < s.length; o++) t.options[s[o][0]] && s[o][1].apply(t.element, i);
    }
  },
  /*!
   * jQuery UI Position 1.12.1
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   *
   * http://api.jqueryui.com/position/
   */
  W = Math.max, C = Math.abs, o = /left|center|right/, s = /top|center|bottom/, r = /[\+\-]\d+(\.[\d]+)?%?/, l = /^\w+/, a = /%$/, i = x.fn.position, x.position = {
    scrollbarWidth: function scrollbarWidth() {
      if (void 0 !== n) return n;
      var t,
        e = x("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),
        i = e.children()[0];
      return x("body").append(e), t = i.offsetWidth, e.css("overflow", "scroll"), t === (i = i.offsetWidth) && (i = e[0].clientWidth), e.remove(), n = t - i;
    },
    getScrollInfo: function getScrollInfo(t) {
      var e = t.isWindow || t.isDocument ? "" : t.element.css("overflow-x"),
        i = t.isWindow || t.isDocument ? "" : t.element.css("overflow-y"),
        e = "scroll" === e || "auto" === e && t.width < t.element[0].scrollWidth;
      return {
        width: "scroll" === i || "auto" === i && t.height < t.element[0].scrollHeight ? x.position.scrollbarWidth() : 0,
        height: e ? x.position.scrollbarWidth() : 0
      };
    },
    getWithinInfo: function getWithinInfo(t) {
      var e = x(t || window),
        i = x.isWindow(e[0]),
        n = !!e[0] && 9 === e[0].nodeType;
      return {
        element: e,
        isWindow: i,
        isDocument: n,
        offset: !i && !n ? x(t).offset() : {
          left: 0,
          top: 0
        },
        scrollLeft: e.scrollLeft(),
        scrollTop: e.scrollTop(),
        width: e.outerWidth(),
        height: e.outerHeight()
      };
    }
  }, x.fn.position = function (f) {
    if (!f || !f.of) return i.apply(this, arguments);
    f = x.extend({}, f);
    var u,
      d,
      p,
      g,
      m,
      t,
      v = x(f.of),
      b = x.position.getWithinInfo(f.within),
      w = x.position.getScrollInfo(b),
      y = (f.collision || "flip").split(" "),
      _ = {},
      e = 9 === (t = (e = v)[0]).nodeType ? {
        width: e.width(),
        height: e.height(),
        offset: {
          top: 0,
          left: 0
        }
      } : x.isWindow(t) ? {
        width: e.width(),
        height: e.height(),
        offset: {
          top: e.scrollTop(),
          left: e.scrollLeft()
        }
      } : t.preventDefault ? {
        width: 0,
        height: 0,
        offset: {
          top: t.pageY,
          left: t.pageX
        }
      } : {
        width: e.outerWidth(),
        height: e.outerHeight(),
        offset: e.offset()
      };
    return v[0].preventDefault && (f.at = "left top"), d = e.width, p = e.height, m = x.extend({}, g = e.offset), x.each(["my", "at"], function () {
      var t,
        e,
        i = (f[this] || "").split(" ");
      (i = 1 === i.length ? o.test(i[0]) ? i.concat(["center"]) : s.test(i[0]) ? ["center"].concat(i) : ["center", "center"] : i)[0] = o.test(i[0]) ? i[0] : "center", i[1] = s.test(i[1]) ? i[1] : "center", t = r.exec(i[0]), e = r.exec(i[1]), _[this] = [t ? t[0] : 0, e ? e[0] : 0], f[this] = [l.exec(i[0])[0], l.exec(i[1])[0]];
    }), 1 === y.length && (y[1] = y[0]), "right" === f.at[0] ? m.left += d : "center" === f.at[0] && (m.left += d / 2), "bottom" === f.at[1] ? m.top += p : "center" === f.at[1] && (m.top += p / 2), u = E(_.at, d, p), m.left += u[0], m.top += u[1], this.each(function () {
      var i,
        t,
        r = x(this),
        l = r.outerWidth(),
        a = r.outerHeight(),
        e = H(this, "marginLeft"),
        n = H(this, "marginTop"),
        o = l + e + H(this, "marginRight") + w.width,
        s = a + n + H(this, "marginBottom") + w.height,
        h = x.extend({}, m),
        c = E(_.my, r.outerWidth(), r.outerHeight());
      "right" === f.my[0] ? h.left -= l : "center" === f.my[0] && (h.left -= l / 2), "bottom" === f.my[1] ? h.top -= a : "center" === f.my[1] && (h.top -= a / 2), h.left += c[0], h.top += c[1], i = {
        marginLeft: e,
        marginTop: n
      }, x.each(["left", "top"], function (t, e) {
        x.ui.position[y[t]] && x.ui.position[y[t]][e](h, {
          targetWidth: d,
          targetHeight: p,
          elemWidth: l,
          elemHeight: a,
          collisionPosition: i,
          collisionWidth: o,
          collisionHeight: s,
          offset: [u[0] + c[0], u[1] + c[1]],
          my: f.my,
          at: f.at,
          within: b,
          elem: r
        });
      }), f.using && (t = function t(_t5) {
        var e = g.left - h.left,
          i = e + d - l,
          n = g.top - h.top,
          o = n + p - a,
          s = {
            target: {
              element: v,
              left: g.left,
              top: g.top,
              width: d,
              height: p
            },
            element: {
              element: r,
              left: h.left,
              top: h.top,
              width: l,
              height: a
            },
            horizontal: i < 0 ? "left" : 0 < e ? "right" : "center",
            vertical: o < 0 ? "top" : 0 < n ? "bottom" : "middle"
          };
        d < l && C(e + i) < d && (s.horizontal = "center"), p < a && C(n + o) < p && (s.vertical = "middle"), W(C(e), C(i)) > W(C(n), C(o)) ? s.important = "horizontal" : s.important = "vertical", f.using.call(this, _t5, s);
      }), r.offset(x.extend(h, {
        using: t
      }));
    });
  }, x.ui.position = {
    fit: {
      left: function left(t, e) {
        var i = e.within,
          n = i.isWindow ? i.scrollLeft : i.offset.left,
          o = i.width,
          s = t.left - e.collisionPosition.marginLeft,
          r = n - s,
          l = s + e.collisionWidth - o - n;
        e.collisionWidth > o ? 0 < r && l <= 0 ? (i = t.left + r + e.collisionWidth - o - n, t.left += r - i) : t.left = !(0 < l && r <= 0) && l < r ? n + o - e.collisionWidth : n : 0 < r ? t.left += r : 0 < l ? t.left -= l : t.left = W(t.left - s, t.left);
      },
      top: function top(t, e) {
        var i = e.within,
          n = i.isWindow ? i.scrollTop : i.offset.top,
          o = e.within.height,
          s = t.top - e.collisionPosition.marginTop,
          r = n - s,
          l = s + e.collisionHeight - o - n;
        e.collisionHeight > o ? 0 < r && l <= 0 ? (i = t.top + r + e.collisionHeight - o - n, t.top += r - i) : t.top = !(0 < l && r <= 0) && l < r ? n + o - e.collisionHeight : n : 0 < r ? t.top += r : 0 < l ? t.top -= l : t.top = W(t.top - s, t.top);
      }
    },
    flip: {
      left: function left(t, e) {
        var i = e.within,
          n = i.offset.left + i.scrollLeft,
          o = i.width,
          s = i.isWindow ? i.scrollLeft : i.offset.left,
          r = t.left - e.collisionPosition.marginLeft,
          l = r - s,
          a = r + e.collisionWidth - o - s,
          h = "left" === e.my[0] ? -e.elemWidth : "right" === e.my[0] ? e.elemWidth : 0,
          i = "left" === e.at[0] ? e.targetWidth : "right" === e.at[0] ? -e.targetWidth : 0,
          r = -2 * e.offset[0];
        l < 0 ? ((n = t.left + h + i + r + e.collisionWidth - o - n) < 0 || n < C(l)) && (t.left += h + i + r) : 0 < a && (0 < (s = t.left - e.collisionPosition.marginLeft + h + i + r - s) || C(s) < a) && (t.left += h + i + r);
      },
      top: function top(t, e) {
        var i = e.within,
          n = i.offset.top + i.scrollTop,
          o = i.height,
          s = i.isWindow ? i.scrollTop : i.offset.top,
          r = t.top - e.collisionPosition.marginTop,
          l = r - s,
          a = r + e.collisionHeight - o - s,
          h = "top" === e.my[1] ? -e.elemHeight : "bottom" === e.my[1] ? e.elemHeight : 0,
          i = "top" === e.at[1] ? e.targetHeight : "bottom" === e.at[1] ? -e.targetHeight : 0,
          r = -2 * e.offset[1];
        l < 0 ? ((n = t.top + h + i + r + e.collisionHeight - o - n) < 0 || n < C(l)) && (t.top += h + i + r) : 0 < a && (0 < (s = t.top - e.collisionPosition.marginTop + h + i + r - s) || C(s) < a) && (t.top += h + i + r);
      }
    },
    flipfit: {
      left: function left() {
        x.ui.position.flip.left.apply(this, arguments), x.ui.position.fit.left.apply(this, arguments);
      },
      top: function top() {
        x.ui.position.flip.top.apply(this, arguments), x.ui.position.fit.top.apply(this, arguments);
      }
    }
  }, x.ui.safeActiveElement = function (e) {
    var i;
    try {
      i = e.activeElement;
    } catch (t) {
      i = e.body;
    }
    return i = !(i = i || e.body).nodeName ? e.body : i;
  }, x.ui.safeBlur = function (t) {
    t && "body" !== t.nodeName.toLowerCase() && x(t).trigger("blur");
  },
  /*!
   * jQuery UI Scroll Parent 1.12.1
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */
  x.fn.scrollParent = function (t) {
    var e = this.css("position"),
      i = "absolute" === e,
      n = t ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
      t = this.parents().filter(function () {
        var t = x(this);
        return (!i || "static" !== t.css("position")) && n.test(t.css("overflow") + t.css("overflow-y") + t.css("overflow-x"));
      }).eq(0);
    return "fixed" !== e && t.length ? t : x(this[0].ownerDocument || document);
  },
  /*!
   * jQuery UI Tabbable 1.12.1
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */
  x.extend(x.expr[":"], {
    tabbable: function tabbable(t) {
      var e = x.attr(t, "tabindex"),
        i = null != e;
      return (!i || 0 <= e) && x.ui.focusable(t, i);
    }
  }),
  /*!
   * jQuery UI Unique ID 1.12.1
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */
  x.fn.extend({
    uniqueId: (h = 0, function () {
      return this.each(function () {
        this.id || (this.id = "ui-id-" + ++h);
      });
    }),
    removeUniqueId: function removeUniqueId() {
      return this.each(function () {
        /^ui-id-\d+$/.test(this.id) && x(this).removeAttr("id");
      });
    }
  });
  /*!
   * jQuery UI Widget 1.12.1
   * http://jqueryui.com
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license.
   * http://jquery.org/license
   */
  var c,
    f = 0,
    u = Array.prototype.slice;
  x.cleanData = (c = x.cleanData, function (t) {
    for (var e, i, n = 0; null != (i = t[n]); n++) try {
      (e = x._data(i, "events")) && e.remove && x(i).triggerHandler("remove");
    } catch (t) {}
    c(t);
  }), x.widget = function (t, i, e) {
    var n,
      o,
      s,
      r = {},
      l = t.split(".")[0],
      a = l + "-" + (t = t.split(".")[1]);
    return e || (e = i, i = x.Widget), x.isArray(e) && (e = x.extend.apply(null, [{}].concat(e))), x.expr[":"][a.toLowerCase()] = function (t) {
      return !!x.data(t, a);
    }, x[l] = x[l] || {}, n = x[l][t], o = x[l][t] = function (t, e) {
      if (!this._createWidget) return new o(t, e);
      arguments.length && this._createWidget(t, e);
    }, x.extend(o, n, {
      version: e.version,
      _proto: x.extend({}, e),
      _childConstructors: []
    }), (s = new i()).options = x.widget.extend({}, s.options), x.each(e, function (e, n) {
      function o() {
        return i.prototype[e].apply(this, arguments);
      }
      function s(t) {
        return i.prototype[e].apply(this, t);
      }
      x.isFunction(n) ? r[e] = function () {
        var t,
          e = this._super,
          i = this._superApply;
        return this._super = o, this._superApply = s, t = n.apply(this, arguments), this._super = e, this._superApply = i, t;
      } : r[e] = n;
    }), o.prototype = x.widget.extend(s, {
      widgetEventPrefix: n && s.widgetEventPrefix || t
    }, r, {
      constructor: o,
      namespace: l,
      widgetName: t,
      widgetFullName: a
    }), n ? (x.each(n._childConstructors, function (t, e) {
      var i = e.prototype;
      x.widget(i.namespace + "." + i.widgetName, o, e._proto);
    }), delete n._childConstructors) : i._childConstructors.push(o), x.widget.bridge(t, o), o;
  }, x.widget.extend = function (t) {
    for (var e, i, n = u.call(arguments, 1), o = 0, s = n.length; o < s; o++) for (e in n[o]) i = n[o][e], n[o].hasOwnProperty(e) && void 0 !== i && (x.isPlainObject(i) ? t[e] = x.isPlainObject(t[e]) ? x.widget.extend({}, t[e], i) : x.widget.extend({}, i) : t[e] = i);
    return t;
  }, x.widget.bridge = function (s, e) {
    var r = e.prototype.widgetFullName || s;
    x.fn[s] = function (i) {
      var t = "string" == typeof i,
        n = u.call(arguments, 1),
        o = this;
      return t ? this.length || "instance" !== i ? this.each(function () {
        var t,
          e = x.data(this, r);
        return "instance" === i ? (o = e, !1) : e ? x.isFunction(e[i]) && "_" !== i.charAt(0) ? (t = e[i].apply(e, n)) !== e && void 0 !== t ? (o = t && t.jquery ? o.pushStack(t.get()) : t, !1) : void 0 : x.error("no such method '" + i + "' for " + s + " widget instance") : x.error("cannot call methods on " + s + " prior to initialization; attempted to call method '" + i + "'");
      }) : o = void 0 : (n.length && (i = x.widget.extend.apply(null, [i].concat(n))), this.each(function () {
        var t = x.data(this, r);
        t ? (t.option(i || {}), t._init && t._init()) : x.data(this, r, new e(i, this));
      })), o;
    };
  }, x.Widget = function () {}, x.Widget._childConstructors = [], x.Widget.prototype = {
    widgetName: "widget",
    widgetEventPrefix: "",
    defaultElement: "<div>",
    options: {
      classes: {},
      disabled: !1,
      create: null
    },
    _createWidget: function _createWidget(t, e) {
      e = x(e || this.defaultElement || this)[0], this.element = x(e), this.uuid = f++, this.eventNamespace = "." + this.widgetName + this.uuid, this.bindings = x(), this.hoverable = x(), this.focusable = x(), this.classesElementLookup = {}, e !== this && (x.data(e, this.widgetFullName, this), this._on(!0, this.element, {
        remove: function remove(t) {
          t.target === e && this.destroy();
        }
      }), this.document = x(e.style ? e.ownerDocument : e.document || e), this.window = x(this.document[0].defaultView || this.document[0].parentWindow)), this.options = x.widget.extend({}, this.options, this._getCreateOptions(), t), this._create(), this.options.disabled && this._setOptionDisabled(this.options.disabled), this._trigger("create", null, this._getCreateEventData()), this._init();
    },
    _getCreateOptions: function _getCreateOptions() {
      return {};
    },
    _getCreateEventData: x.noop,
    _create: x.noop,
    _init: x.noop,
    destroy: function destroy() {
      var i = this;
      this._destroy(), x.each(this.classesElementLookup, function (t, e) {
        i._removeClass(e, t);
      }), this.element.off(this.eventNamespace).removeData(this.widgetFullName), this.widget().off(this.eventNamespace).removeAttr("aria-disabled"), this.bindings.off(this.eventNamespace);
    },
    _destroy: x.noop,
    widget: function widget() {
      return this.element;
    },
    option: function option(t, e) {
      var i,
        n,
        o,
        s = t;
      if (0 === arguments.length) return x.widget.extend({}, this.options);
      if ("string" == typeof t) if (s = {}, t = (i = t.split(".")).shift(), i.length) {
        for (n = s[t] = x.widget.extend({}, this.options[t]), o = 0; o < i.length - 1; o++) n[i[o]] = n[i[o]] || {}, n = n[i[o]];
        if (t = i.pop(), 1 === arguments.length) return void 0 === n[t] ? null : n[t];
        n[t] = e;
      } else {
        if (1 === arguments.length) return void 0 === this.options[t] ? null : this.options[t];
        s[t] = e;
      }
      return this._setOptions(s), this;
    },
    _setOptions: function _setOptions(t) {
      for (var e in t) this._setOption(e, t[e]);
      return this;
    },
    _setOption: function _setOption(t, e) {
      return "classes" === t && this._setOptionClasses(e), this.options[t] = e, "disabled" === t && this._setOptionDisabled(e), this;
    },
    _setOptionClasses: function _setOptionClasses(t) {
      var e, i, n;
      for (e in t) n = this.classesElementLookup[e], t[e] !== this.options.classes[e] && n && n.length && (i = x(n.get()), this._removeClass(n, e), i.addClass(this._classes({
        element: i,
        keys: e,
        classes: t,
        add: !0
      })));
    },
    _setOptionDisabled: function _setOptionDisabled(t) {
      this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !!t), t && (this._removeClass(this.hoverable, null, "ui-state-hover"), this._removeClass(this.focusable, null, "ui-state-focus"));
    },
    enable: function enable() {
      return this._setOptions({
        disabled: !1
      });
    },
    disable: function disable() {
      return this._setOptions({
        disabled: !0
      });
    },
    _classes: function _classes(o) {
      var s = [],
        r = this;
      function t(t, e) {
        for (var i, n = 0; n < t.length; n++) i = r.classesElementLookup[t[n]] || x(), i = o.add ? x(x.unique(i.get().concat(o.element.get()))) : x(i.not(o.element).get()), r.classesElementLookup[t[n]] = i, s.push(t[n]), e && o.classes[t[n]] && s.push(o.classes[t[n]]);
      }
      return o = x.extend({
        element: this.element,
        classes: this.options.classes || {}
      }, o), this._on(o.element, {
        remove: "_untrackClassesElement"
      }), o.keys && t(o.keys.match(/\S+/g) || [], !0), o.extra && t(o.extra.match(/\S+/g) || []), s.join(" ");
    },
    _untrackClassesElement: function _untrackClassesElement(i) {
      var n = this;
      x.each(n.classesElementLookup, function (t, e) {
        -1 !== x.inArray(i.target, e) && (n.classesElementLookup[t] = x(e.not(i.target).get()));
      });
    },
    _removeClass: function _removeClass(t, e, i) {
      return this._toggleClass(t, e, i, !1);
    },
    _addClass: function _addClass(t, e, i) {
      return this._toggleClass(t, e, i, !0);
    },
    _toggleClass: function _toggleClass(t, e, i, n) {
      var o = "string" == typeof t || null === t,
        i = {
          extra: o ? e : i,
          keys: o ? t : e,
          element: o ? this.element : t,
          add: n = "boolean" == typeof n ? n : i
        };
      return i.element.toggleClass(this._classes(i), n), this;
    },
    _on: function _on(o, s, t) {
      var r,
        l = this;
      "boolean" != typeof o && (t = s, s = o, o = !1), t ? (s = r = x(s), this.bindings = this.bindings.add(s)) : (t = s, s = this.element, r = this.widget()), x.each(t, function (t, e) {
        function i() {
          if (o || !0 !== l.options.disabled && !x(this).hasClass("ui-state-disabled")) return ("string" == typeof e ? l[e] : e).apply(l, arguments);
        }
        "string" != typeof e && (i.guid = e.guid = e.guid || i.guid || x.guid++);
        var n = t.match(/^([\w:-]*)\s*(.*)$/),
          t = n[1] + l.eventNamespace,
          n = n[2];
        n ? r.on(t, n, i) : s.on(t, i);
      });
    },
    _off: function _off(t, e) {
      e = (e || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace, t.off(e).off(e), this.bindings = x(this.bindings.not(t).get()), this.focusable = x(this.focusable.not(t).get()), this.hoverable = x(this.hoverable.not(t).get());
    },
    _delay: function _delay(t, e) {
      var i = this;
      return setTimeout(function () {
        return ("string" == typeof t ? i[t] : t).apply(i, arguments);
      }, e || 0);
    },
    _hoverable: function _hoverable(t) {
      this.hoverable = this.hoverable.add(t), this._on(t, {
        mouseenter: function mouseenter(t) {
          this._addClass(x(t.currentTarget), null, "ui-state-hover");
        },
        mouseleave: function mouseleave(t) {
          this._removeClass(x(t.currentTarget), null, "ui-state-hover");
        }
      });
    },
    _focusable: function _focusable(t) {
      this.focusable = this.focusable.add(t), this._on(t, {
        focusin: function focusin(t) {
          this._addClass(x(t.currentTarget), null, "ui-state-focus");
        },
        focusout: function focusout(t) {
          this._removeClass(x(t.currentTarget), null, "ui-state-focus");
        }
      });
    },
    _trigger: function _trigger(t, e, i) {
      var n,
        o,
        s = this.options[t];
      if (i = i || {}, (e = x.Event(e)).type = (t === this.widgetEventPrefix ? t : this.widgetEventPrefix + t).toLowerCase(), e.target = this.element[0], o = e.originalEvent) for (n in o) n in e || (e[n] = o[n]);
      return this.element.trigger(e, i), !(x.isFunction(s) && !1 === s.apply(this.element[0], [e].concat(i)) || e.isDefaultPrevented());
    }
  }, x.each({
    show: "fadeIn",
    hide: "fadeOut"
  }, function (s, r) {
    x.Widget.prototype["_" + s] = function (e, t, i) {
      var n = (t = "string" == typeof t ? {
          effect: t
        } : t) ? !0 !== t && "number" != typeof t && t.effect || r : s,
        o = !x.isEmptyObject(t = "number" == typeof (t = t || {}) ? {
          duration: t
        } : t);
      t.complete = i, t.delay && e.delay(t.delay), o && x.effects && x.effects.effect[n] ? e[s](t) : n !== s && e[n] ? e[n](t.duration, t.easing, i) : e.queue(function (t) {
        x(this)[s](), i && i.call(e[0]), t();
      });
    };
  });
});
/*!
 * jQuery UI Mouse 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */
!function (e) {
  "function" == typeof define && define.amd ? define(["jquery", "./core"], e) : e(jQuery);
}(function (o) {
  var n = !1;
  return o(document).on("mouseup", function () {
    n = !1;
  }), o.widget("ui.mouse", {
    version: "1.12.1",
    options: {
      cancel: "input, textarea, button, select, option",
      distance: 1,
      delay: 0
    },
    _mouseInit: function _mouseInit() {
      var t = this;
      this.element.on("mousedown." + this.widgetName, function (e) {
        return t._mouseDown(e);
      }).on("click." + this.widgetName, function (e) {
        if (!0 === o.data(e.target, t.widgetName + ".preventClickEvent")) return o.removeData(e.target, t.widgetName + ".preventClickEvent"), e.stopImmediatePropagation(), !1;
      }), this.started = !1;
    },
    _mouseDestroy: function _mouseDestroy() {
      this.element.off("." + this.widgetName), this._mouseMoveDelegate && this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate);
    },
    _mouseDown: function _mouseDown(e) {
      if (!n) {
        this._mouseMoved = !1, this._mouseStarted && this._mouseUp(e), this._mouseDownEvent = e;
        var t = this,
          i = 1 === e.which,
          s = !("string" != typeof this.options.cancel || !e.target.nodeName) && o(e.target).closest(this.options.cancel).length;
        return i && !s && this._mouseCapture(e) ? (this.mouseDelayMet = !this.options.delay, this.mouseDelayMet || (this._mouseDelayTimer = setTimeout(function () {
          t.mouseDelayMet = !0;
        }, this.options.delay)), this._mouseDistanceMet(e) && this._mouseDelayMet(e) && (this._mouseStarted = !1 !== this._mouseStart(e), !this._mouseStarted) ? (e.preventDefault(), !0) : (!0 === o.data(e.target, this.widgetName + ".preventClickEvent") && o.removeData(e.target, this.widgetName + ".preventClickEvent"), this._mouseMoveDelegate = function (e) {
          return t._mouseMove(e);
        }, this._mouseUpDelegate = function (e) {
          return t._mouseUp(e);
        }, this.document.on("mousemove." + this.widgetName, this._mouseMoveDelegate).on("mouseup." + this.widgetName, this._mouseUpDelegate), e.preventDefault(), n = !0)) : !0;
      }
    },
    _mouseMove: function _mouseMove(e) {
      if (this._mouseMoved) {
        if (o.ui.ie && (!document.documentMode || document.documentMode < 9) && !e.button) return this._mouseUp(e);
        if (!e.which) if (e.originalEvent.altKey || e.originalEvent.ctrlKey || e.originalEvent.metaKey || e.originalEvent.shiftKey) this.ignoreMissingWhich = !0;else if (!this.ignoreMissingWhich) return this._mouseUp(e);
      }
      return (e.which || e.button) && (this._mouseMoved = !0), this._mouseStarted ? (this._mouseDrag(e), e.preventDefault()) : (this._mouseDistanceMet(e) && this._mouseDelayMet(e) && (this._mouseStarted = !1 !== this._mouseStart(this._mouseDownEvent, e), this._mouseStarted ? this._mouseDrag(e) : this._mouseUp(e)), !this._mouseStarted);
    },
    _mouseUp: function _mouseUp(e) {
      this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate), this._mouseStarted && (this._mouseStarted = !1, e.target === this._mouseDownEvent.target && o.data(e.target, this.widgetName + ".preventClickEvent", !0), this._mouseStop(e)), this._mouseDelayTimer && (clearTimeout(this._mouseDelayTimer), delete this._mouseDelayTimer), this.ignoreMissingWhich = !1, n = !1, e.preventDefault();
    },
    _mouseDistanceMet: function _mouseDistanceMet(e) {
      return Math.max(Math.abs(this._mouseDownEvent.pageX - e.pageX), Math.abs(this._mouseDownEvent.pageY - e.pageY)) >= this.options.distance;
    },
    _mouseDelayMet: function _mouseDelayMet() {
      return this.mouseDelayMet;
    },
    _mouseStart: function _mouseStart() {},
    _mouseDrag: function _mouseDrag() {},
    _mouseStop: function _mouseStop() {},
    _mouseCapture: function _mouseCapture() {
      return !0;
    }
  });
});
/*!
 * jQuery UI Slider 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */
!function (e) {
  "function" == typeof define && define.amd ? define(["jquery", "./mouse", "./core"], e) : e(jQuery);
}(function (o) {
  return o.widget("ui.slider", o.ui.mouse, {
    version: "1.12.1",
    widgetEventPrefix: "slide",
    options: {
      animate: !1,
      classes: {
        "ui-slider": "ui-corner-all",
        "ui-slider-handle": "ui-corner-all",
        "ui-slider-range": "ui-corner-all ui-widget-header"
      },
      distance: 0,
      max: 100,
      min: 0,
      orientation: "horizontal",
      range: !1,
      step: 1,
      value: 0,
      values: null,
      change: null,
      slide: null,
      start: null,
      stop: null
    },
    numPages: 5,
    _create: function _create() {
      this._keySliding = !1, this._mouseSliding = !1, this._animateOff = !0, this._handleIndex = null, this._detectOrientation(), this._mouseInit(), this._calculateNewMax(), this._addClass("ui-slider ui-slider-" + this.orientation, "ui-widget ui-widget-content"), this._refresh(), this._animateOff = !1;
    },
    _refresh: function _refresh() {
      this._createRange(), this._createHandles(), this._setupEvents(), this._refreshValue();
    },
    _createHandles: function _createHandles() {
      var e,
        t = this.options,
        i = this.element.find(".ui-slider-handle"),
        s = [],
        a = t.values && t.values.length || 1;
      for (i.length > a && (i.slice(a).remove(), i = i.slice(0, a)), e = i.length; e < a; e++) s.push("<span tabindex='0'></span>");
      this.handles = i.add(o(s.join("")).appendTo(this.element)), this._addClass(this.handles, "ui-slider-handle", "ui-state-default"), this.handle = this.handles.eq(0), this.handles.each(function (e) {
        o(this).data("ui-slider-handle-index", e).attr("tabIndex", 0);
      });
    },
    _createRange: function _createRange() {
      var e = this.options;
      e.range ? (!0 === e.range && (e.values ? e.values.length && 2 !== e.values.length ? e.values = [e.values[0], e.values[0]] : o.isArray(e.values) && (e.values = e.values.slice(0)) : e.values = [this._valueMin(), this._valueMin()]), this.range && this.range.length ? (this._removeClass(this.range, "ui-slider-range-min ui-slider-range-max"), this.range.css({
        left: "",
        bottom: ""
      })) : (this.range = o("<div>").appendTo(this.element), this._addClass(this.range, "ui-slider-range")), "min" !== e.range && "max" !== e.range || this._addClass(this.range, "ui-slider-range-" + e.range)) : (this.range && this.range.remove(), this.range = null);
    },
    _setupEvents: function _setupEvents() {
      this._off(this.handles), this._on(this.handles, this._handleEvents), this._hoverable(this.handles), this._focusable(this.handles);
    },
    _destroy: function _destroy() {
      this.handles.remove(), this.range && this.range.remove(), this._mouseDestroy();
    },
    _mouseCapture: function _mouseCapture(e) {
      var i,
        s,
        a,
        n,
        t,
        h,
        l = this,
        u = this.options;
      return !u.disabled && (this.elementSize = {
        width: this.element.outerWidth(),
        height: this.element.outerHeight()
      }, this.elementOffset = this.element.offset(), h = {
        x: e.pageX,
        y: e.pageY
      }, i = this._normValueFromMouse(h), s = this._valueMax() - this._valueMin() + 1, this.handles.each(function (e) {
        var t = Math.abs(i - l.values(e));
        (t < s || s === t && (e === l._lastChangedValue || l.values(e) === u.min)) && (s = t, a = o(this), n = e);
      }), !1 !== this._start(e, n) && (this._mouseSliding = !0, this._handleIndex = n, this._addClass(a, null, "ui-state-active"), a.trigger("focus"), t = a.offset(), h = !o(e.target).parents().addBack().is(".ui-slider-handle"), this._clickOffset = h ? {
        left: 0,
        top: 0
      } : {
        left: e.pageX - t.left - a.width() / 2,
        top: e.pageY - t.top - a.height() / 2 - (parseInt(a.css("borderTopWidth"), 10) || 0) - (parseInt(a.css("borderBottomWidth"), 10) || 0) + (parseInt(a.css("marginTop"), 10) || 0)
      }, this.handles.hasClass("ui-state-hover") || this._slide(e, n, i), this._animateOff = !0));
    },
    _mouseStart: function _mouseStart() {
      return !0;
    },
    _mouseDrag: function _mouseDrag(e) {
      var t = {
          x: e.pageX,
          y: e.pageY
        },
        t = this._normValueFromMouse(t);
      return this._slide(e, this._handleIndex, t), !1;
    },
    _mouseStop: function _mouseStop(e) {
      return this._removeClass(this.handles, null, "ui-state-active"), this._mouseSliding = !1, this._stop(e, this._handleIndex), this._change(e, this._handleIndex), this._handleIndex = null, this._clickOffset = null, this._animateOff = !1;
    },
    _detectOrientation: function _detectOrientation() {
      this.orientation = "vertical" === this.options.orientation ? "vertical" : "horizontal";
    },
    _normValueFromMouse: function _normValueFromMouse(e) {
      var t,
        e = "horizontal" === this.orientation ? (t = this.elementSize.width, e.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0)) : (t = this.elementSize.height, e.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0)),
        e = e / t;
      return (e = 1 < e ? 1 : e) < 0 && (e = 0), "vertical" === this.orientation && (e = 1 - e), t = this._valueMax() - this._valueMin(), t = this._valueMin() + e * t, this._trimAlignValue(t);
    },
    _uiHash: function _uiHash(e, t, i) {
      var s = {
        handle: this.handles[e],
        handleIndex: e,
        value: void 0 !== t ? t : this.value()
      };
      return this._hasMultipleValues() && (s.value = void 0 !== t ? t : this.values(e), s.values = i || this.values()), s;
    },
    _hasMultipleValues: function _hasMultipleValues() {
      return this.options.values && this.options.values.length;
    },
    _start: function _start(e, t) {
      return this._trigger("start", e, this._uiHash(t));
    },
    _slide: function _slide(e, t, i) {
      var s,
        a = this.value(),
        n = this.values();
      this._hasMultipleValues() && (s = this.values(t ? 0 : 1), a = this.values(t), 2 === this.options.values.length && !0 === this.options.range && (i = 0 === t ? Math.min(s, i) : Math.max(s, i)), n[t] = i), i !== a && !1 !== this._trigger("slide", e, this._uiHash(t, i, n)) && (this._hasMultipleValues() ? this.values(t, i) : this.value(i));
    },
    _stop: function _stop(e, t) {
      this._trigger("stop", e, this._uiHash(t));
    },
    _change: function _change(e, t) {
      this._keySliding || this._mouseSliding || (this._lastChangedValue = t, this._trigger("change", e, this._uiHash(t)));
    },
    value: function value(e) {
      return arguments.length ? (this.options.value = this._trimAlignValue(e), this._refreshValue(), void this._change(null, 0)) : this._value();
    },
    values: function values(e, t) {
      var i, s, a;
      if (1 < arguments.length) return this.options.values[e] = this._trimAlignValue(t), this._refreshValue(), void this._change(null, e);
      if (!arguments.length) return this._values();
      if (!o.isArray(e)) return this._hasMultipleValues() ? this._values(e) : this.value();
      for (i = this.options.values, s = e, a = 0; a < i.length; a += 1) i[a] = this._trimAlignValue(s[a]), this._change(null, a);
      this._refreshValue();
    },
    _setOption: function _setOption(e, t) {
      var i,
        s = 0;
      switch ("range" === e && !0 === this.options.range && ("min" === t ? (this.options.value = this._values(0), this.options.values = null) : "max" === t && (this.options.value = this._values(this.options.values.length - 1), this.options.values = null)), o.isArray(this.options.values) && (s = this.options.values.length), this._super(e, t), e) {
        case "orientation":
          this._detectOrientation(), this._removeClass("ui-slider-horizontal ui-slider-vertical")._addClass("ui-slider-" + this.orientation), this._refreshValue(), this.options.range && this._refreshRange(t), this.handles.css("horizontal" === t ? "bottom" : "left", "");
          break;
        case "value":
          this._animateOff = !0, this._refreshValue(), this._change(null, 0), this._animateOff = !1;
          break;
        case "values":
          for (this._animateOff = !0, this._refreshValue(), i = s - 1; 0 <= i; i--) this._change(null, i);
          this._animateOff = !1;
          break;
        case "step":
        case "min":
        case "max":
          this._animateOff = !0, this._calculateNewMax(), this._refreshValue(), this._animateOff = !1;
          break;
        case "range":
          this._animateOff = !0, this._refresh(), this._animateOff = !1;
      }
    },
    _setOptionDisabled: function _setOptionDisabled(e) {
      this._super(e), this._toggleClass(null, "ui-state-disabled", !!e);
    },
    _value: function _value() {
      var e = this.options.value;
      return e = this._trimAlignValue(e);
    },
    _values: function _values(e) {
      var t, i, s;
      if (arguments.length) return t = this.options.values[e], this._trimAlignValue(t);
      if (this._hasMultipleValues()) {
        for (i = this.options.values.slice(), s = 0; s < i.length; s += 1) i[s] = this._trimAlignValue(i[s]);
        return i;
      }
      return [];
    },
    _trimAlignValue: function _trimAlignValue(e) {
      if (e <= this._valueMin()) return this._valueMin();
      if (e >= this._valueMax()) return this._valueMax();
      var t = 0 < this.options.step ? this.options.step : 1,
        i = (e - this._valueMin()) % t,
        e = e - i;
      return 2 * Math.abs(i) >= t && (e += 0 < i ? t : -t), parseFloat(e.toFixed(5));
    },
    _calculateNewMax: function _calculateNewMax() {
      var e = this.options.max,
        t = this._valueMin(),
        i = this.options.step;
      (e = Math.round((e - t) / i) * i + t) > this.options.max && (e -= i), this.max = parseFloat(e.toFixed(this._precision()));
    },
    _precision: function _precision() {
      var e = this._precisionOf(this.options.step);
      return e = null !== this.options.min ? Math.max(e, this._precisionOf(this.options.min)) : e;
    },
    _precisionOf: function _precisionOf(e) {
      var t = e.toString(),
        e = t.indexOf(".");
      return -1 === e ? 0 : t.length - e - 1;
    },
    _valueMin: function _valueMin() {
      return this.options.min;
    },
    _valueMax: function _valueMax() {
      return this.max;
    },
    _refreshRange: function _refreshRange(e) {
      "vertical" === e && this.range.css({
        width: "",
        left: ""
      }), "horizontal" === e && this.range.css({
        height: "",
        bottom: ""
      });
    },
    _refreshValue: function _refreshValue() {
      var t,
        i,
        e,
        s,
        a,
        n = this.options.range,
        h = this.options,
        l = this,
        u = !this._animateOff && h.animate,
        r = {};
      this._hasMultipleValues() ? this.handles.each(function (e) {
        i = (l.values(e) - l._valueMin()) / (l._valueMax() - l._valueMin()) * 100, r["horizontal" === l.orientation ? "left" : "bottom"] = i + "%", o(this).stop(1, 1)[u ? "animate" : "css"](r, h.animate), !0 === l.options.range && ("horizontal" === l.orientation ? (0 === e && l.range.stop(1, 1)[u ? "animate" : "css"]({
          left: i + "%"
        }, h.animate), 1 === e && l.range[u ? "animate" : "css"]({
          width: i - t + "%"
        }, {
          queue: !1,
          duration: h.animate
        })) : (0 === e && l.range.stop(1, 1)[u ? "animate" : "css"]({
          bottom: i + "%"
        }, h.animate), 1 === e && l.range[u ? "animate" : "css"]({
          height: i - t + "%"
        }, {
          queue: !1,
          duration: h.animate
        }))), t = i;
      }) : (e = this.value(), s = this._valueMin(), a = this._valueMax(), i = a !== s ? (e - s) / (a - s) * 100 : 0, r["horizontal" === this.orientation ? "left" : "bottom"] = i + "%", this.handle.stop(1, 1)[u ? "animate" : "css"](r, h.animate), "min" === n && "horizontal" === this.orientation && this.range.stop(1, 1)[u ? "animate" : "css"]({
        width: i + "%"
      }, h.animate), "max" === n && "horizontal" === this.orientation && this.range.stop(1, 1)[u ? "animate" : "css"]({
        width: 100 - i + "%"
      }, h.animate), "min" === n && "vertical" === this.orientation && this.range.stop(1, 1)[u ? "animate" : "css"]({
        height: i + "%"
      }, h.animate), "max" === n && "vertical" === this.orientation && this.range.stop(1, 1)[u ? "animate" : "css"]({
        height: 100 - i + "%"
      }, h.animate));
    },
    _handleEvents: {
      keydown: function keydown(e) {
        var t,
          i,
          s,
          a = o(e.target).data("ui-slider-handle-index");
        switch (e.keyCode) {
          case o.ui.keyCode.HOME:
          case o.ui.keyCode.END:
          case o.ui.keyCode.PAGE_UP:
          case o.ui.keyCode.PAGE_DOWN:
          case o.ui.keyCode.UP:
          case o.ui.keyCode.RIGHT:
          case o.ui.keyCode.DOWN:
          case o.ui.keyCode.LEFT:
            if (e.preventDefault(), !this._keySliding && (this._keySliding = !0, this._addClass(o(e.target), null, "ui-state-active"), !1 === this._start(e, a))) return;
        }
        switch (s = this.options.step, t = i = this._hasMultipleValues() ? this.values(a) : this.value(), e.keyCode) {
          case o.ui.keyCode.HOME:
            i = this._valueMin();
            break;
          case o.ui.keyCode.END:
            i = this._valueMax();
            break;
          case o.ui.keyCode.PAGE_UP:
            i = this._trimAlignValue(t + (this._valueMax() - this._valueMin()) / this.numPages);
            break;
          case o.ui.keyCode.PAGE_DOWN:
            i = this._trimAlignValue(t - (this._valueMax() - this._valueMin()) / this.numPages);
            break;
          case o.ui.keyCode.UP:
          case o.ui.keyCode.RIGHT:
            if (t === this._valueMax()) return;
            i = this._trimAlignValue(t + s);
            break;
          case o.ui.keyCode.DOWN:
          case o.ui.keyCode.LEFT:
            if (t === this._valueMin()) return;
            i = this._trimAlignValue(t - s);
        }
        this._slide(e, a, i);
      },
      keyup: function keyup(e) {
        var t = o(e.target).data("ui-slider-handle-index");
        this._keySliding && (this._keySliding = !1, this._stop(e, t), this._change(e, t), this._removeClass(o(e.target), null, "ui-state-active"));
      }
    }
  });
});
;
(function ($) {
  "use strict";

  var scroll_top;
  var window_height;
  var window_width;
  var scroll_status = '';
  var lastScrollTop = 0;
  $(window).on('load', function () {
    $(".ct-loader").fadeOut("slow");
    window_width = $(window).width();
    consultio_col_offset();
    consultio_header_sticky();
    consultio_scroll_to_top();
    consultio_quantity_icon();
    consultio_wow_init();
    consultio_mouse_move();
    consultio_header_offset();
    consultio_footer_fixed();
    setTimeout(function () {
      $('body:not(.elementor-editor-active) .ct-slick-slider').css('height', 'auto');
      $('body:not(.elementor-editor-active) .ct-slick-slider').css('overflow', 'visible');
      $('body:not(.elementor-editor-active) .ct-slick-slider').css('opacity', '1');
    }, 100);
  });
  $(window).on('resize', function () {
    window_width = $(window).width();
    consultio_col_offset();
    consultio_header_offset();
    consultio_footer_fixed();
  });
  $(window).on('scroll', function () {
    scroll_top = $(window).scrollTop();
    window_height = $(window).height();
    window_width = $(window).width();
    if (scroll_top < lastScrollTop) {
      scroll_status = 'up';
    } else {
      scroll_status = 'down';
    }
    lastScrollTop = scroll_top;
    consultio_header_sticky();
    consultio_scroll_to_top();
  });
  $(document).on('click', '.h-btn-search', function () {
    $('.ct-modal-search').addClass('open');
    $('body').addClass('ov-hidden');
    setTimeout(function () {
      $('.ct-modal-search .search-field').focus();
    }, 1000);
  });
  $(document).ready(function () {
    var $menu = $('.ct-main-navigation');
    $menu.find('.ct-main-menu li').each(function () {
      var $submenu = $(this).find('> ul.sub-menu, > .children');
      if ($submenu.length == 1) {
        $(this).hover(function () {
          if ($submenu.offset().left + $submenu.width() > $(window).width()) {
            $submenu.addClass('back');
          } else if ($submenu.offset().left < 0) {
            $submenu.addClass('back');
          }
        }, function () {
          $submenu.removeClass('back');
        });
      }
    });
    $(".ct-main-menu.sub-click > li > a").on('click', function () {
      $(this).parent().toggleClass('opened');
    });
    $('body').on('click', '.ct-main-menu.sub-click > li > a', function () {
      return false;
    });
    $('.ct-main-navigation li.menu-item-has-children').append('<span class="ct-menu-toggle far fac-angle-right"></span>');
    $('.ct-menu-toggle').on('click', function () {
      $(this).toggleClass('toggle-open');
      $(this).parent().find('> .sub-menu, > .children').toggleClass('submenu-open');
      $(this).parent().find('> .sub-menu, > .children').slideToggle();
    });
    $(".ct-main-menu li a.is-one-page").on('click', function () {
      $(this).parents('.ct-header-navigation').removeClass('navigation-open');
      $(this).parents('.ct-header-main').find('.btn-nav-mobile').removeClass('opened');
    });
    if ($(window).width() < 1199) {
      $('.ct-main-menu li.menu-item-has-children > a').on("click", function (e) {
        e.preventDefault();
        $(this).parent().find('> .sub-menu, > .children').toggleClass('submenu-open');
        $(this).parent().find('> .sub-menu, > .children').slideToggle();
        $(this).parent().find('> .ct-menu-toggle').toggleClass('toggle-open');
      });
    }
    $('.ct-main-menu-popup li.menu-item-has-children > a').after('<span class="ct-menu-toggle"></span>');
    $('.ct-main-menu-popup .ct-menu-toggle').on('click', function () {
      $(this).toggleClass('toggle-open');
      $(this).parent().find('> .sub-menu, > .children').toggleClass('submenu-open');
      $(this).parent().find('> .sub-menu, > .children').slideToggle();
    });
    $('.ct-menu-popup').on('click', function () {
      $('body').addClass('ov-hidden');
      $(this).parents('body').find('.ct-header-popup-wrap').toggleClass('open');
    });
    $('.ct-menu-close').on('click', function () {
      $('body').removeClass('ov-hidden');
      $(this).parents('body').find('.ct-header-popup-wrap').toggleClass('open');
    });
    $("#ct-menu-mobile .open-menu").on('click', function () {
      $(this).toggleClass('opened');
      $('.ct-header-navigation').toggleClass('navigation-open');
    });
    $(".ct-menu-close").on('click', function () {
      $(this).parents('.header-navigation').removeClass('navigation-open');
      $('.ct-menu-overlay').removeClass('active');
      $('#ct-menu-mobile .open-menu').removeClass('opened');
      $('body').removeClass('ov-hidden');
    });
    $(".ct-menu-overlay").on('click', function () {
      $(this).parents('#header-main').find('.header-navigation').removeClass('navigation-open');
      $(this).removeClass('active');
      $('#ct-menu-mobile .open-menu').removeClass('opened');
      $('.header-navigation').removeClass('navigation-open');
      $('body').removeClass('ov-hidden');
    });
    $('.h-btn-form').click(function (e) {
      e.preventDefault();
      $('.ct-modal-contact-form').removeClass('remove').toggleClass('open');
    });
    $('.ct-close').click(function (e) {
      e.preventDefault();
      $(this).parents('.ct-widget-cart-wrap').removeClass('open');
      $(this).parents('.ct-modal').addClass('remove').removeClass('open');
      $(this).parents('#page').find('.site-overlay').removeClass('open');
      $(this).parents('body').removeClass('ov-hidden');
    });
    $('.ct-hidden-sidebar-overlay, .ct-widget-cart-overlay').click(function (e) {
      e.preventDefault();
      $(this).parent().toggleClass('open');
      $(this).parents('body').removeClass('ov-hidden');
    });
    $('.entry-video iframe').each(function () {
      var v_width = $(this).width();
      v_width = v_width / (16 / 9);
      $(this).attr('height', v_width + 35);
    });
    $('.ct-video-button, .btn-video, .slider-video').magnificPopup({
      type: 'iframe',
      mainClass: 'mfp-fade',
      removalDelay: 160,
      preloader: false,
      fixedContentPos: false
    });
    $('.ct-service-grid1').magnificPopup({
      delegate: 'a.z-view',
      type: 'inline',
      gallery: {
        enabled: false
      },
      mainClass: 'mfp-fade mfp-menu'
    });
    $('.scroll-top, .scroll-top i').click(function () {
      $('html, body').animate({
        scrollTop: 0
      }, 800);
      return false;
    });
    $('.wpcf7-select').parent().addClass('wpcf7-menu');
    var $owl_item = $('.owl-active-click');
    $owl_item.children().each(function (index) {
      $(this).attr('data-position', index);
    });
    $(document).on('click', '.owl-active-click .owl-item > div', function () {
      $owl_item.trigger('to.owl.carousel', $(this).data('position'));
    });
    $('select:not([id*="ui-id-"])').each(function () {
      $(this).niceSelect();
    });
    setTimeout(function () {
      $('.nice-select').on('click', function () {
        $(this).find('.list').toggleClass('open');
      });
    }, 300);
    $('.widget_newsletterwidget, form.newsletter, form.tnp-subscription').each(function () {
      var email_text = $(this).find('.tnp-field-email label').text();
      $(this).find('.tnp-field-email label').remove();
      $(this).find(".tnp-email").each(function (ev) {
        if (!$(this).val()) {
          $(this).attr("placeholder", email_text);
        }
      });
      var firstname_text = $(this).find('.tnp-field-firstname label').text();
      $(this).find('.tnp-field-firstname label').remove();
      $(this).find(".tnp-firstname").each(function (ev) {
        if (!$(this).val()) {
          $(this).attr("placeholder", firstname_text);
        }
      });
      var lastname_text = $(this).find('.tnp-field-lastname label').text();
      $(this).find('.tnp-field-lastname label').remove();
      $(this).find(".tnp-lastname").each(function (ev) {
        if (!$(this).val()) {
          $(this).attr("placeholder", lastname_text);
        }
      });
    });
    $('.bbp-search-form').each(function () {
      var search_text = 'Search...';
      $(this).find("#bbp_search").each(function (ev) {
        if (!$(this).val()) {
          $(this).attr("placeholder", search_text);
        }
      });
    });
    $('.ct-modal-close').on('click', function () {
      $(this).parent().removeClass('open');
      $(this).parents('body').removeClass('ov-hidden');
    });
    $(document).on('click', function (e) {
      if (e.target.className == 'ct-modal ct-modal-search open') $('.ct-modal-search').removeClass('open');
      if (e.target.className == 'ct-hidden-sidebar open') $('.ct-hidden-sidebar').removeClass('open');
    });
    $(".h-btn-sidebar").on('click', function (e) {
      e.preventDefault();
      $('.ct-hidden-sidebar-wrap').toggleClass('open');
      $(this).parents('body').addClass('ov-hidden');
    });
    $(".ct-hidden-close").on('click', function (e) {
      e.preventDefault();
      $(this).parents('.ct-hidden-sidebar-wrap').removeClass('open');
      $(this).parents('body').removeClass('ov-hidden');
    });
    $(".h-btn-cart, .btn-nav-cart, .ct-cart-bar").on('click', function (e) {
      e.preventDefault();
      $('.ct-widget-cart-wrap').toggleClass('open');
      $('.ct-header-navigation').removeClass('navigation-open');
      $('#ct-menu-mobile .open-menu').removeClass('opened');
      $(this).parents('body').addClass('ov-hidden');
    });
    var _year_footer = $(".ct-footer-year"),
      _year_clone = _year_footer.parents(".site").find('.ct-year');
    _year_clone.after(_year_footer.clone());
    _year_footer.remove();
    _year_clone.remove();
    $('.comment-reply a').append('<i class="fa fa-angle-right"></i>');
    $('.ct-navigation-menu1.default a').append('<i class="fac fac-angle-right"></i>');
    setTimeout(function () {
      $('.revslider-initialised').each(function () {
        $(this).find('.ct-slider-nav .slider-nav-right').on('click', function () {
          $(this).parents('.revslider-initialised').find('.tp-rightarrow').trigger('click');
        });
        $(this).find('.ct-slider-nav .slider-nav-left').on('click', function () {
          $(this).parents('.revslider-initialised').find('.tp-leftarrow').trigger('click');
        });
      });
      $('.ct-slider-nav').parents('.revslider-initialised').find('.tparrows').addClass('arrow-hidden');
    }, 300);
    setTimeout(function () {
      $('.input-filled').each(function () {
        var icon_input = $(this).find(".input-icon"),
          control_wrap = $(this).find('.wpcf7-form-control');
        control_wrap.before(icon_input.clone());
        icon_input.remove();
      });
    }, 200);
    $('.ct-pointer-item').each(function () {
      $(this).find('.ct-pointer-btn').on('click', function () {
        $(this).toggleClass('open');
        $(this).parents('.elementor-widget-wrap').find('.ct-pointer-item .ct-pointer-btn').removeClass('open');
        $(this).addClass('open');
      });
    });
    $(".ct-blog-grid-layout1 .grid-item-inner, .ct-blog-carousel-layout1 .grid-item-inner").hover(function () {
      $(this).find('.entry-readmore').slideToggle(300);
      $(this).find('.entry-meta').slideToggle(300);
    }, function () {
      $(this).find('.entry-readmore').slideToggle(300);
      $(this).find('.entry-meta').slideToggle(300);
    });
    $(".ct-fancy-box-layout18").hover(function () {
      $(this).find('.item--button').slideToggle(300);
      $(this).find('.item--description').slideToggle(300);
    }, function () {
      $(this).find('.item--button').slideToggle(300);
      $(this).find('.item--description').slideToggle(300);
    });
    $(".ct-team-carousel1 .item--inner, .ct-team-carousel2 .item--inner, .ct-team-grid4 .item--inner").hover(function () {
      $(this).find('.item--social').slideToggle(300);
    }, function () {
      $(this).find('.item--social').slideToggle(300);
    });
    $(".ct-team-carousel6 .item--inner").hover(function () {
      $(this).find('.item--meta').slideToggle(200);
    }, function () {
      $(this).find('.item--meta').slideToggle(200);
    });
    $(".social-button").on('click', function () {
      $(this).parent().toggleClass('active');
    });
    $(".ct-service-grid6 .grid-item-inner").hover(function () {
      $(this).find('.item-readmore').slideToggle(300);
    }, function () {
      $(this).find('.item-readmore').slideToggle(300);
    });
    $(".ct-service-grid7 .grid-item-inner").hover(function () {
      $(this).find('.item--desc').slideToggle(300);
    }, function () {
      $(this).find('.item--desc').slideToggle(300);
    });
    $(".ct-service-grid10 .grid-item-inner").hover(function () {
      $(this).find('.item--readmore').slideToggle(300);
    }, function () {
      $(this).find('.item--readmore').slideToggle(300);
    });
    $('.ct-fancy-box-grid1').each(function () {
      $(this).find('.item--inner').hover(function () {
        $(this).parents('.elementor-element').find('.item--inner').removeClass('active');
        $(this).addClass('active');
      });
    });
    $('.ct-fancy-box-layout9').each(function () {
      $(this).hover(function () {
        $(this).parents('.elementor-row').find('.ct-fancy-box-layout9').removeClass('active');
        $(this).parents('.elementor-container').find('.ct-fancy-box-layout9').removeClass('active');
        $(this).addClass('active');
      });
    });
    $('.ct-fancy-box-grid1 .item--inner').matchHeight();
    $('.ct-feature-layout1').matchHeight();
    $('.ct-fancy-box-layout4').matchHeight();
    $('.ct-fancy-box-layout5 .ct-fancy-box-inner').matchHeight();
    $('.ct-fancy-box-layout1.style4').matchHeight();
    $('.ct-testimonial-carousel3 .item--description').matchHeight();
    $('.same-height').matchHeight();
    $('.ct-fancy-box-layout14').matchHeight();
    $('.ct-service-grid3 .grid-item-holder').matchHeight();
    $('.ct-service-grid5 .grid-item-inner').matchHeight();
    $(".choose-demo, .ct-demo-bar-close").on('click', function () {
      $(this).parents('.ct-demo-bar').toggleClass('active');
    });
    $('.animate-time').each(function () {
      var eltime = 100;
      var elt_inner = $(this).children().length;
      var _elt = elt_inner - 1;
      $(this).find('> .grid-item > .wow').each(function (index, obj) {
        $(this).css('animation-delay', eltime + 'ms');
        if (_elt === index) {
          eltime = 100;
          _elt = _elt + elt_inner;
        } else {
          eltime = eltime + 80;
        }
      });
    });
    setTimeout(function () {
      $('.elementor-section-wrap > .elementor-element').each(function () {
        var _el_particle = $(this).find(".ct-particle-animate"),
          _row_particle = _el_particle.parents(".elementor-container");
        _row_particle.before(_el_particle.clone());
        _el_particle.remove();
        var _el_bg_animate = $(this).find(".ct-background-animate"),
          _row_bg_animate = _el_bg_animate.parents(".elementor-container");
        _row_bg_animate.before(_el_bg_animate.clone());
        _el_bg_animate.remove();
        var _el_text = $(this).find(".ct-text"),
          _row_text = _el_text.parents(".elementor-container");
        _row_text.before(_el_text.clone());
        _el_text.remove();
      });
    }, 200);
    $('.h9-section-01 > .elementor-container').after('<div class="h9-section-gradient"></div>');
    $('.h9-section-02 > .elementor-container').after('<div class="h9-section-overlay"></div>');
    $('.item--social-btn').on('click', function () {
      $(this).toggleClass('active');
      $(this).parent().toggleClass('active');
    });
    $('.wpcf7-form').each(function () {
      var range = $(this).find('.ct-range-slider');
      var range_value = $(this).find('.ct-range-slider').attr('data-value');
      var range_maxvalue = $(this).find('.ct-range-slider').attr('data-maxvalue');
      var range_currency = $(this).find('.ct-range-slider').attr('data-currency');
      $(this).find(".ct-range-slider").slider({
        range: "min",
        value: range_value,
        min: 1,
        max: range_maxvalue,
        slide: function slide(event, ui) {
          $(this).parent().find(".ct-range-result").val(range_currency + ui.value);
        }
      });
      $(this).find(".ct-range-result").val(range_currency + $(this).find(".ct-range-slider").slider("value"));
    });
    $('.ct-slider-arrow').parents('.elementor-widget-slider_revolution').addClass('hide-arrow');
    $('body:not(.elementor-editor-active) .ct-cover-boxes1 .ct-cover-item').each(function () {
      $(this).hover(function () {
        $(this).parents('.ct-cover-boxes1').find('.ct-cover-item').removeClass('active');
        $(this).addClass('active');
      });
    });
    $('.counter-col-line1').append('<span class="counter-line"></span>');
    $(".ct-pricing-tab-active .ct-pricing-tab-item").on('click', function () {
      $(this).parent().find('.ct-pricing-tab-item').removeClass('active');
      $(this).addClass('active');
    });
    $(".ct-pricing-tab-active .title-tab-monthly").on('click', function () {
      $(this).parents('.ct-pricing-multi').find('.ct-pricing-monthly').removeClass('ct-pricing-hide');
      $(this).parents('.ct-pricing-multi').find('.ct-pricing-year').addClass('ct-pricing-hide');
    });
    $(".ct-pricing-tab-active .title-tab-year").on('click', function () {
      $(this).parents('.ct-pricing-multi').find('.ct-pricing-year').removeClass('ct-pricing-hide');
      $(this).parents('.ct-pricing-multi').find('.ct-pricing-monthly').addClass('ct-pricing-hide');
    });
    $('.case-animate-time > span').each(function () {
      var eltime = 0;
      var elt_inner = $(this).children().length;
      var _elt = elt_inner - 1;
      $(this).find('> .slide-in-container > .wow').each(function (index, obj) {
        $(this).css('transition-delay', eltime + 'ms');
        if (_elt === index) {
          eltime = 0;
          _elt = _elt + elt_inner;
        } else {
          eltime = eltime + 150;
        }
      });
    });
  });
  function consultio_header_offset() {
    if ($('#ct-header-wrap').html() != "") {
      var space_branding = $('.ct-header-branding').offset().left;
      var width_branding = $('.ct-header-branding').outerWidth();
      var offset_branding = space_branding + width_branding;
      $('.ct-header-layout10 .ct-header-branding-bg').css('width', offset_branding + 'px');
      $('.site-h10 .ct-header-offset').css('width', offset_branding + 'px');
      $('.h9-section-overlay').css('left', offset_branding + 'px');
      $('.h9-section-03 > .elementor-container.elementor-column-gap-no > .elementor-row > .elementor-element:nth-child(1)').css('max-width', offset_branding + 'px');
      $('.h9-section-03 > .elementor-container.elementor-column-gap-no > .elementor-row > .elementor-element:nth-child(1)').css('min-width', offset_branding + 'px');
      $('.h9-section-03 > .elementor-container.elementor-column-gap-no > .elementor-element:nth-child(1)').css('max-width', offset_branding + 'px');
      $('.h9-section-03 > .elementor-container.elementor-column-gap-no > .elementor-element:nth-child(1)').css('min-width', offset_branding + 'px');
      $('.h9-section-gradient').css('width', offset_branding + 'px');
    }
  }
  function consultio_header_sticky() {
    var offsetTop = $('#ct-header-wrap').outerHeight();
    var h_header = $('.fixed-height').outerHeight();
    var offsetTopAnimation = offsetTop + 200;
    if ($('#ct-header-wrap').hasClass('is-sticky')) {
      if (scroll_top > offsetTopAnimation) {
        $('#ct-header').addClass('h-fixed');
      } else {
        $('#ct-header').removeClass('h-fixed');
      }
    }
    var h_header_slider = $('.ct-header-slider').outerHeight();
    if ($('#ct-header-wrap').hasClass('is-sticky-offset')) {
      if (scroll_top > h_header_slider) {
        $('#ct-header').addClass('h-fixed');
        $('#ct-header-wrap').addClass('is-sticky-active');
      } else {
        $('#ct-header').removeClass('h-fixed');
        $('#ct-header-wrap').removeClass('is-sticky-active');
      }
      if (scroll_top > 200) {
        $('#ct-header-wrap').removeClass('sub-show-top');
      }
      if (scroll_top == 0) {
        $('#ct-header-wrap').addClass('sub-show-top');
      }
    }
    if (window_width > 1200) {
      $('.fixed-height').css({
        'height': h_header
      });
    }
  }
  function consultio_col_offset() {
    setTimeout(function () {
      var w_vc_row_lg_medium = ($('#content').width() - 1200) / 2;
      var w_vc_row_lg_full_medium = ($('#content section.elementor-element section.elementor-element').width() - 1200) / 2;
      if (window_width > 1200) {
        $('body:not(.rtl) .col-offset-left').parents('.elementor-container').css('padding-left', w_vc_row_lg_medium + 'px');
        $('body:not(.rtl) .col-offset-right').parents('.elementor-container').css('padding-right', w_vc_row_lg_medium + 'px');
        $('.rtl .col-offset-left').parents('.elementor-container').css('padding-right', w_vc_row_lg_medium + 'px');
        $('.rtl .col-offset-right').parents('.elementor-container').css('padding-left', w_vc_row_lg_medium + 'px');
        $('body:not(.rtl) .ct-row-full-width .col-offset-left').parents('.elementor-container').css('padding-left', w_vc_row_lg_full_medium + 'px');
        $('body:not(.rtl) .ct-row-full-width .col-offset-right').parents('.elementor-container').css('padding-right', w_vc_row_lg_full_medium + 'px');
        $('.rtl .ct-row-full-width .col-offset-left').parents('.elementor-container').css('padding-right', w_vc_row_lg_full_medium + 'px');
        $('.rtl .ct-row-full-width .col-offset-right').parents('.elementor-container').css('padding-left', w_vc_row_lg_full_medium + 'px');
        $('body:not(.rtl) .h9-section-03 .col-offset-right > .elementor-column-wrap > .elementor-widget-wrap').css('padding-right', w_vc_row_lg_medium + 'px');
        if (window_width > 1200) {
          $('body:not(.rtl) .ct-column-offset-left > .elementor-column-wrap > .elementor-widget-wrap').css('padding-left', w_vc_row_lg_medium + 'px');
          $('body:not(.rtl) .ct-column-offset-right > .elementor-column-wrap > .elementor-widget-wrap').css('padding-right', w_vc_row_lg_medium + 'px');
          $('.rtl .ct-column-offset-left > .elementor-column-wrap > .elementor-widget-wrap').css('padding-right', w_vc_row_lg_medium + 'px');
          $('.rtl .ct-column-offset-right > .elementor-column-wrap > .elementor-widget-wrap').css('padding-left', w_vc_row_lg_medium + 'px');
        }
      }
    }, 10);
  }
  function consultio_scroll_to_top() {
    if (scroll_top < window_height) {
      $('.scroll-top').addClass('off').removeClass('on');
    }
    if (scroll_top > window_height) {
      $('.scroll-top').addClass('on').removeClass('off');
    }
  }
  function consultio_wow_init() {
    var wow = new WOW({
      boxClass: 'wow',
      animateClass: 'animated',
      offset: 0,
      mobile: true,
      live: true,
      callback: function callback(box) {},
      scrollContainer: null,
      resetAnimation: true
    });
    wow.init();
  }
  function consultio_mouse_move() {
    var follower, init, mouseX, mouseY, positionElement, timer;
    follower = document.getElementById('ct-mouse-move');
    mouseX = function mouseX(event) {
      return event.clientX;
    };
    mouseY = function mouseY(event) {
      return event.clientY;
    };
    positionElement = function positionElement(event) {
      var mouse;
      mouse = {
        x: mouseX(event),
        y: mouseY(event)
      };
      follower.style.top = mouse.y + 'px';
      return follower.style.left = mouse.x + 'px';
    };
    timer = false;
    window.onmousemove = init = function init(event) {
      var _event;
      _event = event;
      return timer = setTimeout(function () {
        return positionElement(_event);
      }, 0);
    };
  }
  function consultio_quantity_icon() {
    $('#content .quantity').append('<span class="quantity-icon"><i class="quantity-down fa fa-sort-desc"></i><i class="quantity-up fa fa-sort-asc"></i></span>');
    $('.quantity-up').on('click', function () {
      $(this).parents('.quantity').find('input[type="number"]').get(0).stepUp();
    });
    $('.quantity-down').on('click', function () {
      $(this).parents('.quantity').find('input[type="number"]').get(0).stepDown();
    });
    $('.woocommerce-cart-form .actions .button').removeAttr('disabled');
  }
  $(document).ajaxComplete(function () {
    consultio_quantity_icon();
  });
  function consultio_footer_fixed() {
    setTimeout(function () {
      var h_footer = $('.fixed-footer .site-footer-custom').outerHeight() - 1;
      $('.fixed-footer .site-content').css('margin-bottom', h_footer + 'px');
    }, 300);
  }
})(jQuery);
/*! This file is auto-generated */
!function (c, d) {
  "use strict";

  var e = !1,
    n = !1;
  if (d.querySelector) if (c.addEventListener) e = !0;
  if (c.wp = c.wp || {}, !c.wp.receiveEmbedMessage) if (c.wp.receiveEmbedMessage = function (e) {
    var t = e.data;
    if (t) if (t.secret || t.message || t.value) if (!/[^a-zA-Z0-9]/.test(t.secret)) {
      for (var r, a, i, s = d.querySelectorAll('iframe[data-secret="' + t.secret + '"]'), n = d.querySelectorAll('blockquote[data-secret="' + t.secret + '"]'), o = 0; o < n.length; o++) n[o].style.display = "none";
      for (o = 0; o < s.length; o++) if (r = s[o], e.source === r.contentWindow) {
        if (r.removeAttribute("style"), "height" === t.message) {
          if (1e3 < (i = parseInt(t.value, 10))) i = 1e3;else if (~~i < 200) i = 200;
          r.height = i;
        }
        if ("link" === t.message) if (a = d.createElement("a"), i = d.createElement("a"), a.href = r.getAttribute("src"), i.href = t.value, i.host === a.host) if (d.activeElement === r) c.top.location.href = t.value;
      }
    }
  }, e) c.addEventListener("message", c.wp.receiveEmbedMessage, !1), d.addEventListener("DOMContentLoaded", t, !1), c.addEventListener("load", t, !1);
  function t() {
    if (!n) {
      n = !0;
      for (var e, t, r = -1 !== navigator.appVersion.indexOf("MSIE 10"), a = !!navigator.userAgent.match(/Trident.*rv:11\./), i = d.querySelectorAll("iframe.wp-embedded-content"), s = 0; s < i.length; s++) {
        if (!(e = i[s]).getAttribute("data-secret")) t = Math.random().toString(36).substr(2, 10), e.src += "#?secret=" + t, e.setAttribute("data-secret", t);
        if (r || a) (t = e.cloneNode(!0)).removeAttribute("security"), e.parentNode.replaceChild(t, e);
      }
    }
  }
}(window, document);
!function (t) {
  "use strict";

  if ("function" == typeof define && define.amd) define(["jquery"], t);else if ("object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports))) t(require("jquery"));else {
    if ("undefined" == typeof jQuery) throw "jquery-numerator requires jQuery to be loaded first";
    t(jQuery);
  }
}(function (t) {
  function e(e, s) {
    this.element = e, this.settings = t.extend({}, i, s), this._defaults = i, this._name = n, this.init();
  }
  var n = "numerator",
    i = {
      easing: "swing",
      duration: 500,
      delimiter: void 0,
      rounding: 0,
      toValue: void 0,
      fromValue: void 0,
      queue: !1,
      onStart: function onStart() {},
      onStep: function onStep() {},
      onProgress: function onProgress() {},
      onComplete: function onComplete() {}
    };
  e.prototype = {
    init: function init() {
      this.parseElement(), this.setValue();
    },
    parseElement: function parseElement() {
      var e = t.trim(t(this.element).text());
      this.settings.fromValue = this.settings.fromValue || this.format(e);
    },
    setValue: function setValue() {
      var e = this;
      t({
        value: e.settings.fromValue
      }).animate({
        value: e.settings.toValue
      }, {
        duration: parseInt(e.settings.duration, 10),
        easing: e.settings.easing,
        start: e.settings.onStart,
        step: function step(n, i) {
          t(e.element).text(e.format(n)), e.settings.onStep(n, i);
        },
        progress: e.settings.onProgress,
        complete: e.settings.onComplete
      });
    },
    format: function format(t) {
      var e = this;
      return t = parseInt(this.settings.rounding) < 1 ? parseInt(t, 10) : parseFloat(t).toFixed(parseInt(this.settings.rounding)), e.settings.delimiter ? this.delimit(t) : t;
    },
    delimit: function delimit(t) {
      var e = this;
      if (t = t.toString(), e.settings.rounding && parseInt(e.settings.rounding, 10) > 0) {
        var n = t.substring(t.length - (e.settings.rounding + 1), t.length),
          i = t.substring(0, t.length - (e.settings.rounding + 1));
        return e.addDelimiter(i) + n;
      }
      return e.addDelimiter(t);
    },
    addDelimiter: function addDelimiter(t) {
      return t.toString().replace(/\B(?=(\d{3})+(?!\d))/g, this.settings.delimiter);
    }
  }, t.fn[n] = function (i) {
    return this.each(function () {
      t.data(this, "plugin_" + n) && t.data(this, "plugin_" + n, null), t.data(this, "plugin_" + n, new e(this, i));
    });
  };
});
(function ($) {
  var WidgetCTCounterHandler = function WidgetCTCounterHandler($scope, $) {
    elementorFrontend.waypoint($scope.find('.ct-counter-number-value'), function () {
      var $number = $(this),
        data = $number.data();
      var decimalDigits = data.toValue.toString().match(/\.(.*)/);
      if (decimalDigits) {
        data.rounding = decimalDigits[1].length;
      }
      $number.numerator(data);
    }, {
      offset: '120%',
      triggerOnce: true
    });
  };
  $(window).on('elementor/frontend/init', function () {
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_counter.default', WidgetCTCounterHandler);
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_statistics.default', WidgetCTCounterHandler);
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_banner.default', WidgetCTCounterHandler);
  });
})(jQuery);
(function ($) {
  var WidgetCTIlineHandler = function WidgetCTIlineHandler($scope, $) {
    $('.elementor-section-wrap > .elementor-element').each(function () {
      var _el_angle = $(this).find(".ct-angle"),
        _el_angle_remove = $(this).find(".elementor-column .ct-angle"),
        _row_angle = _el_angle.parents(".elementor-container");
      _row_angle.before(_el_angle.clone());
      _el_angle_remove.remove();
    });
  };
  $(window).on('elementor/frontend/init', function () {
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_angle.default', WidgetCTIlineHandler);
  });
})(jQuery);
!function (i) {
  "use strict";

  "function" == typeof define && define.amd ? define(["jquery"], i) : "undefined" != typeof exports ? module.exports = i(require("jquery")) : i(jQuery);
}(function (i) {
  "use strict";

  var e = window.Slick || {};
  (e = function () {
    var e = 0;
    return function (t, o) {
      var s,
        n = this;
      n.defaults = {
        accessibility: !0,
        adaptiveHeight: !1,
        appendArrows: i(t),
        appendDots: i(t),
        arrows: !0,
        asNavFor: null,
        prevArrow: '<button class="slick-prev" aria-label="Previous" type="button">Previous</button>',
        nextArrow: '<button class="slick-next" aria-label="Next" type="button">Next</button>',
        autoplay: !1,
        autoplaySpeed: 3e3,
        centerMode: !1,
        centerPadding: "50px",
        cssEase: "ease",
        customPaging: function customPaging(e, t) {
          return i('<button type="button" />').text(t + 1);
        },
        dots: !1,
        dotsClass: "slick-dots",
        draggable: !0,
        easing: "linear",
        edgeFriction: .35,
        fade: !1,
        focusOnSelect: !1,
        focusOnChange: !1,
        infinite: !0,
        initialSlide: 0,
        lazyLoad: "ondemand",
        mobileFirst: !1,
        pauseOnHover: !0,
        pauseOnFocus: !0,
        pauseOnDotsHover: !1,
        respondTo: "window",
        responsive: null,
        rows: 1,
        rtl: !1,
        slide: "",
        slidesPerRow: 1,
        slidesToShow: 1,
        slidesToScroll: 1,
        speed: 500,
        swipe: !0,
        swipeToSlide: !1,
        touchMove: !0,
        touchThreshold: 5,
        useCSS: !0,
        useTransform: !0,
        variableWidth: !1,
        vertical: !1,
        verticalSwiping: !1,
        waitForAnimate: !0,
        zIndex: 1e3
      }, n.initials = {
        animating: !1,
        dragging: !1,
        autoPlayTimer: null,
        currentDirection: 0,
        currentLeft: null,
        currentSlide: 0,
        direction: 1,
        $dots: null,
        listWidth: null,
        listHeight: null,
        loadIndex: 0,
        $nextArrow: null,
        $prevArrow: null,
        scrolling: !1,
        slideCount: null,
        slideWidth: null,
        $slideTrack: null,
        $slides: null,
        sliding: !1,
        slideOffset: 0,
        swipeLeft: null,
        swiping: !1,
        $list: null,
        touchObject: {},
        transformsEnabled: !1,
        unslicked: !1
      }, i.extend(n, n.initials), n.activeBreakpoint = null, n.animType = null, n.animProp = null, n.breakpoints = [], n.breakpointSettings = [], n.cssTransitions = !1, n.focussed = !1, n.interrupted = !1, n.hidden = "hidden", n.paused = !0, n.positionProp = null, n.respondTo = null, n.rowCount = 1, n.shouldClick = !0, n.$slider = i(t), n.$slidesCache = null, n.transformType = null, n.transitionType = null, n.visibilityChange = "visibilitychange", n.windowWidth = 0, n.windowTimer = null, s = i(t).data("slick") || {}, n.options = i.extend({}, n.defaults, o, s), n.currentSlide = n.options.initialSlide, n.originalSettings = n.options, void 0 !== document.mozHidden ? (n.hidden = "mozHidden", n.visibilityChange = "mozvisibilitychange") : void 0 !== document.webkitHidden && (n.hidden = "webkitHidden", n.visibilityChange = "webkitvisibilitychange"), n.autoPlay = i.proxy(n.autoPlay, n), n.autoPlayClear = i.proxy(n.autoPlayClear, n), n.autoPlayIterator = i.proxy(n.autoPlayIterator, n), n.changeSlide = i.proxy(n.changeSlide, n), n.clickHandler = i.proxy(n.clickHandler, n), n.selectHandler = i.proxy(n.selectHandler, n), n.setPosition = i.proxy(n.setPosition, n), n.swipeHandler = i.proxy(n.swipeHandler, n), n.dragHandler = i.proxy(n.dragHandler, n), n.keyHandler = i.proxy(n.keyHandler, n), n.instanceUid = e++, n.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/, n.registerBreakpoints(), n.init(!0);
    };
  }()).prototype.activateADA = function () {
    this.$slideTrack.find(".slick-active").attr({
      "aria-hidden": "false"
    }).find("a, input, button, select").attr({
      tabindex: "0"
    });
  }, e.prototype.addSlide = e.prototype.slickAdd = function (e, t, o) {
    var s = this;
    if ("boolean" == typeof t) o = t, t = null;else if (t < 0 || t >= s.slideCount) return !1;
    s.unload(), "number" == typeof t ? 0 === t && 0 === s.$slides.length ? i(e).appendTo(s.$slideTrack) : o ? i(e).insertBefore(s.$slides.eq(t)) : i(e).insertAfter(s.$slides.eq(t)) : !0 === o ? i(e).prependTo(s.$slideTrack) : i(e).appendTo(s.$slideTrack), s.$slides = s.$slideTrack.children(this.options.slide), s.$slideTrack.children(this.options.slide).detach(), s.$slideTrack.append(s.$slides), s.$slides.each(function (e, t) {
      i(t).attr("data-slick-index", e);
    }), s.$slidesCache = s.$slides, s.reinit();
  }, e.prototype.animateHeight = function () {
    var i = this;
    if (1 === i.options.slidesToShow && !0 === i.options.adaptiveHeight && !1 === i.options.vertical) {
      var e = i.$slides.eq(i.currentSlide).outerHeight(!0);
      i.$list.animate({
        height: e
      }, i.options.speed);
    }
  }, e.prototype.animateSlide = function (e, t) {
    var o = {},
      s = this;
    s.animateHeight(), !0 === s.options.rtl && !1 === s.options.vertical && (e = -e), !1 === s.transformsEnabled ? !1 === s.options.vertical ? s.$slideTrack.animate({
      left: e
    }, s.options.speed, s.options.easing, t) : s.$slideTrack.animate({
      top: e
    }, s.options.speed, s.options.easing, t) : !1 === s.cssTransitions ? (!0 === s.options.rtl && (s.currentLeft = -s.currentLeft), i({
      animStart: s.currentLeft
    }).animate({
      animStart: e
    }, {
      duration: s.options.speed,
      easing: s.options.easing,
      step: function step(i) {
        i = Math.ceil(i), !1 === s.options.vertical ? (o[s.animType] = "translate(" + i + "px, 0px)", s.$slideTrack.css(o)) : (o[s.animType] = "translate(0px," + i + "px)", s.$slideTrack.css(o));
      },
      complete: function complete() {
        t && t.call();
      }
    })) : (s.applyTransition(), e = Math.ceil(e), !1 === s.options.vertical ? o[s.animType] = "translate3d(" + e + "px, 0px, 0px)" : o[s.animType] = "translate3d(0px," + e + "px, 0px)", s.$slideTrack.css(o), t && setTimeout(function () {
      s.disableTransition(), t.call();
    }, s.options.speed));
  }, e.prototype.getNavTarget = function () {
    var e = this,
      t = e.options.asNavFor;
    return t && null !== t && (t = i(t).not(e.$slider)), t;
  }, e.prototype.asNavFor = function (e) {
    var t = this.getNavTarget();
    null !== t && "object" == _typeof(t) && t.each(function () {
      var t = i(this).slick("getSlick");
      t.unslicked || t.slideHandler(e, !0);
    });
  }, e.prototype.applyTransition = function (i) {
    var e = this,
      t = {};
    !1 === e.options.fade ? t[e.transitionType] = e.transformType + " " + e.options.speed + "ms " + e.options.cssEase : t[e.transitionType] = "opacity " + e.options.speed + "ms " + e.options.cssEase, !1 === e.options.fade ? e.$slideTrack.css(t) : e.$slides.eq(i).css(t);
  }, e.prototype.autoPlay = function () {
    var i = this;
    i.autoPlayClear(), i.slideCount > i.options.slidesToShow && (i.autoPlayTimer = setInterval(i.autoPlayIterator, i.options.autoplaySpeed));
  }, e.prototype.autoPlayClear = function () {
    var i = this;
    i.autoPlayTimer && clearInterval(i.autoPlayTimer);
  }, e.prototype.autoPlayIterator = function () {
    var i = this,
      e = i.currentSlide + i.options.slidesToScroll;
    i.paused || i.interrupted || i.focussed || (!1 === i.options.infinite && (1 === i.direction && i.currentSlide + 1 === i.slideCount - 1 ? i.direction = 0 : 0 === i.direction && (e = i.currentSlide - i.options.slidesToScroll, i.currentSlide - 1 == 0 && (i.direction = 1))), i.slideHandler(e));
  }, e.prototype.buildArrows = function () {
    var e = this;
    !0 === e.options.arrows && (e.$prevArrow = i(e.options.prevArrow).addClass("slick-arrow"), e.$nextArrow = i(e.options.nextArrow).addClass("slick-arrow"), e.slideCount > e.options.slidesToShow ? (e.$prevArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"), e.$nextArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"), e.htmlExpr.test(e.options.prevArrow) && e.$prevArrow.prependTo(e.options.appendArrows), e.htmlExpr.test(e.options.nextArrow) && e.$nextArrow.appendTo(e.options.appendArrows), !0 !== e.options.infinite && e.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true")) : e.$prevArrow.add(e.$nextArrow).addClass("slick-hidden").attr({
      "aria-disabled": "true",
      tabindex: "-1"
    }));
  }, e.prototype.buildDots = function () {
    var e,
      t,
      o = this;
    if (!0 === o.options.dots) {
      for (o.$slider.addClass("slick-dotted"), t = i("<ul />").addClass(o.options.dotsClass), e = 0; e <= o.getDotCount(); e += 1) t.append(i("<li />").append(o.options.customPaging.call(this, o, e)));
      o.$dots = t.appendTo(o.options.appendDots), o.$dots.find("li").first().addClass("slick-active");
    }
  }, e.prototype.buildOut = function () {
    var e = this;
    e.$slides = e.$slider.children(e.options.slide + ":not(.slick-cloned)").addClass("slick-slide"), e.slideCount = e.$slides.length, e.$slides.each(function (e, t) {
      i(t).attr("data-slick-index", e).data("originalStyling", i(t).attr("style") || "");
    }), e.$slider.addClass("slick-slider"), e.$slideTrack = 0 === e.slideCount ? i('<div class="slick-track"/>').appendTo(e.$slider) : e.$slides.wrapAll('<div class="slick-track"/>').parent(), e.$list = e.$slideTrack.wrap('<div class="slick-list"/>').parent(), e.$slideTrack.css("opacity", 0), !0 !== e.options.centerMode && !0 !== e.options.swipeToSlide || (e.options.slidesToScroll = 1), i("img[data-lazy]", e.$slider).not("[src]").addClass("slick-loading"), e.setupInfinite(), e.buildArrows(), e.buildDots(), e.updateDots(), e.setSlideClasses("number" == typeof e.currentSlide ? e.currentSlide : 0), !0 === e.options.draggable && e.$list.addClass("draggable");
  }, e.prototype.buildRows = function () {
    var i,
      e,
      t,
      o,
      s,
      n,
      r,
      l = this;
    if (o = document.createDocumentFragment(), n = l.$slider.children(), l.options.rows > 1) {
      for (r = l.options.slidesPerRow * l.options.rows, s = Math.ceil(n.length / r), i = 0; i < s; i++) {
        var d = document.createElement("div");
        for (e = 0; e < l.options.rows; e++) {
          var a = document.createElement("div");
          for (t = 0; t < l.options.slidesPerRow; t++) {
            var c = i * r + (e * l.options.slidesPerRow + t);
            n.get(c) && a.appendChild(n.get(c));
          }
          d.appendChild(a);
        }
        o.appendChild(d);
      }
      l.$slider.empty().append(o), l.$slider.children().children().children().css({
        width: 100 / l.options.slidesPerRow + "%",
        display: "inline-block"
      });
    }
  }, e.prototype.checkResponsive = function (e, t) {
    var o,
      s,
      n,
      r = this,
      l = !1,
      d = r.$slider.width(),
      a = window.innerWidth || i(window).width();
    if ("window" === r.respondTo ? n = a : "slider" === r.respondTo ? n = d : "min" === r.respondTo && (n = Math.min(a, d)), r.options.responsive && r.options.responsive.length && null !== r.options.responsive) {
      s = null;
      for (o in r.breakpoints) r.breakpoints.hasOwnProperty(o) && (!1 === r.originalSettings.mobileFirst ? n < r.breakpoints[o] && (s = r.breakpoints[o]) : n > r.breakpoints[o] && (s = r.breakpoints[o]));
      null !== s ? null !== r.activeBreakpoint ? (s !== r.activeBreakpoint || t) && (r.activeBreakpoint = s, "unslick" === r.breakpointSettings[s] ? r.unslick(s) : (r.options = i.extend({}, r.originalSettings, r.breakpointSettings[s]), !0 === e && (r.currentSlide = r.options.initialSlide), r.refresh(e)), l = s) : (r.activeBreakpoint = s, "unslick" === r.breakpointSettings[s] ? r.unslick(s) : (r.options = i.extend({}, r.originalSettings, r.breakpointSettings[s]), !0 === e && (r.currentSlide = r.options.initialSlide), r.refresh(e)), l = s) : null !== r.activeBreakpoint && (r.activeBreakpoint = null, r.options = r.originalSettings, !0 === e && (r.currentSlide = r.options.initialSlide), r.refresh(e), l = s), e || !1 === l || r.$slider.trigger("breakpoint", [r, l]);
    }
  }, e.prototype.changeSlide = function (e, t) {
    var o,
      s,
      n,
      r = this,
      l = i(e.currentTarget);
    switch (l.is("a") && e.preventDefault(), l.is("li") || (l = l.closest("li")), n = r.slideCount % r.options.slidesToScroll != 0, o = n ? 0 : (r.slideCount - r.currentSlide) % r.options.slidesToScroll, e.data.message) {
      case "previous":
        s = 0 === o ? r.options.slidesToScroll : r.options.slidesToShow - o, r.slideCount > r.options.slidesToShow && r.slideHandler(r.currentSlide - s, !1, t);
        break;
      case "next":
        s = 0 === o ? r.options.slidesToScroll : o, r.slideCount > r.options.slidesToShow && r.slideHandler(r.currentSlide + s, !1, t);
        break;
      case "index":
        var d = 0 === e.data.index ? 0 : e.data.index || l.index() * r.options.slidesToScroll;
        r.slideHandler(r.checkNavigable(d), !1, t), l.children().trigger("focus");
        break;
      default:
        return;
    }
  }, e.prototype.checkNavigable = function (i) {
    var e, t;
    if (e = this.getNavigableIndexes(), t = 0, i > e[e.length - 1]) i = e[e.length - 1];else for (var o in e) {
      if (i < e[o]) {
        i = t;
        break;
      }
      t = e[o];
    }
    return i;
  }, e.prototype.cleanUpEvents = function () {
    var e = this;
    e.options.dots && null !== e.$dots && (i("li", e.$dots).off("click.slick", e.changeSlide).off("mouseenter.slick", i.proxy(e.interrupt, e, !0)).off("mouseleave.slick", i.proxy(e.interrupt, e, !1)), !0 === e.options.accessibility && e.$dots.off("keydown.slick", e.keyHandler)), e.$slider.off("focus.slick blur.slick"), !0 === e.options.arrows && e.slideCount > e.options.slidesToShow && (e.$prevArrow && e.$prevArrow.off("click.slick", e.changeSlide), e.$nextArrow && e.$nextArrow.off("click.slick", e.changeSlide), !0 === e.options.accessibility && (e.$prevArrow && e.$prevArrow.off("keydown.slick", e.keyHandler), e.$nextArrow && e.$nextArrow.off("keydown.slick", e.keyHandler))), e.$list.off("touchstart.slick mousedown.slick", e.swipeHandler), e.$list.off("touchmove.slick mousemove.slick", e.swipeHandler), e.$list.off("touchend.slick mouseup.slick", e.swipeHandler), e.$list.off("touchcancel.slick mouseleave.slick", e.swipeHandler), e.$list.off("click.slick", e.clickHandler), i(document).off(e.visibilityChange, e.visibility), e.cleanUpSlideEvents(), !0 === e.options.accessibility && e.$list.off("keydown.slick", e.keyHandler), !0 === e.options.focusOnSelect && i(e.$slideTrack).children().off("click.slick", e.selectHandler), i(window).off("orientationchange.slick.slick-" + e.instanceUid, e.orientationChange), i(window).off("resize.slick.slick-" + e.instanceUid, e.resize), i("[draggable!=true]", e.$slideTrack).off("dragstart", e.preventDefault), i(window).off("load.slick.slick-" + e.instanceUid, e.setPosition);
  }, e.prototype.cleanUpSlideEvents = function () {
    var e = this;
    e.$list.off("mouseenter.slick", i.proxy(e.interrupt, e, !0)), e.$list.off("mouseleave.slick", i.proxy(e.interrupt, e, !1));
  }, e.prototype.cleanUpRows = function () {
    var i,
      e = this;
    e.options.rows > 1 && ((i = e.$slides.children().children()).removeAttr("style"), e.$slider.empty().append(i));
  }, e.prototype.clickHandler = function (i) {
    !1 === this.shouldClick && (i.stopImmediatePropagation(), i.stopPropagation(), i.preventDefault());
  }, e.prototype.destroy = function (e) {
    var t = this;
    t.autoPlayClear(), t.touchObject = {}, t.cleanUpEvents(), i(".slick-cloned", t.$slider).detach(), t.$dots && t.$dots.remove(), t.$prevArrow && t.$prevArrow.length && (t.$prevArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""), t.htmlExpr.test(t.options.prevArrow) && t.$prevArrow.remove()), t.$nextArrow && t.$nextArrow.length && (t.$nextArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""), t.htmlExpr.test(t.options.nextArrow) && t.$nextArrow.remove()), t.$slides && (t.$slides.removeClass("slick-slide slick-active slick-center slick-visible slick-current").removeAttr("aria-hidden").removeAttr("data-slick-index").each(function () {
      i(this).attr("style", i(this).data("originalStyling"));
    }), t.$slideTrack.children(this.options.slide).detach(), t.$slideTrack.detach(), t.$list.detach(), t.$slider.append(t.$slides)), t.cleanUpRows(), t.$slider.removeClass("slick-slider"), t.$slider.removeClass("slick-initialized"), t.$slider.removeClass("slick-dotted"), t.unslicked = !0, e || t.$slider.trigger("destroy", [t]);
  }, e.prototype.disableTransition = function (i) {
    var e = this,
      t = {};
    t[e.transitionType] = "", !1 === e.options.fade ? e.$slideTrack.css(t) : e.$slides.eq(i).css(t);
  }, e.prototype.fadeSlide = function (i, e) {
    var t = this;
    !1 === t.cssTransitions ? (t.$slides.eq(i).css({
      zIndex: t.options.zIndex
    }), t.$slides.eq(i).animate({
      opacity: 1
    }, t.options.speed, t.options.easing, e)) : (t.applyTransition(i), t.$slides.eq(i).css({
      opacity: 1,
      zIndex: t.options.zIndex
    }), e && setTimeout(function () {
      t.disableTransition(i), e.call();
    }, t.options.speed));
  }, e.prototype.fadeSlideOut = function (i) {
    var e = this;
    !1 === e.cssTransitions ? e.$slides.eq(i).animate({
      opacity: 0,
      zIndex: e.options.zIndex - 2
    }, e.options.speed, e.options.easing) : (e.applyTransition(i), e.$slides.eq(i).css({
      opacity: 0,
      zIndex: e.options.zIndex - 2
    }));
  }, e.prototype.filterSlides = e.prototype.slickFilter = function (i) {
    var e = this;
    null !== i && (e.$slidesCache = e.$slides, e.unload(), e.$slideTrack.children(this.options.slide).detach(), e.$slidesCache.filter(i).appendTo(e.$slideTrack), e.reinit());
  }, e.prototype.focusHandler = function () {
    var e = this;
    e.$slider.off("focus.slick blur.slick").on("focus.slick blur.slick", "*", function (t) {
      t.stopImmediatePropagation();
      var o = i(this);
      setTimeout(function () {
        e.options.pauseOnFocus && (e.focussed = o.is(":focus"), e.autoPlay());
      }, 0);
    });
  }, e.prototype.getCurrent = e.prototype.slickCurrentSlide = function () {
    return this.currentSlide;
  }, e.prototype.getDotCount = function () {
    var i = this,
      e = 0,
      t = 0,
      o = 0;
    if (!0 === i.options.infinite) {
      if (i.slideCount <= i.options.slidesToShow) ++o;else for (; e < i.slideCount;) ++o, e = t + i.options.slidesToScroll, t += i.options.slidesToScroll <= i.options.slidesToShow ? i.options.slidesToScroll : i.options.slidesToShow;
    } else if (!0 === i.options.centerMode) o = i.slideCount;else if (i.options.asNavFor) for (; e < i.slideCount;) ++o, e = t + i.options.slidesToScroll, t += i.options.slidesToScroll <= i.options.slidesToShow ? i.options.slidesToScroll : i.options.slidesToShow;else o = 1 + Math.ceil((i.slideCount - i.options.slidesToShow) / i.options.slidesToScroll);
    return o - 1;
  }, e.prototype.getLeft = function (i) {
    var e,
      t,
      o,
      s,
      n = this,
      r = 0;
    return n.slideOffset = 0, t = n.$slides.first().outerHeight(!0), !0 === n.options.infinite ? (n.slideCount > n.options.slidesToShow && (n.slideOffset = n.slideWidth * n.options.slidesToShow * -1, s = -1, !0 === n.options.vertical && !0 === n.options.centerMode && (2 === n.options.slidesToShow ? s = -1.5 : 1 === n.options.slidesToShow && (s = -2)), r = t * n.options.slidesToShow * s), n.slideCount % n.options.slidesToScroll != 0 && i + n.options.slidesToScroll > n.slideCount && n.slideCount > n.options.slidesToShow && (i > n.slideCount ? (n.slideOffset = (n.options.slidesToShow - (i - n.slideCount)) * n.slideWidth * -1, r = (n.options.slidesToShow - (i - n.slideCount)) * t * -1) : (n.slideOffset = n.slideCount % n.options.slidesToScroll * n.slideWidth * -1, r = n.slideCount % n.options.slidesToScroll * t * -1))) : i + n.options.slidesToShow > n.slideCount && (n.slideOffset = (i + n.options.slidesToShow - n.slideCount) * n.slideWidth, r = (i + n.options.slidesToShow - n.slideCount) * t), n.slideCount <= n.options.slidesToShow && (n.slideOffset = 0, r = 0), !0 === n.options.centerMode && n.slideCount <= n.options.slidesToShow ? n.slideOffset = n.slideWidth * Math.floor(n.options.slidesToShow) / 2 - n.slideWidth * n.slideCount / 2 : !0 === n.options.centerMode && !0 === n.options.infinite ? n.slideOffset += n.slideWidth * Math.floor(n.options.slidesToShow / 2) - n.slideWidth : !0 === n.options.centerMode && (n.slideOffset = 0, n.slideOffset += n.slideWidth * Math.floor(n.options.slidesToShow / 2)), e = !1 === n.options.vertical ? i * n.slideWidth * -1 + n.slideOffset : i * t * -1 + r, !0 === n.options.variableWidth && (o = n.slideCount <= n.options.slidesToShow || !1 === n.options.infinite ? n.$slideTrack.children(".slick-slide").eq(i) : n.$slideTrack.children(".slick-slide").eq(i + n.options.slidesToShow), e = !0 === n.options.rtl ? o[0] ? -1 * (n.$slideTrack.width() - o[0].offsetLeft - o.width()) : 0 : o[0] ? -1 * o[0].offsetLeft : 0, !0 === n.options.centerMode && (o = n.slideCount <= n.options.slidesToShow || !1 === n.options.infinite ? n.$slideTrack.children(".slick-slide").eq(i) : n.$slideTrack.children(".slick-slide").eq(i + n.options.slidesToShow + 1), e = !0 === n.options.rtl ? o[0] ? -1 * (n.$slideTrack.width() - o[0].offsetLeft - o.width()) : 0 : o[0] ? -1 * o[0].offsetLeft : 0, e += (n.$list.width() - o.outerWidth()) / 2)), e;
  }, e.prototype.getOption = e.prototype.slickGetOption = function (i) {
    return this.options[i];
  }, e.prototype.getNavigableIndexes = function () {
    var i,
      e = this,
      t = 0,
      o = 0,
      s = [];
    for (!1 === e.options.infinite ? i = e.slideCount : (t = -1 * e.options.slidesToScroll, o = -1 * e.options.slidesToScroll, i = 2 * e.slideCount); t < i;) s.push(t), t = o + e.options.slidesToScroll, o += e.options.slidesToScroll <= e.options.slidesToShow ? e.options.slidesToScroll : e.options.slidesToShow;
    return s;
  }, e.prototype.getSlick = function () {
    return this;
  }, e.prototype.getSlideCount = function () {
    var e,
      t,
      o = this;
    return t = !0 === o.options.centerMode ? o.slideWidth * Math.floor(o.options.slidesToShow / 2) : 0, !0 === o.options.swipeToSlide ? (o.$slideTrack.find(".slick-slide").each(function (s, n) {
      if (n.offsetLeft - t + i(n).outerWidth() / 2 > -1 * o.swipeLeft) return e = n, !1;
    }), Math.abs(i(e).attr("data-slick-index") - o.currentSlide) || 1) : o.options.slidesToScroll;
  }, e.prototype.goTo = e.prototype.slickGoTo = function (i, e) {
    this.changeSlide({
      data: {
        message: "index",
        index: parseInt(i)
      }
    }, e);
  }, e.prototype.init = function (e) {
    var t = this;
    i(t.$slider).hasClass("slick-initialized") || (i(t.$slider).addClass("slick-initialized"), t.buildRows(), t.buildOut(), t.setProps(), t.startLoad(), t.loadSlider(), t.initializeEvents(), t.updateArrows(), t.updateDots(), t.checkResponsive(!0), t.focusHandler()), e && t.$slider.trigger("init", [t]), !0 === t.options.accessibility && t.initADA(), t.options.autoplay && (t.paused = !1, t.autoPlay());
  }, e.prototype.initADA = function () {
    var e = this,
      t = Math.ceil(e.slideCount / e.options.slidesToShow),
      o = e.getNavigableIndexes().filter(function (i) {
        return i >= 0 && i < e.slideCount;
      });
    e.$slides.add(e.$slideTrack.find(".slick-cloned")).attr({
      "aria-hidden": "true",
      tabindex: "-1"
    }).find("a, input, button, select").attr({
      tabindex: "-1"
    }), null !== e.$dots && (e.$slides.not(e.$slideTrack.find(".slick-cloned")).each(function (t) {
      var s = o.indexOf(t);
      i(this).attr({
        role: "tabpanel",
        id: "slick-slide" + e.instanceUid + t,
        tabindex: -1
      }), -1 !== s && i(this).attr({
        "aria-describedby": "slick-slide-control" + e.instanceUid + s
      });
    }), e.$dots.attr("role", "tablist").find("li").each(function (s) {
      var n = o[s];
      i(this).attr({
        role: "presentation"
      }), i(this).find("button").first().attr({
        role: "tab",
        id: "slick-slide-control" + e.instanceUid + s,
        "aria-controls": "slick-slide" + e.instanceUid + n,
        "aria-label": s + 1 + " of " + t,
        "aria-selected": null,
        tabindex: "-1"
      });
    }).eq(e.currentSlide).find("button").attr({
      "aria-selected": "true",
      tabindex: "0"
    }).end());
    for (var s = e.currentSlide, n = s + e.options.slidesToShow; s < n; s++) e.$slides.eq(s).attr("tabindex", 0);
    e.activateADA();
  }, e.prototype.initArrowEvents = function () {
    var i = this;
    !0 === i.options.arrows && i.slideCount > i.options.slidesToShow && (i.$prevArrow.off("click.slick").on("click.slick", {
      message: "previous"
    }, i.changeSlide), i.$nextArrow.off("click.slick").on("click.slick", {
      message: "next"
    }, i.changeSlide), !0 === i.options.accessibility && (i.$prevArrow.on("keydown.slick", i.keyHandler), i.$nextArrow.on("keydown.slick", i.keyHandler)));
  }, e.prototype.initDotEvents = function () {
    var e = this;
    !0 === e.options.dots && (i("li", e.$dots).on("click.slick", {
      message: "index"
    }, e.changeSlide), !0 === e.options.accessibility && e.$dots.on("keydown.slick", e.keyHandler)), !0 === e.options.dots && !0 === e.options.pauseOnDotsHover && i("li", e.$dots).on("mouseenter.slick", i.proxy(e.interrupt, e, !0)).on("mouseleave.slick", i.proxy(e.interrupt, e, !1));
  }, e.prototype.initSlideEvents = function () {
    var e = this;
    e.options.pauseOnHover && (e.$list.on("mouseenter.slick", i.proxy(e.interrupt, e, !0)), e.$list.on("mouseleave.slick", i.proxy(e.interrupt, e, !1)));
  }, e.prototype.initializeEvents = function () {
    var e = this;
    e.initArrowEvents(), e.initDotEvents(), e.initSlideEvents(), e.$list.on("touchstart.slick mousedown.slick", {
      action: "start"
    }, e.swipeHandler), e.$list.on("touchmove.slick mousemove.slick", {
      action: "move"
    }, e.swipeHandler), e.$list.on("touchend.slick mouseup.slick", {
      action: "end"
    }, e.swipeHandler), e.$list.on("touchcancel.slick mouseleave.slick", {
      action: "end"
    }, e.swipeHandler), e.$list.on("click.slick", e.clickHandler), i(document).on(e.visibilityChange, i.proxy(e.visibility, e)), !0 === e.options.accessibility && e.$list.on("keydown.slick", e.keyHandler), !0 === e.options.focusOnSelect && i(e.$slideTrack).children().on("click.slick", e.selectHandler), i(window).on("orientationchange.slick.slick-" + e.instanceUid, i.proxy(e.orientationChange, e)), i(window).on("resize.slick.slick-" + e.instanceUid, i.proxy(e.resize, e)), i("[draggable!=true]", e.$slideTrack).on("dragstart", e.preventDefault), i(window).on("load.slick.slick-" + e.instanceUid, e.setPosition), i(e.setPosition);
  }, e.prototype.initUI = function () {
    var i = this;
    !0 === i.options.arrows && i.slideCount > i.options.slidesToShow && (i.$prevArrow.show(), i.$nextArrow.show()), !0 === i.options.dots && i.slideCount > i.options.slidesToShow && i.$dots.show();
  }, e.prototype.keyHandler = function (i) {
    var e = this;
    i.target.tagName.match("TEXTAREA|INPUT|SELECT") || (37 === i.keyCode && !0 === e.options.accessibility ? e.changeSlide({
      data: {
        message: !0 === e.options.rtl ? "next" : "previous"
      }
    }) : 39 === i.keyCode && !0 === e.options.accessibility && e.changeSlide({
      data: {
        message: !0 === e.options.rtl ? "previous" : "next"
      }
    }));
  }, e.prototype.lazyLoad = function () {
    function e(e) {
      i("img[data-lazy]", e).each(function () {
        var e = i(this),
          t = i(this).attr("data-lazy"),
          o = i(this).attr("data-srcset"),
          s = i(this).attr("data-sizes") || n.$slider.attr("data-sizes"),
          r = document.createElement("img");
        r.onload = function () {
          e.animate({
            opacity: 0
          }, 100, function () {
            o && (e.attr("srcset", o), s && e.attr("sizes", s)), e.attr("src", t).animate({
              opacity: 1
            }, 200, function () {
              e.removeAttr("data-lazy data-srcset data-sizes").removeClass("slick-loading");
            }), n.$slider.trigger("lazyLoaded", [n, e, t]);
          });
        }, r.onerror = function () {
          e.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"), n.$slider.trigger("lazyLoadError", [n, e, t]);
        }, r.src = t;
      });
    }
    var t,
      o,
      s,
      n = this;
    if (!0 === n.options.centerMode ? !0 === n.options.infinite ? s = (o = n.currentSlide + (n.options.slidesToShow / 2 + 1)) + n.options.slidesToShow + 2 : (o = Math.max(0, n.currentSlide - (n.options.slidesToShow / 2 + 1)), s = n.options.slidesToShow / 2 + 1 + 2 + n.currentSlide) : (o = n.options.infinite ? n.options.slidesToShow + n.currentSlide : n.currentSlide, s = Math.ceil(o + n.options.slidesToShow), !0 === n.options.fade && (o > 0 && o--, s <= n.slideCount && s++)), t = n.$slider.find(".slick-slide").slice(o, s), "anticipated" === n.options.lazyLoad) for (var r = o - 1, l = s, d = n.$slider.find(".slick-slide"), a = 0; a < n.options.slidesToScroll; a++) r < 0 && (r = n.slideCount - 1), t = (t = t.add(d.eq(r))).add(d.eq(l)), r--, l++;
    e(t), n.slideCount <= n.options.slidesToShow ? e(n.$slider.find(".slick-slide")) : n.currentSlide >= n.slideCount - n.options.slidesToShow ? e(n.$slider.find(".slick-cloned").slice(0, n.options.slidesToShow)) : 0 === n.currentSlide && e(n.$slider.find(".slick-cloned").slice(-1 * n.options.slidesToShow));
  }, e.prototype.loadSlider = function () {
    var i = this;
    i.setPosition(), i.$slideTrack.css({
      opacity: 1
    }), i.$slider.removeClass("slick-loading"), i.initUI(), "progressive" === i.options.lazyLoad && i.progressiveLazyLoad();
  }, e.prototype.next = e.prototype.slickNext = function () {
    this.changeSlide({
      data: {
        message: "next"
      }
    });
  }, e.prototype.orientationChange = function () {
    var i = this;
    i.checkResponsive(), i.setPosition();
  }, e.prototype.pause = e.prototype.slickPause = function () {
    var i = this;
    i.autoPlayClear(), i.paused = !0;
  }, e.prototype.play = e.prototype.slickPlay = function () {
    var i = this;
    i.autoPlay(), i.options.autoplay = !0, i.paused = !1, i.focussed = !1, i.interrupted = !1;
  }, e.prototype.postSlide = function (e) {
    var t = this;
    t.unslicked || (t.$slider.trigger("afterChange", [t, e]), t.animating = !1, t.slideCount > t.options.slidesToShow && t.setPosition(), t.swipeLeft = null, t.options.autoplay && t.autoPlay(), !0 === t.options.accessibility && (t.initADA(), t.options.focusOnChange && i(t.$slides.get(t.currentSlide)).attr("tabindex", 0).focus()));
  }, e.prototype.prev = e.prototype.slickPrev = function () {
    this.changeSlide({
      data: {
        message: "previous"
      }
    });
  }, e.prototype.preventDefault = function (i) {
    i.preventDefault();
  }, e.prototype.progressiveLazyLoad = function (e) {
    e = e || 1;
    var t,
      o,
      s,
      n,
      r,
      l = this,
      d = i("img[data-lazy]", l.$slider);
    d.length ? (t = d.first(), o = t.attr("data-lazy"), s = t.attr("data-srcset"), n = t.attr("data-sizes") || l.$slider.attr("data-sizes"), (r = document.createElement("img")).onload = function () {
      s && (t.attr("srcset", s), n && t.attr("sizes", n)), t.attr("src", o).removeAttr("data-lazy data-srcset data-sizes").removeClass("slick-loading"), !0 === l.options.adaptiveHeight && l.setPosition(), l.$slider.trigger("lazyLoaded", [l, t, o]), l.progressiveLazyLoad();
    }, r.onerror = function () {
      e < 3 ? setTimeout(function () {
        l.progressiveLazyLoad(e + 1);
      }, 500) : (t.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"), l.$slider.trigger("lazyLoadError", [l, t, o]), l.progressiveLazyLoad());
    }, r.src = o) : l.$slider.trigger("allImagesLoaded", [l]);
  }, e.prototype.refresh = function (e) {
    var t,
      o,
      s = this;
    o = s.slideCount - s.options.slidesToShow, !s.options.infinite && s.currentSlide > o && (s.currentSlide = o), s.slideCount <= s.options.slidesToShow && (s.currentSlide = 0), t = s.currentSlide, s.destroy(!0), i.extend(s, s.initials, {
      currentSlide: t
    }), s.init(), e || s.changeSlide({
      data: {
        message: "index",
        index: t
      }
    }, !1);
  }, e.prototype.registerBreakpoints = function () {
    var e,
      t,
      o,
      s = this,
      n = s.options.responsive || null;
    if ("array" === i.type(n) && n.length) {
      s.respondTo = s.options.respondTo || "window";
      for (e in n) if (o = s.breakpoints.length - 1, n.hasOwnProperty(e)) {
        for (t = n[e].breakpoint; o >= 0;) s.breakpoints[o] && s.breakpoints[o] === t && s.breakpoints.splice(o, 1), o--;
        s.breakpoints.push(t), s.breakpointSettings[t] = n[e].settings;
      }
      s.breakpoints.sort(function (i, e) {
        return s.options.mobileFirst ? i - e : e - i;
      });
    }
  }, e.prototype.reinit = function () {
    var e = this;
    e.$slides = e.$slideTrack.children(e.options.slide).addClass("slick-slide"), e.slideCount = e.$slides.length, e.currentSlide >= e.slideCount && 0 !== e.currentSlide && (e.currentSlide = e.currentSlide - e.options.slidesToScroll), e.slideCount <= e.options.slidesToShow && (e.currentSlide = 0), e.registerBreakpoints(), e.setProps(), e.setupInfinite(), e.buildArrows(), e.updateArrows(), e.initArrowEvents(), e.buildDots(), e.updateDots(), e.initDotEvents(), e.cleanUpSlideEvents(), e.initSlideEvents(), e.checkResponsive(!1, !0), !0 === e.options.focusOnSelect && i(e.$slideTrack).children().on("click.slick", e.selectHandler), e.setSlideClasses("number" == typeof e.currentSlide ? e.currentSlide : 0), e.setPosition(), e.focusHandler(), e.paused = !e.options.autoplay, e.autoPlay(), e.$slider.trigger("reInit", [e]);
  }, e.prototype.resize = function () {
    var e = this;
    i(window).width() !== e.windowWidth && (clearTimeout(e.windowDelay), e.windowDelay = window.setTimeout(function () {
      e.windowWidth = i(window).width(), e.checkResponsive(), e.unslicked || e.setPosition();
    }, 50));
  }, e.prototype.removeSlide = e.prototype.slickRemove = function (i, e, t) {
    var o = this;
    if (i = "boolean" == typeof i ? !0 === (e = i) ? 0 : o.slideCount - 1 : !0 === e ? --i : i, o.slideCount < 1 || i < 0 || i > o.slideCount - 1) return !1;
    o.unload(), !0 === t ? o.$slideTrack.children().remove() : o.$slideTrack.children(this.options.slide).eq(i).remove(), o.$slides = o.$slideTrack.children(this.options.slide), o.$slideTrack.children(this.options.slide).detach(), o.$slideTrack.append(o.$slides), o.$slidesCache = o.$slides, o.reinit();
  }, e.prototype.setCSS = function (i) {
    var e,
      t,
      o = this,
      s = {};
    !0 === o.options.rtl && (i = -i), e = "left" == o.positionProp ? Math.ceil(i) + "px" : "0px", t = "top" == o.positionProp ? Math.ceil(i) + "px" : "0px", s[o.positionProp] = i, !1 === o.transformsEnabled ? o.$slideTrack.css(s) : (s = {}, !1 === o.cssTransitions ? (s[o.animType] = "translate(" + e + ", " + t + ")", o.$slideTrack.css(s)) : (s[o.animType] = "translate3d(" + e + ", " + t + ", 0px)", o.$slideTrack.css(s)));
  }, e.prototype.setDimensions = function () {
    var i = this;
    !1 === i.options.vertical ? !0 === i.options.centerMode && i.$list.css({
      padding: "0px " + i.options.centerPadding
    }) : (i.$list.height(i.$slides.first().outerHeight(!0) * i.options.slidesToShow), !0 === i.options.centerMode && i.$list.css({
      padding: i.options.centerPadding + " 0px"
    })), i.listWidth = i.$list.width(), i.listHeight = i.$list.height(), !1 === i.options.vertical && !1 === i.options.variableWidth ? (i.slideWidth = Math.ceil(i.listWidth / i.options.slidesToShow), i.$slideTrack.width(Math.ceil(i.slideWidth * i.$slideTrack.children(".slick-slide").length))) : !0 === i.options.variableWidth ? i.$slideTrack.width(5e3 * i.slideCount) : (i.slideWidth = Math.ceil(i.listWidth), i.$slideTrack.height(Math.ceil(i.$slides.first().outerHeight(!0) * i.$slideTrack.children(".slick-slide").length)));
    var e = i.$slides.first().outerWidth(!0) - i.$slides.first().width();
    !1 === i.options.variableWidth && i.$slideTrack.children(".slick-slide").width(i.slideWidth - e);
  }, e.prototype.setFade = function () {
    var e,
      t = this;
    t.$slides.each(function (o, s) {
      e = t.slideWidth * o * -1, !0 === t.options.rtl ? i(s).css({
        position: "relative",
        right: e,
        top: 0,
        zIndex: t.options.zIndex - 2,
        opacity: 0
      }) : i(s).css({
        position: "relative",
        left: e,
        top: 0,
        zIndex: t.options.zIndex - 2,
        opacity: 0
      });
    }), t.$slides.eq(t.currentSlide).css({
      zIndex: t.options.zIndex - 1,
      opacity: 1
    });
  }, e.prototype.setHeight = function () {
    var i = this;
    if (1 === i.options.slidesToShow && !0 === i.options.adaptiveHeight && !1 === i.options.vertical) {
      var e = i.$slides.eq(i.currentSlide).outerHeight(!0);
      i.$list.css("height", e);
    }
  }, e.prototype.setOption = e.prototype.slickSetOption = function () {
    var e,
      t,
      o,
      s,
      n,
      r = this,
      l = !1;
    if ("object" === i.type(arguments[0]) ? (o = arguments[0], l = arguments[1], n = "multiple") : "string" === i.type(arguments[0]) && (o = arguments[0], s = arguments[1], l = arguments[2], "responsive" === arguments[0] && "array" === i.type(arguments[1]) ? n = "responsive" : void 0 !== arguments[1] && (n = "single")), "single" === n) r.options[o] = s;else if ("multiple" === n) i.each(o, function (i, e) {
      r.options[i] = e;
    });else if ("responsive" === n) for (t in s) if ("array" !== i.type(r.options.responsive)) r.options.responsive = [s[t]];else {
      for (e = r.options.responsive.length - 1; e >= 0;) r.options.responsive[e].breakpoint === s[t].breakpoint && r.options.responsive.splice(e, 1), e--;
      r.options.responsive.push(s[t]);
    }
    l && (r.unload(), r.reinit());
  }, e.prototype.setPosition = function () {
    var i = this;
    i.setDimensions(), i.setHeight(), !1 === i.options.fade ? i.setCSS(i.getLeft(i.currentSlide)) : i.setFade(), i.$slider.trigger("setPosition", [i]);
  }, e.prototype.setProps = function () {
    var i = this,
      e = document.body.style;
    i.positionProp = !0 === i.options.vertical ? "top" : "left", "top" === i.positionProp ? i.$slider.addClass("slick-vertical") : i.$slider.removeClass("slick-vertical"), void 0 === e.WebkitTransition && void 0 === e.MozTransition && void 0 === e.msTransition || !0 === i.options.useCSS && (i.cssTransitions = !0), i.options.fade && ("number" == typeof i.options.zIndex ? i.options.zIndex < 3 && (i.options.zIndex = 3) : i.options.zIndex = i.defaults.zIndex), void 0 !== e.OTransform && (i.animType = "OTransform", i.transformType = "-o-transform", i.transitionType = "OTransition", void 0 === e.perspectiveProperty && void 0 === e.webkitPerspective && (i.animType = !1)), void 0 !== e.MozTransform && (i.animType = "MozTransform", i.transformType = "-moz-transform", i.transitionType = "MozTransition", void 0 === e.perspectiveProperty && void 0 === e.MozPerspective && (i.animType = !1)), void 0 !== e.webkitTransform && (i.animType = "webkitTransform", i.transformType = "-webkit-transform", i.transitionType = "webkitTransition", void 0 === e.perspectiveProperty && void 0 === e.webkitPerspective && (i.animType = !1)), void 0 !== e.msTransform && (i.animType = "msTransform", i.transformType = "-ms-transform", i.transitionType = "msTransition", void 0 === e.msTransform && (i.animType = !1)), void 0 !== e.transform && !1 !== i.animType && (i.animType = "transform", i.transformType = "transform", i.transitionType = "transition"), i.transformsEnabled = i.options.useTransform && null !== i.animType && !1 !== i.animType;
  }, e.prototype.setSlideClasses = function (i) {
    var e,
      t,
      o,
      s,
      n = this;
    if (t = n.$slider.find(".slick-slide").removeClass("slick-active slick-center slick-current").attr("aria-hidden", "true"), n.$slides.eq(i).addClass("slick-current"), !0 === n.options.centerMode) {
      var r = n.options.slidesToShow % 2 == 0 ? 1 : 0;
      e = Math.floor(n.options.slidesToShow / 2), !0 === n.options.infinite && (i >= e && i <= n.slideCount - 1 - e ? n.$slides.slice(i - e + r, i + e + 1).addClass("slick-active").attr("aria-hidden", "false") : (o = n.options.slidesToShow + i, t.slice(o - e + 1 + r, o + e + 2).addClass("slick-active").attr("aria-hidden", "false")), 0 === i ? t.eq(t.length - 1 - n.options.slidesToShow).addClass("slick-center") : i === n.slideCount - 1 && t.eq(n.options.slidesToShow).addClass("slick-center")), n.$slides.eq(i).addClass("slick-center");
    } else i >= 0 && i <= n.slideCount - n.options.slidesToShow ? n.$slides.slice(i, i + n.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false") : t.length <= n.options.slidesToShow ? t.addClass("slick-active").attr("aria-hidden", "false") : (s = n.slideCount % n.options.slidesToShow, o = !0 === n.options.infinite ? n.options.slidesToShow + i : i, n.options.slidesToShow == n.options.slidesToScroll && n.slideCount - i < n.options.slidesToShow ? t.slice(o - (n.options.slidesToShow - s), o + s).addClass("slick-active").attr("aria-hidden", "false") : t.slice(o, o + n.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false"));
    "ondemand" !== n.options.lazyLoad && "anticipated" !== n.options.lazyLoad || n.lazyLoad();
  }, e.prototype.setupInfinite = function () {
    var e,
      t,
      o,
      s = this;
    if (!0 === s.options.fade && (s.options.centerMode = !1), !0 === s.options.infinite && !1 === s.options.fade && (t = null, s.slideCount > s.options.slidesToShow)) {
      for (o = !0 === s.options.centerMode ? s.options.slidesToShow + 1 : s.options.slidesToShow, e = s.slideCount; e > s.slideCount - o; e -= 1) t = e - 1, i(s.$slides[t]).clone(!0).attr("id", "").attr("data-slick-index", t - s.slideCount).prependTo(s.$slideTrack).addClass("slick-cloned");
      for (e = 0; e < o + s.slideCount; e += 1) t = e, i(s.$slides[t]).clone(!0).attr("id", "").attr("data-slick-index", t + s.slideCount).appendTo(s.$slideTrack).addClass("slick-cloned");
      s.$slideTrack.find(".slick-cloned").find("[id]").each(function () {
        i(this).attr("id", "");
      });
    }
  }, e.prototype.interrupt = function (i) {
    var e = this;
    i || e.autoPlay(), e.interrupted = i;
  }, e.prototype.selectHandler = function (e) {
    var t = this,
      o = i(e.target).is(".slick-slide") ? i(e.target) : i(e.target).parents(".slick-slide"),
      s = parseInt(o.attr("data-slick-index"));
    s || (s = 0), t.slideCount <= t.options.slidesToShow ? t.slideHandler(s, !1, !0) : t.slideHandler(s);
  }, e.prototype.slideHandler = function (i, e, t) {
    var o,
      s,
      n,
      r,
      l,
      d = null,
      a = this;
    if (e = e || !1, !(!0 === a.animating && !0 === a.options.waitForAnimate || !0 === a.options.fade && a.currentSlide === i)) if (!1 === e && a.asNavFor(i), o = i, d = a.getLeft(o), r = a.getLeft(a.currentSlide), a.currentLeft = null === a.swipeLeft ? r : a.swipeLeft, !1 === a.options.infinite && !1 === a.options.centerMode && (i < 0 || i > a.getDotCount() * a.options.slidesToScroll)) !1 === a.options.fade && (o = a.currentSlide, !0 !== t ? a.animateSlide(r, function () {
      a.postSlide(o);
    }) : a.postSlide(o));else if (!1 === a.options.infinite && !0 === a.options.centerMode && (i < 0 || i > a.slideCount - a.options.slidesToScroll)) !1 === a.options.fade && (o = a.currentSlide, !0 !== t ? a.animateSlide(r, function () {
      a.postSlide(o);
    }) : a.postSlide(o));else {
      if (a.options.autoplay && clearInterval(a.autoPlayTimer), s = o < 0 ? a.slideCount % a.options.slidesToScroll != 0 ? a.slideCount - a.slideCount % a.options.slidesToScroll : a.slideCount + o : o >= a.slideCount ? a.slideCount % a.options.slidesToScroll != 0 ? 0 : o - a.slideCount : o, a.animating = !0, a.$slider.trigger("beforeChange", [a, a.currentSlide, s]), n = a.currentSlide, a.currentSlide = s, a.setSlideClasses(a.currentSlide), a.options.asNavFor && (l = (l = a.getNavTarget()).slick("getSlick")).slideCount <= l.options.slidesToShow && l.setSlideClasses(a.currentSlide), a.updateDots(), a.updateArrows(), !0 === a.options.fade) return !0 !== t ? (a.fadeSlideOut(n), a.fadeSlide(s, function () {
        a.postSlide(s);
      })) : a.postSlide(s), void a.animateHeight();
      !0 !== t ? a.animateSlide(d, function () {
        a.postSlide(s);
      }) : a.postSlide(s);
    }
  }, e.prototype.startLoad = function () {
    var i = this;
    !0 === i.options.arrows && i.slideCount > i.options.slidesToShow && (i.$prevArrow.hide(), i.$nextArrow.hide()), !0 === i.options.dots && i.slideCount > i.options.slidesToShow && i.$dots.hide(), i.$slider.addClass("slick-loading");
  }, e.prototype.swipeDirection = function () {
    var i,
      e,
      t,
      o,
      s = this;
    return i = s.touchObject.startX - s.touchObject.curX, e = s.touchObject.startY - s.touchObject.curY, t = Math.atan2(e, i), (o = Math.round(180 * t / Math.PI)) < 0 && (o = 360 - Math.abs(o)), o <= 45 && o >= 0 ? !1 === s.options.rtl ? "left" : "right" : o <= 360 && o >= 315 ? !1 === s.options.rtl ? "left" : "right" : o >= 135 && o <= 225 ? !1 === s.options.rtl ? "right" : "left" : !0 === s.options.verticalSwiping ? o >= 35 && o <= 135 ? "down" : "up" : "vertical";
  }, e.prototype.swipeEnd = function (i) {
    var e,
      t,
      o = this;
    if (o.dragging = !1, o.swiping = !1, o.scrolling) return o.scrolling = !1, !1;
    if (o.interrupted = !1, o.shouldClick = !(o.touchObject.swipeLength > 10), void 0 === o.touchObject.curX) return !1;
    if (!0 === o.touchObject.edgeHit && o.$slider.trigger("edge", [o, o.swipeDirection()]), o.touchObject.swipeLength >= o.touchObject.minSwipe) {
      switch (t = o.swipeDirection()) {
        case "left":
        case "down":
          e = o.options.swipeToSlide ? o.checkNavigable(o.currentSlide + o.getSlideCount()) : o.currentSlide + o.getSlideCount(), o.currentDirection = 0;
          break;
        case "right":
        case "up":
          e = o.options.swipeToSlide ? o.checkNavigable(o.currentSlide - o.getSlideCount()) : o.currentSlide - o.getSlideCount(), o.currentDirection = 1;
      }
      "vertical" != t && (o.slideHandler(e), o.touchObject = {}, o.$slider.trigger("swipe", [o, t]));
    } else o.touchObject.startX !== o.touchObject.curX && (o.slideHandler(o.currentSlide), o.touchObject = {});
  }, e.prototype.swipeHandler = function (i) {
    var e = this;
    if (!(!1 === e.options.swipe || "ontouchend" in document && !1 === e.options.swipe || !1 === e.options.draggable && -1 !== i.type.indexOf("mouse"))) switch (e.touchObject.fingerCount = i.originalEvent && void 0 !== i.originalEvent.touches ? i.originalEvent.touches.length : 1, e.touchObject.minSwipe = e.listWidth / e.options.touchThreshold, !0 === e.options.verticalSwiping && (e.touchObject.minSwipe = e.listHeight / e.options.touchThreshold), i.data.action) {
      case "start":
        e.swipeStart(i);
        break;
      case "move":
        e.swipeMove(i);
        break;
      case "end":
        e.swipeEnd(i);
    }
  }, e.prototype.swipeMove = function (i) {
    var e,
      t,
      o,
      s,
      n,
      r,
      l = this;
    return n = void 0 !== i.originalEvent ? i.originalEvent.touches : null, !(!l.dragging || l.scrolling || n && 1 !== n.length) && (e = l.getLeft(l.currentSlide), l.touchObject.curX = void 0 !== n ? n[0].pageX : i.clientX, l.touchObject.curY = void 0 !== n ? n[0].pageY : i.clientY, l.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(l.touchObject.curX - l.touchObject.startX, 2))), r = Math.round(Math.sqrt(Math.pow(l.touchObject.curY - l.touchObject.startY, 2))), !l.options.verticalSwiping && !l.swiping && r > 4 ? (l.scrolling = !0, !1) : (!0 === l.options.verticalSwiping && (l.touchObject.swipeLength = r), t = l.swipeDirection(), void 0 !== i.originalEvent && l.touchObject.swipeLength > 4 && (l.swiping = !0, i.preventDefault()), s = (!1 === l.options.rtl ? 1 : -1) * (l.touchObject.curX > l.touchObject.startX ? 1 : -1), !0 === l.options.verticalSwiping && (s = l.touchObject.curY > l.touchObject.startY ? 1 : -1), o = l.touchObject.swipeLength, l.touchObject.edgeHit = !1, !1 === l.options.infinite && (0 === l.currentSlide && "right" === t || l.currentSlide >= l.getDotCount() && "left" === t) && (o = l.touchObject.swipeLength * l.options.edgeFriction, l.touchObject.edgeHit = !0), !1 === l.options.vertical ? l.swipeLeft = e + o * s : l.swipeLeft = e + o * (l.$list.height() / l.listWidth) * s, !0 === l.options.verticalSwiping && (l.swipeLeft = e + o * s), !0 !== l.options.fade && !1 !== l.options.touchMove && (!0 === l.animating ? (l.swipeLeft = null, !1) : void l.setCSS(l.swipeLeft))));
  }, e.prototype.swipeStart = function (i) {
    var e,
      t = this;
    if (t.interrupted = !0, 1 !== t.touchObject.fingerCount || t.slideCount <= t.options.slidesToShow) return t.touchObject = {}, !1;
    void 0 !== i.originalEvent && void 0 !== i.originalEvent.touches && (e = i.originalEvent.touches[0]), t.touchObject.startX = t.touchObject.curX = void 0 !== e ? e.pageX : i.clientX, t.touchObject.startY = t.touchObject.curY = void 0 !== e ? e.pageY : i.clientY, t.dragging = !0;
  }, e.prototype.unfilterSlides = e.prototype.slickUnfilter = function () {
    var i = this;
    null !== i.$slidesCache && (i.unload(), i.$slideTrack.children(this.options.slide).detach(), i.$slidesCache.appendTo(i.$slideTrack), i.reinit());
  }, e.prototype.unload = function () {
    var e = this;
    i(".slick-cloned", e.$slider).remove(), e.$dots && e.$dots.remove(), e.$prevArrow && e.htmlExpr.test(e.options.prevArrow) && e.$prevArrow.remove(), e.$nextArrow && e.htmlExpr.test(e.options.nextArrow) && e.$nextArrow.remove(), e.$slides.removeClass("slick-slide slick-active slick-visible slick-current").attr("aria-hidden", "true").css("width", "");
  }, e.prototype.unslick = function (i) {
    var e = this;
    e.$slider.trigger("unslick", [e, i]), e.destroy();
  }, e.prototype.updateArrows = function () {
    var i = this;
    Math.floor(i.options.slidesToShow / 2), !0 === i.options.arrows && i.slideCount > i.options.slidesToShow && !i.options.infinite && (i.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false"), i.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false"), 0 === i.currentSlide ? (i.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true"), i.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : i.currentSlide >= i.slideCount - i.options.slidesToShow && !1 === i.options.centerMode ? (i.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"), i.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : i.currentSlide >= i.slideCount - 1 && !0 === i.options.centerMode && (i.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"), i.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")));
  }, e.prototype.updateDots = function () {
    var i = this;
    null !== i.$dots && (i.$dots.find("li").removeClass("slick-active").end(), i.$dots.find("li").eq(Math.floor(i.currentSlide / i.options.slidesToScroll)).addClass("slick-active"));
  }, e.prototype.visibility = function () {
    var i = this;
    i.options.autoplay && (document[i.hidden] ? i.interrupted = !0 : i.interrupted = !1);
  }, i.fn.slick = function () {
    var i,
      t,
      o = this,
      s = arguments[0],
      n = Array.prototype.slice.call(arguments, 1),
      r = o.length;
    for (i = 0; i < r; i++) if ("object" == _typeof(s) || void 0 === s ? o[i].slick = new e(o[i], s) : t = o[i].slick[s].apply(o[i].slick, n), void 0 !== t) return t;
    return o;
  };
});
(function ($) {
  var WidgetCTPostCarouselHandler = function WidgetCTPostCarouselHandler($scope, $) {
    setTimeout(function () {
      var breakpoints = elementorFrontend.config.breakpoints;
      var carousel = $scope.find(".ct-slick-carousel");
      var data = carousel.data();
      var slickOptions = {
        slidesToShow: data.colxl,
        slidesToScroll: data.slidestoscroll,
        autoplay: true === data.autoplay,
        autoplaySpeed: data.autoplayspeed,
        infinite: true === data.infinite,
        pauseOnHover: true === data.pauseonhover,
        speed: data.speed,
        arrows: true === data.arrows,
        dots: true === data.dots,
        rtl: true === data.dir,
        responsive: [{
          breakpoint: 1200,
          settings: {
            slidesToShow: data.collg
          }
        }, {
          breakpoint: 992,
          settings: {
            slidesToShow: data.colmd
          }
        }, {
          breakpoint: 767,
          settings: {
            slidesToShow: data.colsm
          }
        }, {
          breakpoint: 575,
          settings: {
            slidesToShow: data.colxs,
            slidesToScroll: data.colxs
          }
        }]
      };
      var nav_for = $scope.find(".ct-slick-nav");
      if (nav_for.length > 0) {
        slickOptions.asNavFor = nav_for;
      }
      if (typeof carousel.attr('data-centerMode') !== 'undefined') {
        slickOptions.centerMode = carousel.attr('data-centerMode') == 'true' ? true : false;
      }
      if (typeof carousel.attr('data-fade') !== 'undefined') {
        slickOptions.fade = carousel.attr('data-fade') == 'true' ? true : false;
      }
      carousel.slick(slickOptions);
      $('.ct-nav-carousel').parents('.elementor-section').addClass('hide-nav');
      $('.ct-nav-carousel .nav-prev').on('click', function () {
        $(this).parents('.elementor-element').find('.slick-prev').trigger('click');
      });
      $('.ct-nav-carousel .nav-next').on('click', function () {
        $(this).parents('.elementor-element').find('.slick-next').trigger('click');
      });
      $('.arrow-focus1 .ct-nav-carousel').parents('.site-content').find('.carousel-focus1').addClass('hide-nav');
      $('.arrow-focus1 .ct-nav-carousel .nav-prev').on('click', function () {
        $(this).parents('.site-content').find('.carousel-focus1 .slick-prev').trigger('click');
      });
      $('.arrow-focus1 .ct-nav-carousel .nav-next').on('click', function () {
        $(this).parents('.site-content').find('.carousel-focus1 .slick-next').trigger('click');
      });
      $('.ct-nav-slick').parent().addClass('hide-nav');
      $('.ct-nav-slick .nav-prev').on('click', function () {
        $(this).parents('.ct-slick-slider').find('.slick-prev').trigger('click');
      });
      $('.ct-nav-slick .nav-next').on('click', function () {
        $(this).parents('.ct-slick-slider').find('.slick-next').trigger('click');
      });
    }, 300);
  };
  $('.ct-slick-slider').each(function () {
    var slider_main = $(this).find('.ct-slick-carousel');
    var slider_nav = $(this).find('.ct-slick-nav');
    $(slider_nav).slick({
      slidesToShow: parseInt(slider_nav.attr('data-nav')),
      slidesToScroll: 1,
      asNavFor: slider_main,
      dots: false,
      arrows: false,
      centerMode: true,
      infinite: true,
      focusOnSelect: true,
      autoplay: false,
      autoplaySpeed: 8000,
      speed: 800,
      rtl: true === slider_nav.data('dir'),
      responsive: [{
        breakpoint: 768,
        settings: {
          slidesToShow: 3
        }
      }]
    });
  });
  $(window).on('elementor/frontend/init', function () {
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_blog_carousel.default', WidgetCTPostCarouselHandler);
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_service_carousel.default', WidgetCTPostCarouselHandler);
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_portfolio_carousel.default', WidgetCTPostCarouselHandler);
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_gallery_carousel.default', WidgetCTPostCarouselHandler);
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_testimonial_carousel.default', WidgetCTPostCarouselHandler);
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_team_carousel.default', WidgetCTPostCarouselHandler);
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_fancybox_carousel.default', WidgetCTPostCarouselHandler);
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_clients_list.default', WidgetCTPostCarouselHandler);
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_case_study_carousel.default', WidgetCTPostCarouselHandler);
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_fancy_box_carousel.default', WidgetCTPostCarouselHandler);
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_offer_carousel.default', WidgetCTPostCarouselHandler);
    elementorFrontend.hooks.addAction('frontend/element_ready/ct_courses_carousel.default', WidgetCTPostCarouselHandler);
  });
})(jQuery);
/*! elementor - v3.5.6 - 28-02-2022 */
(function () {
  "use strict";

  var e,
    r,
    _,
    t,
    i,
    a = {},
    n = {};
  function __webpack_require__(e) {
    var r = n[e];
    if (void 0 !== r) return r.exports;
    var _ = n[e] = {
      exports: {}
    };
    return a[e](_, _.exports, __webpack_require__), _.exports;
  }
  __webpack_require__.m = a, e = [], __webpack_require__.O = function (r, _, t, i) {
    if (!_) {
      var a = 1 / 0;
      for (u = 0; u < e.length; u++) {
        for (var _e$u = _slicedToArray(e[u], 3), _ = _e$u[0], t = _e$u[1], i = _e$u[2], n = !0, c = 0; c < _.length; c++) (!1 & i || a >= i) && Object.keys(__webpack_require__.O).every(function (e) {
          return __webpack_require__.O[e](_[c]);
        }) ? _.splice(c--, 1) : (n = !1, i < a && (a = i));
        if (n) {
          e.splice(u--, 1);
          var o = t();
          void 0 !== o && (r = o);
        }
      }
      return r;
    }
    i = i || 0;
    for (var u = e.length; u > 0 && e[u - 1][2] > i; u--) e[u] = e[u - 1];
    e[u] = [_, t, i];
  }, _ = Object.getPrototypeOf ? function (e) {
    return Object.getPrototypeOf(e);
  } : function (e) {
    return e.__proto__;
  }, __webpack_require__.t = function (e, t) {
    if (1 & t && (e = this(e)), 8 & t) return e;
    if ("object" == _typeof(e) && e) {
      if (4 & t && e.__esModule) return e;
      if (16 & t && "function" == typeof e.then) return e;
    }
    var i = Object.create(null);
    __webpack_require__.r(i);
    var a = {};
    r = r || [null, _({}), _([]), _(_)];
    for (var n = 2 & t && e; "object" == _typeof(n) && !~r.indexOf(n); n = _(n)) Object.getOwnPropertyNames(n).forEach(function (r) {
      return a[r] = function () {
        return e[r];
      };
    });
    return a.default = function () {
      return e;
    }, __webpack_require__.d(i, a), i;
  }, __webpack_require__.d = function (e, r) {
    for (var _ in r) __webpack_require__.o(r, _) && !__webpack_require__.o(e, _) && Object.defineProperty(e, _, {
      enumerable: !0,
      get: r[_]
    });
  }, __webpack_require__.f = {}, __webpack_require__.e = function (e) {
    return Promise.all(Object.keys(__webpack_require__.f).reduce(function (r, _) {
      return __webpack_require__.f[_](e, r), r;
    }, []));
  }, __webpack_require__.u = function (e) {
    return 723 === e ? "lightbox.2b2c155d6ec60974d8c4.bundle.min.js" : 48 === e ? "text-path.9f18ebdea5ac00d653e5.bundle.min.js" : 209 === e ? "accordion.b68e6c976682017e4ff2.bundle.min.js" : 745 === e ? "alert.cbc2a0fee74ee3ed0419.bundle.min.js" : 120 === e ? "counter.02cef29c589e742d4c8c.bundle.min.js" : 192 === e ? "progress.ca55d33bb06cee4e6f02.bundle.min.js" : 520 === e ? "tabs.49f0a48abbd6fc4749fb.bundle.min.js" : 181 === e ? "toggle.ac82dafbd4b75739bfe6.bundle.min.js" : 791 === e ? "video.1a44ef088849d6949ada.bundle.min.js" : 268 === e ? "image-carousel.bd7aab19c9d934b7c505.bundle.min.js" : 357 === e ? "text-editor.289ae80d76f0c5abea44.bundle.min.js" : 52 === e ? "wp-audio.75f0ced143febb8cd31a.bundle.min.js" : void 0;
  }, __webpack_require__.g = function () {
    if ("object" == (typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis))) return globalThis;
    try {
      return this || new Function("return this")();
    } catch (e) {
      if ("object" == (typeof window === "undefined" ? "undefined" : _typeof(window))) return window;
    }
  }(), __webpack_require__.o = function (e, r) {
    return Object.prototype.hasOwnProperty.call(e, r);
  }, t = {}, i = "elementor:", __webpack_require__.l = function (e, r, _, a) {
    if (t[e]) t[e].push(r);else {
      var n, c;
      if (void 0 !== _) for (var o = document.getElementsByTagName("script"), u = 0; u < o.length; u++) {
        var b = o[u];
        if (b.getAttribute("src") == e || b.getAttribute("data-webpack") == i + _) {
          n = b;
          break;
        }
      }
      n || (c = !0, (n = document.createElement("script")).charset = "utf-8", n.timeout = 120, __webpack_require__.nc && n.setAttribute("nonce", __webpack_require__.nc), n.setAttribute("data-webpack", i + _), n.src = e), t[e] = [r];
      var onScriptComplete = function onScriptComplete(r, _) {
          n.onerror = n.onload = null, clearTimeout(p);
          var i = t[e];
          if (delete t[e], n.parentNode && n.parentNode.removeChild(n), i && i.forEach(function (e) {
            return e(_);
          }), r) return r(_);
        },
        p = setTimeout(onScriptComplete.bind(null, void 0, {
          type: "timeout",
          target: n
        }), 12e4);
      n.onerror = onScriptComplete.bind(null, n.onerror), n.onload = onScriptComplete.bind(null, n.onload), c && document.head.appendChild(n);
    }
  }, __webpack_require__.r = function (e) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(e, "__esModule", {
      value: !0
    });
  }, function () {
    var e;
    __webpack_require__.g.importScripts && (e = __webpack_require__.g.location + "");
    var r = __webpack_require__.g.document;
    if (!e && r && (r.currentScript && (e = r.currentScript.src), !e)) {
      var _ = r.getElementsByTagName("script");
      _.length && (e = _[_.length - 1].src);
    }
    if (!e) throw new Error("Automatic publicPath is not supported in this browser");
    e = e.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/"), __webpack_require__.p = e;
  }(), function () {
    var e = {
      162: 0
    };
    __webpack_require__.f.j = function (r, _) {
      var t = __webpack_require__.o(e, r) ? e[r] : void 0;
      if (0 !== t) if (t) _.push(t[2]);else if (162 != r) {
        var i = new Promise(function (_, i) {
          return t = e[r] = [_, i];
        });
        _.push(t[2] = i);
        var a = __webpack_require__.p + __webpack_require__.u(r),
          n = new Error();
        __webpack_require__.l(a, function (_) {
          if (__webpack_require__.o(e, r) && (0 !== (t = e[r]) && (e[r] = void 0), t)) {
            var i = _ && ("load" === _.type ? "missing" : _.type),
              a = _ && _.target && _.target.src;
            n.message = "Loading chunk " + r + " failed.\n(" + i + ": " + a + ")", n.name = "ChunkLoadError", n.type = i, n.request = a, t[1](n);
          }
        }, "chunk-" + r, r);
      } else e[r] = 0;
    }, __webpack_require__.O.j = function (r) {
      return 0 === e[r];
    };
    var webpackJsonpCallback = function webpackJsonpCallback(r, _) {
        var t,
          i,
          _ref = _slicedToArray(_, 3),
          a = _ref[0],
          n = _ref[1],
          c = _ref[2],
          o = 0;
        if (a.some(function (r) {
          return 0 !== e[r];
        })) {
          for (t in n) __webpack_require__.o(n, t) && (__webpack_require__.m[t] = n[t]);
          if (c) var u = c(__webpack_require__);
        }
        for (r && r(_); o < a.length; o++) i = a[o], __webpack_require__.o(e, i) && e[i] && e[i][0](), e[a[o]] = 0;
        return __webpack_require__.O(u);
      },
      r = self.webpackChunkelementor = self.webpackChunkelementor || [];
    r.forEach(webpackJsonpCallback.bind(null, 0)), r.push = webpackJsonpCallback.bind(null, r.push.bind(r));
  }();
})();
/*! elementor - v3.5.6 - 28-02-2022 */
(self.webpackChunkelementor = self.webpackChunkelementor || []).push([[354], {
  7914: function _(e) {
    e.exports = function _interopRequireDefault(e) {
      return e && e.__esModule ? e : {
        default: e
      };
    }, e.exports.default = e.exports, e.exports.__esModule = !0;
  },
  381: function _(e, t) {
    "use strict";

    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    t.default = function (e, t) {
      t = Array.isArray(t) ? t : [t];
      var _iterator = _createForOfIteratorHelper(t),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var n = _step.value;
          if (e.constructor.name === n.prototype[Symbol.toStringTag]) return !0;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return !1;
    };
  },
  8135: function _(e, t) {
    "use strict";

    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var _default = /*#__PURE__*/function (_elementorModules$Vie) {
      _inherits(_default, _elementorModules$Vie);
      var _super = _createSuper(_default);
      function _default() {
        _classCallCheck(this, _default);
        return _super.apply(this, arguments);
      }
      _createClass(_default, [{
        key: "getDefaultSettings",
        value: function getDefaultSettings() {
          return {
            selectors: {
              elements: ".elementor-element",
              nestedDocumentElements: ".elementor .elementor-element"
            },
            classes: {
              editMode: "elementor-edit-mode"
            }
          };
        }
      }, {
        key: "getDefaultElements",
        value: function getDefaultElements() {
          var e = this.getSettings("selectors");
          return {
            $elements: this.$element.find(e.elements).not(this.$element.find(e.nestedDocumentElements))
          };
        }
      }, {
        key: "getDocumentSettings",
        value: function getDocumentSettings(e) {
          var t;
          if (this.isEdit) {
            t = {};
            var _e2 = elementor.settings.page.model;
            jQuery.each(_e2.getActiveControls(), function (n) {
              t[n] = _e2.attributes[n];
            });
          } else t = this.$element.data("elementor-settings") || {};
          return this.getItems(t, e);
        }
      }, {
        key: "runElementsHandlers",
        value: function runElementsHandlers() {
          this.elements.$elements.each(function (e, t) {
            return elementorFrontend.elementsHandler.runReadyTrigger(t);
          });
        }
      }, {
        key: "onInit",
        value: function onInit() {
          var _this2 = this;
          this.$element = this.getSettings("$element"), _get(_getPrototypeOf(_default.prototype), "onInit", this).call(this), this.isEdit = this.$element.hasClass(this.getSettings("classes.editMode")), this.isEdit ? elementor.on("document:loaded", function () {
            elementor.settings.page.model.on("change", _this2.onSettingsChange.bind(_this2));
          }) : this.runElementsHandlers();
        }
      }, {
        key: "onSettingsChange",
        value: function onSettingsChange() {}
      }]);
      return _default;
    }(elementorModules.ViewModule);
    t.default = _default;
  },
  2821: function _(e, t, n) {
    "use strict";

    var s = n(7914);
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var i = s(n(3090));
    var SwiperHandlerBase = /*#__PURE__*/function (_i$default) {
      _inherits(SwiperHandlerBase, _i$default);
      var _super2 = _createSuper(SwiperHandlerBase);
      function SwiperHandlerBase() {
        _classCallCheck(this, SwiperHandlerBase);
        return _super2.apply(this, arguments);
      }
      _createClass(SwiperHandlerBase, [{
        key: "getInitialSlide",
        value: function getInitialSlide() {
          var e = this.getEditSettings();
          return e.activeItemIndex ? e.activeItemIndex - 1 : 0;
        }
      }, {
        key: "getSlidesCount",
        value: function getSlidesCount() {
          return this.elements.$slides.length;
        }
      }, {
        key: "togglePauseOnHover",
        value: function togglePauseOnHover(e) {
          var _this3 = this;
          e ? this.elements.$swiperContainer.on({
            mouseenter: function mouseenter() {
              _this3.swiper.autoplay.stop();
            },
            mouseleave: function mouseleave() {
              _this3.swiper.autoplay.start();
            }
          }) : this.elements.$swiperContainer.off("mouseenter mouseleave");
        }
      }, {
        key: "handleKenBurns",
        value: function handleKenBurns() {
          var e = this.getSettings();
          this.$activeImageBg && this.$activeImageBg.removeClass(e.classes.kenBurnsActive), this.activeItemIndex = this.swiper ? this.swiper.activeIndex : this.getInitialSlide(), this.swiper ? this.$activeImageBg = jQuery(this.swiper.slides[this.activeItemIndex]).children("." + e.classes.slideBackground) : this.$activeImageBg = jQuery(this.elements.$slides[0]).children("." + e.classes.slideBackground), this.$activeImageBg.addClass(e.classes.kenBurnsActive);
        }
      }]);
      return SwiperHandlerBase;
    }(i.default);
    t.default = SwiperHandlerBase;
  },
  3090: function _(e) {
    "use strict";

    e.exports = elementorModules.ViewModule.extend({
      $element: null,
      editorListeners: null,
      onElementChange: null,
      onEditSettingsChange: null,
      onPageSettingsChange: null,
      isEdit: null,
      __construct: function __construct(e) {
        this.isActive(e) && (this.$element = e.$element, this.isEdit = this.$element.hasClass("elementor-element-edit-mode"), this.isEdit && this.addEditorListeners());
      },
      isActive: function isActive() {
        return !0;
      },
      findElement: function findElement(e) {
        var t = this.$element;
        return t.find(e).filter(function () {
          return jQuery(this).closest(".elementor-element").is(t);
        });
      },
      getUniqueHandlerID: function getUniqueHandlerID(e, t) {
        return e || (e = this.getModelCID()), t || (t = this.$element), e + t.attr("data-element_type") + this.getConstructorID();
      },
      initEditorListeners: function initEditorListeners() {
        var e = this;
        if (e.editorListeners = [{
          event: "element:destroy",
          to: elementor.channels.data,
          callback: function callback(t) {
            t.cid === e.getModelCID() && e.onDestroy();
          }
        }], e.onElementChange) {
          var t = e.getWidgetType() || e.getElementType();
          var n = "change";
          "global" !== t && (n += ":" + t), e.editorListeners.push({
            event: n,
            to: elementor.channels.editor,
            callback: function callback(t, n) {
              e.getUniqueHandlerID(n.model.cid, n.$el) === e.getUniqueHandlerID() && e.onElementChange(t.model.get("name"), t, n);
            }
          });
        }
        e.onEditSettingsChange && e.editorListeners.push({
          event: "change:editSettings",
          to: elementor.channels.editor,
          callback: function callback(t, n) {
            n.model.cid === e.getModelCID() && e.onEditSettingsChange(Object.keys(t.changed)[0]);
          }
        }), ["page"].forEach(function (t) {
          var n = "on" + t[0].toUpperCase() + t.slice(1) + "SettingsChange";
          e[n] && e.editorListeners.push({
            event: "change",
            to: elementor.settings[t].model,
            callback: function callback(t) {
              e[n](t.changed);
            }
          });
        });
      },
      getEditorListeners: function getEditorListeners() {
        return this.editorListeners || this.initEditorListeners(), this.editorListeners;
      },
      addEditorListeners: function addEditorListeners() {
        var e = this.getUniqueHandlerID();
        this.getEditorListeners().forEach(function (t) {
          elementorFrontend.addListenerOnce(e, t.event, t.callback, t.to);
        });
      },
      removeEditorListeners: function removeEditorListeners() {
        var e = this.getUniqueHandlerID();
        this.getEditorListeners().forEach(function (t) {
          elementorFrontend.removeListeners(e, t.event, null, t.to);
        });
      },
      getElementType: function getElementType() {
        return this.$element.data("element_type");
      },
      getWidgetType: function getWidgetType() {
        var e = this.$element.data("widget_type");
        if (e) return e.split(".")[0];
      },
      getID: function getID() {
        return this.$element.data("id");
      },
      getModelCID: function getModelCID() {
        return this.$element.data("model-cid");
      },
      getElementSettings: function getElementSettings(e) {
        var t = {};
        var n = this.getModelCID();
        if (this.isEdit && n) {
          var _e3 = elementorFrontend.config.elements.data[n],
            s = _e3.attributes;
          var i = s.widgetType || s.elType;
          s.isInner && (i = "inner-" + i);
          var r = elementorFrontend.config.elements.keys[i];
          r || (r = elementorFrontend.config.elements.keys[i] = [], jQuery.each(_e3.controls, function (e, t) {
            t.frontend_available && r.push(e);
          })), jQuery.each(_e3.getActiveControls(), function (e) {
            if (-1 !== r.indexOf(e)) {
              var _n2 = s[e];
              _n2.toJSON && (_n2 = _n2.toJSON()), t[e] = _n2;
            }
          });
        } else t = this.$element.data("settings") || {};
        return this.getItems(t, e);
      },
      getEditSettings: function getEditSettings(e) {
        var t = {};
        return this.isEdit && (t = elementorFrontend.config.elements.editSettings[this.getModelCID()].attributes), this.getItems(t, e);
      },
      getCurrentDeviceSetting: function getCurrentDeviceSetting(e) {
        return elementorFrontend.getCurrentDeviceSetting(this.getElementSettings(), e);
      },
      onInit: function onInit() {
        this.isActive(this.getSettings()) && elementorModules.ViewModule.prototype.onInit.apply(this, arguments);
      },
      onDestroy: function onDestroy() {
        this.isEdit && this.removeEditorListeners(), this.unbindEvents && this.unbindEvents();
      }
    });
  },
  6412: function _(e, t, n) {
    "use strict";

    var s = n(7914),
      i = s(n(5955)),
      r = s(n(8135)),
      o = s(n(5658)),
      l = s(n(3090)),
      c = s(n(2821));
    i.default.frontend = {
      Document: r.default,
      tools: {
        StretchElement: o.default
      },
      handlers: {
        Base: l.default,
        SwiperBase: c.default
      }
    };
  },
  5658: function _(e) {
    "use strict";

    e.exports = elementorModules.ViewModule.extend({
      getDefaultSettings: function getDefaultSettings() {
        return {
          element: null,
          direction: elementorFrontend.config.is_rtl ? "right" : "left",
          selectors: {
            container: window
          }
        };
      },
      getDefaultElements: function getDefaultElements() {
        return {
          $element: jQuery(this.getSettings("element"))
        };
      },
      stretch: function stretch() {
        var e,
          t = this.getSettings("selectors.container");
        try {
          e = jQuery(t);
        } catch (e) {}
        e && e.length || (e = jQuery(this.getDefaultSettings().selectors.container)), this.reset();
        var n = this.elements.$element,
          s = e.innerWidth(),
          i = n.offset().left,
          r = "fixed" === n.css("position"),
          o = r ? 0 : i;
        if (window !== e[0]) {
          var l = e.offset().left;
          r && (o = l), i > l && (o = i - l);
        }
        r || (elementorFrontend.config.is_rtl && (o = s - (n.outerWidth() + o)), o = -o);
        var c = {};
        c.width = s + "px", c[this.getSettings("direction")] = o + "px", n.css(c);
      },
      reset: function reset() {
        var e = {
          width: ""
        };
        e[this.getSettings("direction")] = "", this.elements.$element.css(e);
      }
    });
  },
  2618: function _(e, t, n) {
    "use strict";

    var s = n(7914);
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var i = s(n(7597)),
      r = s(n(381));
    var ArgsObject = /*#__PURE__*/function (_i$default2) {
      _inherits(ArgsObject, _i$default2);
      var _super3 = _createSuper(ArgsObject);
      function ArgsObject(e) {
        var _this4;
        _classCallCheck(this, ArgsObject);
        _this4 = _super3.call(this), _this4.args = e;
        return _this4;
      }
      _createClass(ArgsObject, [{
        key: "requireArgument",
        value: function requireArgument(e) {
          var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.args;
          if (!t.hasOwnProperty(e)) throw Error("".concat(e, " is required."));
        }
      }, {
        key: "requireArgumentType",
        value: function requireArgumentType(e, t) {
          var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.args;
          if (this.requireArgument(e, n), _typeof(n[e]) !== t) throw Error("".concat(e, " invalid type: ").concat(t, "."));
        }
      }, {
        key: "requireArgumentInstance",
        value: function requireArgumentInstance(e, t) {
          var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.args;
          if (this.requireArgument(e, n), !(n[e] instanceof t || (0, r.default)(n[e], t))) throw Error("".concat(e, " invalid instance."));
        }
      }, {
        key: "requireArgumentConstructor",
        value: function requireArgumentConstructor(e, t) {
          var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.args;
          if (this.requireArgument(e, n), n[e].constructor !== t) throw Error("".concat(e, " invalid constructor type."));
        }
      }], [{
        key: "getInstanceType",
        value: function getInstanceType() {
          return "ArgsObject";
        }
      }]);
      return ArgsObject;
    }(i.default);
    t.default = ArgsObject;
  },
  869: function _(e, t) {
    "use strict";

    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = t.ForceMethodImplementation = void 0;
    var ForceMethodImplementation = /*#__PURE__*/function (_Error) {
      _inherits(ForceMethodImplementation, _Error);
      var _super4 = _createSuper(ForceMethodImplementation);
      function ForceMethodImplementation() {
        var _this5;
        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        _classCallCheck(this, ForceMethodImplementation);
        _this5 = _super4.call(this, "".concat(e.isStatic ? "static " : "").concat(e.fullName, "() should be implemented, please provide '").concat(e.functionName || e.fullName, "' functionality.")), Error.captureStackTrace(_assertThisInitialized(_this5), ForceMethodImplementation);
        return _this5;
      }
      return _createClass(ForceMethodImplementation);
    }( /*#__PURE__*/_wrapNativeSuper(Error));
    t.ForceMethodImplementation = ForceMethodImplementation;
    t.default = function () {
      var e = Error().stack.split("\n")[2].trim(),
        t = e.startsWith("at new") ? "constructor" : e.split(" ")[1],
        n = {};
      if (n.functionName = t, n.fullName = t, n.functionName.includes(".")) {
        var _e4 = n.functionName.split(".");
        n.className = _e4[0], n.functionName = _e4[1];
      } else n.isStatic = !0;
      throw new ForceMethodImplementation(n);
    };
  },
  7597: function _(e, t) {
    "use strict";

    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var InstanceType = /*#__PURE__*/function (_Symbol$hasInstance) {
      function InstanceType() {
        var _this6 = this;
        _classCallCheck(this, InstanceType);
        var e = this instanceof InstanceType ? this.constructor : void 0;
        var t = [];
        for (; e.__proto__ && e.__proto__.name;) t.push(e.__proto__), e = e.__proto__;
        t.reverse().forEach(function (e) {
          return _this6 instanceof e;
        });
      }
      _createClass(InstanceType, null, [{
        key: _Symbol$hasInstance,
        value: function value(e) {
          var t = _get(_getPrototypeOf(InstanceType), Symbol.hasInstance, this).call(this, e);
          if (e && !e.constructor.getInstanceType) return t;
          if (e && (e.instanceTypes || (e.instanceTypes = []), t || this.getInstanceType() === e.constructor.getInstanceType() && (t = !0), t)) {
            var _t6 = this.getInstanceType === InstanceType.getInstanceType ? "BaseInstanceType" : this.getInstanceType();
            -1 === e.instanceTypes.indexOf(_t6) && e.instanceTypes.push(_t6);
          }
          return !t && e && (t = e.instanceTypes && Array.isArray(e.instanceTypes) && -1 !== e.instanceTypes.indexOf(this.getInstanceType())), t;
        }
      }, {
        key: "getInstanceType",
        value: function getInstanceType() {
          elementorModules.ForceMethodImplementation();
        }
      }]);
      return InstanceType;
    }(Symbol.hasInstance);
    t.default = InstanceType;
  },
  1192: function _(e) {
    "use strict";

    var Module = function Module() {
      var e = jQuery,
        t = arguments,
        n = this,
        s = {};
      var i;
      var ensureClosureMethods = function ensureClosureMethods() {
          e.each(n, function (e) {
            var t = n[e];
            "function" == typeof t && (n[e] = function () {
              return t.apply(n, arguments);
            });
          });
        },
        initSettings = function initSettings() {
          i = n.getDefaultSettings();
          var s = t[0];
          s && e.extend(!0, i, s);
        },
        init = function init() {
          n.__construct.apply(n, t), ensureClosureMethods(), initSettings(), n.trigger("init");
        };
      this.getItems = function (e, t) {
        if (t) {
          var _n3 = t.split("."),
            _s2 = _n3.splice(0, 1);
          if (!_n3.length) return e[_s2];
          if (!e[_s2]) return;
          return this.getItems(e[_s2], _n3.join("."));
        }
        return e;
      }, this.getSettings = function (e) {
        return this.getItems(i, e);
      }, this.setSettings = function (t, s, r) {
        if (r || (r = i), "object" == _typeof(t)) return e.extend(r, t), n;
        var o = t.split("."),
          l = o.splice(0, 1);
        return o.length ? (r[l] || (r[l] = {}), n.setSettings(o.join("."), s, r[l])) : (r[l] = s, n);
      }, this.getErrorMessage = function (e, t) {
        var n;
        if ("forceMethodImplementation" === e) n = "The method '".concat(t, "' must to be implemented in the inheritor child.");else n = "An error occurs";
        return n;
      }, this.forceMethodImplementation = function (e) {
        throw new Error(this.getErrorMessage("forceMethodImplementation", e));
      }, this.on = function (t, i) {
        if ("object" == _typeof(t)) return e.each(t, function (e) {
          n.on(e, this);
        }), n;
        return t.split(" ").forEach(function (e) {
          s[e] || (s[e] = []), s[e].push(i);
        }), n;
      }, this.off = function (e, t) {
        if (!s[e]) return n;
        if (!t) return delete s[e], n;
        var i = s[e].indexOf(t);
        return -1 !== i && (delete s[e][i], s[e] = s[e].filter(function (e) {
          return e;
        })), n;
      }, this.trigger = function (t) {
        var i = "on" + t[0].toUpperCase() + t.slice(1),
          r = Array.prototype.slice.call(arguments, 1);
        n[i] && n[i].apply(n, r);
        var o = s[t];
        return o ? (e.each(o, function (e, t) {
          t.apply(n, r);
        }), n) : n;
      }, init();
    };
    Module.prototype.__construct = function () {}, Module.prototype.getDefaultSettings = function () {
      return {};
    }, Module.prototype.getConstructorID = function () {
      return this.constructor.name;
    }, Module.extend = function (e) {
      var t = jQuery,
        n = this,
        child = function child() {
          return n.apply(this, arguments);
        };
      return t.extend(child, n), (child.prototype = Object.create(t.extend({}, n.prototype, e))).constructor = child, child.__super__ = n.prototype, child;
    }, e.exports = Module;
  },
  6516: function _(e, t, n) {
    "use strict";

    var s = n(7914)(n(2640));
    e.exports = s.default.extend({
      getDefaultSettings: function getDefaultSettings() {
        return {
          container: null,
          items: null,
          columnsCount: 3,
          verticalSpaceBetween: 30
        };
      },
      getDefaultElements: function getDefaultElements() {
        return {
          $container: jQuery(this.getSettings("container")),
          $items: jQuery(this.getSettings("items"))
        };
      },
      run: function run() {
        var e = [],
          t = this.elements.$container.position().top,
          n = this.getSettings(),
          s = n.columnsCount;
        t += parseInt(this.elements.$container.css("margin-top"), 10), this.elements.$items.each(function (i) {
          var r = Math.floor(i / s),
            o = jQuery(this),
            l = o[0].getBoundingClientRect().height + n.verticalSpaceBetween;
          if (r) {
            var c = o.position(),
              a = i % s,
              u = c.top - t - e[a];
            u -= parseInt(o.css("margin-top"), 10), u *= -1, o.css("margin-top", u + "px"), e[a] += l;
          } else e.push(l);
        });
      }
    });
  },
  400: function _(e, t) {
    "use strict";

    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    t.default = /*#__PURE__*/function () {
      function Scroll() {
        _classCallCheck(this, Scroll);
      }
      _createClass(Scroll, null, [{
        key: "scrollObserver",
        value: function scrollObserver(e) {
          var t = 0;
          var n = {
            root: e.root || null,
            rootMargin: e.offset || "0px",
            threshold: function () {
              var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
              var t = [];
              if (e > 0 && e <= 100) {
                var _n4 = 100 / e;
                for (var _e5 = 0; _e5 <= 100; _e5 += _n4) t.push(_e5 / 100);
              } else t.push(0);
              return t;
            }(e.sensitivity)
          };
          return new IntersectionObserver(function handleIntersect(n, s) {
            var i = n[0].boundingClientRect.y,
              r = n[0].isIntersecting,
              o = i < t ? "down" : "up",
              l = Math.abs(parseFloat((100 * n[0].intersectionRatio).toFixed(2)));
            e.callback({
              sensitivity: e.sensitivity,
              isInViewport: r,
              scrollPercentage: l,
              intersectionScrollDirection: o
            }), t = i;
          }, n);
        }
      }, {
        key: "getElementViewportPercentage",
        value: function getElementViewportPercentage(e) {
          var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var n = e[0].getBoundingClientRect(),
            s = t.start || 0,
            i = t.end || 0,
            r = window.innerHeight * s / 100,
            o = window.innerHeight * i / 100,
            l = n.top - window.innerHeight,
            c = 0 - l + r,
            a = n.top + r + e.height() - l + o,
            u = Math.max(0, Math.min(c / a, 1));
          return parseFloat((100 * u).toFixed(2));
        }
      }, {
        key: "getPageScrollPercentage",
        value: function getPageScrollPercentage() {
          var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var t = arguments.length > 1 ? arguments[1] : undefined;
          var n = e.start || 0,
            s = e.end || 0,
            i = t || document.documentElement.scrollHeight - document.documentElement.clientHeight,
            r = i * n / 100,
            o = i + r + i * s / 100;
          return (document.documentElement.scrollTop + document.body.scrollTop + r) / o * 100;
        }
      }]);
      return Scroll;
    }();
  },
  2640: function _(e, t, n) {
    "use strict";

    var s = n(7914)(n(1192));
    e.exports = s.default.extend({
      elements: null,
      getDefaultElements: function getDefaultElements() {
        return {};
      },
      bindEvents: function bindEvents() {},
      onInit: function onInit() {
        this.initElements(), this.bindEvents();
      },
      initElements: function initElements() {
        this.elements = this.getDefaultElements();
      }
    });
  },
  5955: function _(e, t, n) {
    "use strict";

    var s = n(7914);
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var i = s(n(1192)),
      r = s(n(2640)),
      o = s(n(2618)),
      l = s(n(6516)),
      c = s(n(400)),
      a = s(n(869)),
      u = window.elementorModules = {
        Module: i.default,
        ViewModule: r.default,
        ArgsObject: o.default,
        ForceMethodImplementation: a.default,
        utils: {
          Masonry: l.default,
          Scroll: c.default
        }
      };
    t.default = u;
  }
}, function (e) {
  var t;
  t = 6412, e(e.s = t);
}]);
!function () {
  "use strict";

  function Waypoint(options) {
    if (!options) throw new Error("No options passed to Waypoint constructor");
    if (!options.element) throw new Error("No element option passed to Waypoint constructor");
    if (!options.handler) throw new Error("No handler option passed to Waypoint constructor");
    this.key = "waypoint-" + keyCounter, this.options = Waypoint.Adapter.extend({}, Waypoint.defaults, options), this.element = this.options.element, this.adapter = new Waypoint.Adapter(this.element), this.callback = options.handler, this.axis = this.options.horizontal ? "horizontal" : "vertical", this.enabled = this.options.enabled, this.triggerPoint = null, this.group = Waypoint.Group.findOrCreate({
      name: this.options.group,
      axis: this.axis
    }), this.context = Waypoint.Context.findOrCreateByElement(this.options.context), Waypoint.offsetAliases[this.options.offset] && (this.options.offset = Waypoint.offsetAliases[this.options.offset]), this.group.add(this), this.context.add(this), allWaypoints[this.key] = this, keyCounter += 1;
  }
  var keyCounter = 0,
    allWaypoints = {};
  Waypoint.prototype.queueTrigger = function (direction) {
    this.group.queueTrigger(this, direction);
  }, Waypoint.prototype.trigger = function (args) {
    this.enabled && this.callback && this.callback.apply(this, args);
  }, Waypoint.prototype.destroy = function () {
    this.context.remove(this), this.group.remove(this), delete allWaypoints[this.key];
  }, Waypoint.prototype.disable = function () {
    return this.enabled = !1, this;
  }, Waypoint.prototype.enable = function () {
    return this.context.refresh(), this.enabled = !0, this;
  }, Waypoint.prototype.next = function () {
    return this.group.next(this);
  }, Waypoint.prototype.previous = function () {
    return this.group.previous(this);
  }, Waypoint.invokeAll = function (method) {
    var allWaypointsArray = [];
    for (var waypointKey in allWaypoints) allWaypointsArray.push(allWaypoints[waypointKey]);
    for (var i = 0, end = allWaypointsArray.length; i < end; i++) allWaypointsArray[i][method]();
  }, Waypoint.destroyAll = function () {
    Waypoint.invokeAll("destroy");
  }, Waypoint.disableAll = function () {
    Waypoint.invokeAll("disable");
  }, Waypoint.enableAll = function () {
    Waypoint.Context.refreshAll();
    for (var waypointKey in allWaypoints) allWaypoints[waypointKey].enabled = !0;
    return this;
  }, Waypoint.refreshAll = function () {
    Waypoint.Context.refreshAll();
  }, Waypoint.viewportHeight = function () {
    return window.innerHeight || document.documentElement.clientHeight;
  }, Waypoint.viewportWidth = function () {
    return document.documentElement.clientWidth;
  }, Waypoint.adapters = [], Waypoint.defaults = {
    context: window,
    continuous: !0,
    enabled: !0,
    group: "default",
    horizontal: !1,
    offset: 0
  }, Waypoint.offsetAliases = {
    "bottom-in-view": function bottomInView() {
      return this.context.innerHeight() - this.adapter.outerHeight();
    },
    "right-in-view": function rightInView() {
      return this.context.innerWidth() - this.adapter.outerWidth();
    }
  }, window.Waypoint = Waypoint;
}(), function () {
  "use strict";

  function requestAnimationFrameShim(callback) {
    window.setTimeout(callback, 1e3 / 60);
  }
  function Context(element) {
    this.element = element, this.Adapter = Waypoint.Adapter, this.adapter = new this.Adapter(element), this.key = "waypoint-context-" + keyCounter, this.didScroll = !1, this.didResize = !1, this.oldScroll = {
      x: this.adapter.scrollLeft(),
      y: this.adapter.scrollTop()
    }, this.waypoints = {
      vertical: {},
      horizontal: {}
    }, element.waypointContextKey = this.key, contexts[element.waypointContextKey] = this, keyCounter += 1, Waypoint.windowContext || (Waypoint.windowContext = !0, Waypoint.windowContext = new Context(window)), this.createThrottledScrollHandler(), this.createThrottledResizeHandler();
  }
  var keyCounter = 0,
    contexts = {},
    Waypoint = window.Waypoint,
    oldWindowLoad = window.onload;
  Context.prototype.add = function (waypoint) {
    var axis = waypoint.options.horizontal ? "horizontal" : "vertical";
    this.waypoints[axis][waypoint.key] = waypoint, this.refresh();
  }, Context.prototype.checkEmpty = function () {
    var horizontalEmpty = this.Adapter.isEmptyObject(this.waypoints.horizontal),
      verticalEmpty = this.Adapter.isEmptyObject(this.waypoints.vertical),
      isWindow = this.element == this.element.window;
    horizontalEmpty && verticalEmpty && !isWindow && (this.adapter.off(".waypoints"), delete contexts[this.key]);
  }, Context.prototype.createThrottledResizeHandler = function () {
    function resizeHandler() {
      self.handleResize(), self.didResize = !1;
    }
    var self = this;
    this.adapter.on("resize.waypoints", function () {
      self.didResize || (self.didResize = !0, Waypoint.requestAnimationFrame(resizeHandler));
    });
  }, Context.prototype.createThrottledScrollHandler = function () {
    function scrollHandler() {
      self.handleScroll(), self.didScroll = !1;
    }
    var self = this;
    this.adapter.on("scroll.waypoints", function () {
      self.didScroll && !Waypoint.isTouch || (self.didScroll = !0, Waypoint.requestAnimationFrame(scrollHandler));
    });
  }, Context.prototype.handleResize = function () {
    Waypoint.Context.refreshAll();
  }, Context.prototype.handleScroll = function () {
    var triggeredGroups = {},
      axes = {
        horizontal: {
          newScroll: this.adapter.scrollLeft(),
          oldScroll: this.oldScroll.x,
          forward: "right",
          backward: "left"
        },
        vertical: {
          newScroll: this.adapter.scrollTop(),
          oldScroll: this.oldScroll.y,
          forward: "down",
          backward: "up"
        }
      };
    for (var axisKey in axes) {
      var axis = axes[axisKey],
        isForward = axis.newScroll > axis.oldScroll,
        direction = isForward ? axis.forward : axis.backward;
      for (var waypointKey in this.waypoints[axisKey]) {
        var waypoint = this.waypoints[axisKey][waypointKey];
        if (null !== waypoint.triggerPoint) {
          var wasBeforeTriggerPoint = axis.oldScroll < waypoint.triggerPoint,
            nowAfterTriggerPoint = axis.newScroll >= waypoint.triggerPoint,
            crossedForward = wasBeforeTriggerPoint && nowAfterTriggerPoint,
            crossedBackward = !wasBeforeTriggerPoint && !nowAfterTriggerPoint;
          (crossedForward || crossedBackward) && (waypoint.queueTrigger(direction), triggeredGroups[waypoint.group.id] = waypoint.group);
        }
      }
    }
    for (var groupKey in triggeredGroups) triggeredGroups[groupKey].flushTriggers();
    this.oldScroll = {
      x: axes.horizontal.newScroll,
      y: axes.vertical.newScroll
    };
  }, Context.prototype.innerHeight = function () {
    return this.element == this.element.window ? Waypoint.viewportHeight() : this.adapter.innerHeight();
  }, Context.prototype.remove = function (waypoint) {
    delete this.waypoints[waypoint.axis][waypoint.key], this.checkEmpty();
  }, Context.prototype.innerWidth = function () {
    return this.element == this.element.window ? Waypoint.viewportWidth() : this.adapter.innerWidth();
  }, Context.prototype.destroy = function () {
    var allWaypoints = [];
    for (var axis in this.waypoints) for (var waypointKey in this.waypoints[axis]) allWaypoints.push(this.waypoints[axis][waypointKey]);
    for (var i = 0, end = allWaypoints.length; i < end; i++) allWaypoints[i].destroy();
  }, Context.prototype.refresh = function () {
    var axes,
      isWindow = this.element == this.element.window,
      contextOffset = isWindow ? void 0 : this.adapter.offset(),
      triggeredGroups = {};
    this.handleScroll(), axes = {
      horizontal: {
        contextOffset: isWindow ? 0 : contextOffset.left,
        contextScroll: isWindow ? 0 : this.oldScroll.x,
        contextDimension: this.innerWidth(),
        oldScroll: this.oldScroll.x,
        forward: "right",
        backward: "left",
        offsetProp: "left"
      },
      vertical: {
        contextOffset: isWindow ? 0 : contextOffset.top,
        contextScroll: isWindow ? 0 : this.oldScroll.y,
        contextDimension: this.innerHeight(),
        oldScroll: this.oldScroll.y,
        forward: "down",
        backward: "up",
        offsetProp: "top"
      }
    };
    for (var axisKey in axes) {
      var axis = axes[axisKey];
      for (var waypointKey in this.waypoints[axisKey]) {
        var contextModifier,
          wasBeforeScroll,
          nowAfterScroll,
          triggeredBackward,
          triggeredForward,
          waypoint = this.waypoints[axisKey][waypointKey],
          adjustment = waypoint.options.offset,
          oldTriggerPoint = waypoint.triggerPoint,
          elementOffset = 0,
          freshWaypoint = null == oldTriggerPoint;
        waypoint.element !== waypoint.element.window && (elementOffset = waypoint.adapter.offset()[axis.offsetProp]), "function" == typeof adjustment ? adjustment = adjustment.apply(waypoint) : "string" == typeof adjustment && (adjustment = parseFloat(adjustment), waypoint.options.offset.indexOf("%") > -1 && (adjustment = Math.ceil(axis.contextDimension * adjustment / 100))), contextModifier = axis.contextScroll - axis.contextOffset, waypoint.triggerPoint = Math.floor(elementOffset + contextModifier - adjustment), wasBeforeScroll = oldTriggerPoint < axis.oldScroll, nowAfterScroll = waypoint.triggerPoint >= axis.oldScroll, triggeredBackward = wasBeforeScroll && nowAfterScroll, triggeredForward = !wasBeforeScroll && !nowAfterScroll, !freshWaypoint && triggeredBackward ? (waypoint.queueTrigger(axis.backward), triggeredGroups[waypoint.group.id] = waypoint.group) : !freshWaypoint && triggeredForward ? (waypoint.queueTrigger(axis.forward), triggeredGroups[waypoint.group.id] = waypoint.group) : freshWaypoint && axis.oldScroll >= waypoint.triggerPoint && (waypoint.queueTrigger(axis.forward), triggeredGroups[waypoint.group.id] = waypoint.group);
      }
    }
    return Waypoint.requestAnimationFrame(function () {
      for (var groupKey in triggeredGroups) triggeredGroups[groupKey].flushTriggers();
    }), this;
  }, Context.findOrCreateByElement = function (element) {
    return Context.findByElement(element) || new Context(element);
  }, Context.refreshAll = function () {
    for (var contextId in contexts) contexts[contextId].refresh();
  }, Context.findByElement = function (element) {
    return contexts[element.waypointContextKey];
  }, window.onload = function () {
    oldWindowLoad && oldWindowLoad(), Context.refreshAll();
  }, Waypoint.requestAnimationFrame = function (callback) {
    var requestFn = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || requestAnimationFrameShim;
    requestFn.call(window, callback);
  }, Waypoint.Context = Context;
}(), function () {
  "use strict";

  function byTriggerPoint(a, b) {
    return a.triggerPoint - b.triggerPoint;
  }
  function byReverseTriggerPoint(a, b) {
    return b.triggerPoint - a.triggerPoint;
  }
  function Group(options) {
    this.name = options.name, this.axis = options.axis, this.id = this.name + "-" + this.axis, this.waypoints = [], this.clearTriggerQueues(), groups[this.axis][this.name] = this;
  }
  var groups = {
      vertical: {},
      horizontal: {}
    },
    Waypoint = window.Waypoint;
  Group.prototype.add = function (waypoint) {
    this.waypoints.push(waypoint);
  }, Group.prototype.clearTriggerQueues = function () {
    this.triggerQueues = {
      up: [],
      down: [],
      left: [],
      right: []
    };
  }, Group.prototype.flushTriggers = function () {
    for (var direction in this.triggerQueues) {
      var waypoints = this.triggerQueues[direction],
        reverse = "up" === direction || "left" === direction;
      waypoints.sort(reverse ? byReverseTriggerPoint : byTriggerPoint);
      for (var i = 0, end = waypoints.length; i < end; i += 1) {
        var waypoint = waypoints[i];
        (waypoint.options.continuous || i === waypoints.length - 1) && waypoint.trigger([direction]);
      }
    }
    this.clearTriggerQueues();
  }, Group.prototype.next = function (waypoint) {
    this.waypoints.sort(byTriggerPoint);
    var index = Waypoint.Adapter.inArray(waypoint, this.waypoints),
      isLast = index === this.waypoints.length - 1;
    return isLast ? null : this.waypoints[index + 1];
  }, Group.prototype.previous = function (waypoint) {
    this.waypoints.sort(byTriggerPoint);
    var index = Waypoint.Adapter.inArray(waypoint, this.waypoints);
    return index ? this.waypoints[index - 1] : null;
  }, Group.prototype.queueTrigger = function (waypoint, direction) {
    this.triggerQueues[direction].push(waypoint);
  }, Group.prototype.remove = function (waypoint) {
    var index = Waypoint.Adapter.inArray(waypoint, this.waypoints);
    index > -1 && this.waypoints.splice(index, 1);
  }, Group.prototype.first = function () {
    return this.waypoints[0];
  }, Group.prototype.last = function () {
    return this.waypoints[this.waypoints.length - 1];
  }, Group.findOrCreate = function (options) {
    return groups[options.axis][options.name] || new Group(options);
  }, Waypoint.Group = Group;
}(), function () {
  "use strict";

  function JQueryAdapter(element) {
    this.$element = $(element);
  }
  var $ = window.jQuery,
    Waypoint = window.Waypoint;
  $.each(["innerHeight", "innerWidth", "off", "offset", "on", "outerHeight", "outerWidth", "scrollLeft", "scrollTop"], function (i, method) {
    JQueryAdapter.prototype[method] = function () {
      var args = Array.prototype.slice.call(arguments);
      return this.$element[method].apply(this.$element, args);
    };
  }), $.each(["extend", "inArray", "isEmptyObject"], function (i, method) {
    JQueryAdapter[method] = $[method];
  }), Waypoint.adapters.push({
    name: "jquery",
    Adapter: JQueryAdapter
  }), Waypoint.Adapter = JQueryAdapter;
}(), function () {
  "use strict";

  function createExtension(framework) {
    return function () {
      var waypoints = [],
        overrides = arguments[0];
      return framework.isFunction(arguments[0]) && (overrides = framework.extend({}, arguments[1]), overrides.handler = arguments[0]), this.each(function () {
        var options = framework.extend({}, overrides, {
          element: this
        });
        "string" == typeof options.context && (options.context = framework(this).closest(options.context)[0]), waypoints.push(new Waypoint(options));
      }), waypoints;
    };
  }
  var Waypoint = window.Waypoint;
  window.jQuery && (window.jQuery.fn.elementorWaypoint = createExtension(window.jQuery)), window.Zepto && (window.Zepto.fn.elementorWaypoint = createExtension(window.Zepto));
}();
/*! elementor - v3.5.6 - 28-02-2022 */
"use strict";
(self.webpackChunkelementor = self.webpackChunkelementor || []).push([[819], {
  9220: function _(e, t, n) {
    var i = n(7914);
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var s = i(n(8135));
    var _default = /*#__PURE__*/function (_elementorModules$Vie2) {
      _inherits(_default, _elementorModules$Vie2);
      var _super5 = _createSuper(_default);
      function _default() {
        var _this7;
        _classCallCheck(this, _default);
        for (var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++) {
          e[_key] = arguments[_key];
        }
        _this7 = _super5.call.apply(_super5, [this].concat(e)), _this7.documents = {}, _this7.initDocumentClasses(), _this7.attachDocumentsClasses();
        return _this7;
      }
      _createClass(_default, [{
        key: "getDefaultSettings",
        value: function getDefaultSettings() {
          return {
            selectors: {
              document: ".elementor"
            }
          };
        }
      }, {
        key: "getDefaultElements",
        value: function getDefaultElements() {
          var e = this.getSettings("selectors");
          return {
            $documents: jQuery(e.document)
          };
        }
      }, {
        key: "initDocumentClasses",
        value: function initDocumentClasses() {
          this.documentClasses = {
            base: s.default
          }, elementorFrontend.hooks.doAction("elementor/frontend/documents-manager/init-classes", this);
        }
      }, {
        key: "addDocumentClass",
        value: function addDocumentClass(e, t) {
          this.documentClasses[e] = t;
        }
      }, {
        key: "attachDocumentsClasses",
        value: function attachDocumentsClasses() {
          var _this8 = this;
          this.elements.$documents.each(function (e, t) {
            return _this8.attachDocumentClass(jQuery(t));
          });
        }
      }, {
        key: "attachDocumentClass",
        value: function attachDocumentClass(e) {
          var t = e.data(),
            n = t.elementorId,
            i = t.elementorType,
            s = this.documentClasses[i] || this.documentClasses.base;
          this.documents[n] = new s({
            $element: e,
            id: n
          });
        }
      }]);
      return _default;
    }(elementorModules.ViewModule);
    t.default = _default;
  },
  9804: function _(e, t, n) {
    var i = n(7914),
      s = i(n(6397)),
      o = i(n(9320)),
      r = i(n(7537));
    e.exports = function (e) {
      var _this9 = this;
      var t = {};
      this.elementsHandlers = {
        "accordion.default": function accordionDefault() {
          return n.e(209).then(n.bind(n, 8470));
        },
        "alert.default": function alertDefault() {
          return n.e(745).then(n.bind(n, 9269));
        },
        "counter.default": function counterDefault() {
          return n.e(120).then(n.bind(n, 7884));
        },
        "progress.default": function progressDefault() {
          return n.e(192).then(n.bind(n, 1351));
        },
        "tabs.default": function tabsDefault() {
          return n.e(520).then(n.bind(n, 9459));
        },
        "toggle.default": function toggleDefault() {
          return n.e(181).then(n.bind(n, 2));
        },
        "video.default": function videoDefault() {
          return n.e(791).then(n.bind(n, 5363));
        },
        "image-carousel.default": function imageCarouselDefault() {
          return n.e(268).then(n.bind(n, 5914));
        },
        "text-editor.default": function textEditorDefault() {
          return n.e(357).then(n.bind(n, 1327));
        },
        "wp-widget-media_audio.default": function wpWidgetMedia_audioDefault() {
          return n.e(52).then(n.bind(n, 7602));
        }
      };
      var addElementsHandlers = function addElementsHandlers() {
          _this9.elementsHandlers.section = o.default, _this9.elementsHandlers.column = r.default, e.each(_this9.elementsHandlers, function (e, t) {
            var n = e.split(".");
            e = n[0];
            var i = n[1] || null;
            _this9.attachHandler(e, t, i);
          });
        },
        isClassHandler = function isClassHandler(e) {
          var t;
          return null === (t = e.prototype) || void 0 === t ? void 0 : t.getUniqueHandlerID;
        },
        addHandlerWithHook = function addHandlerWithHook(e, t) {
          var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "default";
          n = n ? "." + n : "", elementorFrontend.hooks.addAction("frontend/element_ready/".concat(e).concat(n), function (e) {
            if (isClassHandler(t)) _this9.addHandler(t, {
              $element: e
            }, !0);else {
              var _n5 = t();
              _n5 instanceof Promise ? _n5.then(function (_ref2) {
                var t = _ref2.default;
                _this9.addHandler(t, {
                  $element: e
                }, !0);
              }) : _this9.addHandler(_n5, {
                $element: e
              }, !0);
            }
          });
        };
      this.addHandler = function (e, n) {
        var i = n.$element.data("model-cid");
        var s;
        if (i) {
          s = e.prototype.getConstructorID(), t[i] || (t[i] = {});
          var _n6 = t[i][s];
          _n6 && _n6.onDestroy();
        }
        var o = new e(n);
        i && (t[i][s] = o);
      }, this.attachHandler = function (e, t, n) {
        Array.isArray(t) || (t = [t]), t.forEach(function (t) {
          return addHandlerWithHook(e, t, n);
        });
      }, this.getHandler = function (e) {
        if (!e) return;
        var t = this.elementsHandlers[e];
        return isClassHandler(t) ? t : new Promise(function (e) {
          t().then(function (_ref3) {
            var t = _ref3.default;
            e(t);
          });
        });
      }, this.getHandlers = function (e) {
        return elementorCommon.helpers.softDeprecated("getHandlers", "3.1.0", "elementorFrontend.elementsHandler.getHandler"), e ? this.getHandler(e) : this.elementsHandlers;
      }, this.runReadyTrigger = function (t) {
        if (elementorFrontend.config.is_static) return;
        var n = jQuery(t),
          i = n.attr("data-element_type");
        if (i && (elementorFrontend.hooks.doAction("frontend/element_ready/global", n, e), elementorFrontend.hooks.doAction("frontend/element_ready/".concat(i), n, e), "widget" === i)) {
          var _t7 = n.attr("data-widget_type");
          elementorFrontend.hooks.doAction("frontend/element_ready/".concat(_t7), n, e);
        }
      }, this.init = function () {
        elementorFrontend.hooks.addAction("frontend/element_ready/global", s.default), addElementsHandlers();
      };
    };
  },
  5654: function _(e, t, n) {
    var i = n(7914);
    n(59);
    var s = i(n(9220)),
      o = i(n(5107)),
      r = i(n(3308)),
      a = i(n(1604)),
      l = i(n(1911)),
      d = i(n(4773)),
      c = i(n(2064)),
      u = i(n(8628)),
      h = i(n(8646)),
      m = i(n(6866)),
      g = i(n(4375)),
      p = i(n(6404)),
      f = i(n(6046)),
      v = n(6028);
    var b = n(9469),
      y = n(9804),
      _ = n(3346);
    var Frontend = /*#__PURE__*/function (_elementorModules$Vie3) {
      _inherits(Frontend, _elementorModules$Vie3);
      var _super6 = _createSuper(Frontend);
      function Frontend() {
        var _this10;
        _classCallCheck(this, Frontend);
        for (var _len2 = arguments.length, e = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          e[_key2] = arguments[_key2];
        }
        _this10 = _super6.call.apply(_super6, [this].concat(e)), _this10.config = elementorFrontendConfig, _this10.config.legacyMode = {
          get elementWrappers() {
            return elementorFrontend.isEditMode() && elementorCommon.helpers.hardDeprecated("elementorFrontend.config.legacyMode.elementWrappers", "3.1.0", "elementorFrontend.config.experimentalFeatures.e_dom_optimization"), !elementorFrontend.config.experimentalFeatures.e_dom_optimization;
          }
        }, _this10.populateActiveBreakpointsConfig();
        return _this10;
      }
      _createClass(Frontend, [{
        key: "Module",
        get: function get() {
          return this.isEditMode() && parent.elementorCommon.helpers.hardDeprecated("elementorFrontend.Module", "2.5.0", "elementorModules.frontend.handlers.Base"), elementorModules.frontend.handlers.Base;
        }
      }, {
        key: "getDefaultSettings",
        value: function getDefaultSettings() {
          return {
            selectors: {
              elementor: ".elementor",
              adminBar: "#wpadminbar"
            }
          };
        }
      }, {
        key: "getDefaultElements",
        value: function getDefaultElements() {
          var e = {
            window: window,
            $window: jQuery(window),
            $document: jQuery(document),
            $head: jQuery(document.head),
            $body: jQuery(document.body),
            $deviceMode: jQuery("<span>", {
              id: "elementor-device-mode",
              class: "elementor-screen-only"
            })
          };
          return e.$body.append(e.$deviceMode), e;
        }
      }, {
        key: "bindEvents",
        value: function bindEvents() {
          var _this11 = this;
          this.elements.$window.on("resize", function () {
            return _this11.setDeviceModeData();
          });
        }
      }, {
        key: "getElements",
        value: function getElements(e) {
          return this.getItems(this.elements, e);
        }
      }, {
        key: "getPageSettings",
        value: function getPageSettings(e) {
          var t = this.isEditMode() ? elementor.settings.page.model.attributes : this.config.settings.page;
          return this.getItems(t, e);
        }
      }, {
        key: "getGeneralSettings",
        value: function getGeneralSettings(e) {
          return this.isEditMode() && parent.elementorCommon.helpers.softDeprecated("getGeneralSettings", "3.0.0", "getKitSettings and remove the `elementor_` prefix"), this.getKitSettings("elementor_".concat(e));
        }
      }, {
        key: "getKitSettings",
        value: function getKitSettings(e) {
          return this.getItems(this.config.kit, e);
        }
      }, {
        key: "getCurrentDeviceMode",
        value: function getCurrentDeviceMode() {
          return getComputedStyle(this.elements.$deviceMode[0], ":after").content.replace(/"/g, "");
        }
      }, {
        key: "getDeviceSetting",
        value: function getDeviceSetting(e, t, n) {
          if ("widescreen" === e) return this.getWidescreenSetting(t, n);
          var i = elementorFrontend.breakpoints.getActiveBreakpointsList({
            largeToSmall: !0,
            withDesktop: !0
          });
          var s = i.indexOf(e);
          for (; s > 0;) {
            var _e6 = t[n + "_" + i[s]];
            if (_e6 || 0 === _e6) return _e6;
            s--;
          }
          return t[n];
        }
      }, {
        key: "getWidescreenSetting",
        value: function getWidescreenSetting(e, t) {
          var n = t + "_widescreen";
          var i;
          return i = e[n] ? e[n] : e[t], i;
        }
      }, {
        key: "getCurrentDeviceSetting",
        value: function getCurrentDeviceSetting(e, t) {
          return this.getDeviceSetting(elementorFrontend.getCurrentDeviceMode(), e, t);
        }
      }, {
        key: "isEditMode",
        value: function isEditMode() {
          return this.config.environmentMode.edit;
        }
      }, {
        key: "isWPPreviewMode",
        value: function isWPPreviewMode() {
          return this.config.environmentMode.wpPreview;
        }
      }, {
        key: "initDialogsManager",
        value: function initDialogsManager() {
          var e;
          this.getDialogsManager = function () {
            return e || (e = new DialogsManager.Instance()), e;
          };
        }
      }, {
        key: "initOnReadyComponents",
        value: function initOnReadyComponents() {
          var _this12 = this;
          this.utils = {
            youtube: new a.default(),
            vimeo: new l.default(),
            baseVideoLoader: new d.default(),
            anchors: new _(),
            get lightbox() {
              return h.default.getLightbox();
            },
            urlActions: new c.default(),
            swiper: u.default,
            environment: r.default,
            assetsLoader: new m.default(),
            escapeHTML: v.escapeHTML
          }, this.modules = {
            StretchElement: elementorModules.frontend.tools.StretchElement,
            Masonry: elementorModules.utils.Masonry
          }, this.elementsHandler.init(), this.isEditMode() ? elementor.once("document:loaded", function () {
            return _this12.onDocumentLoaded();
          }) : this.onDocumentLoaded();
        }
      }, {
        key: "initOnReadyElements",
        value: function initOnReadyElements() {
          this.elements.$wpAdminBar = this.elements.$document.find(this.getSettings("selectors.adminBar"));
        }
      }, {
        key: "addUserAgentClasses",
        value: function addUserAgentClasses() {
          for (var _i2 = 0, _Object$entries = Object.entries(r.default); _i2 < _Object$entries.length; _i2++) {
            var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
              _e7 = _Object$entries$_i[0],
              _t8 = _Object$entries$_i[1];
            _t8 && this.elements.$body.addClass("e--ua-" + _e7);
          }
        }
      }, {
        key: "setDeviceModeData",
        value: function setDeviceModeData() {
          this.elements.$body.attr("data-elementor-device-mode", this.getCurrentDeviceMode());
        }
      }, {
        key: "addListenerOnce",
        value: function addListenerOnce(e, t, n, i) {
          if (i || (i = this.elements.$window), this.isEditMode()) {
            if (this.removeListeners(e, t, i), i instanceof jQuery) {
              var _s3 = t + "." + e;
              i.on(_s3, n);
            } else i.on(t, n, e);
          } else i.on(t, n);
        }
      }, {
        key: "removeListeners",
        value: function removeListeners(e, t, n, i) {
          if (i || (i = this.elements.$window), i instanceof jQuery) {
            var _s4 = t + "." + e;
            i.off(_s4, n);
          } else i.off(t, n, e);
        }
      }, {
        key: "debounce",
        value: function debounce(e, t) {
          var n;
          return function () {
            var i = this,
              s = arguments,
              later = function later() {
                n = null, e.apply(i, s);
              },
              o = !n;
            clearTimeout(n), n = setTimeout(later, t), o && e.apply(i, s);
          };
        }
      }, {
        key: "waypoint",
        value: function waypoint(e, t, n) {
          n = jQuery.extend({
            offset: "100%",
            triggerOnce: !0
          }, n);
          return e.elementorWaypoint(function () {
            var e = this.element || this,
              i = t.apply(e, arguments);
            return n.triggerOnce && this.destroy && this.destroy(), i;
          }, n);
        }
      }, {
        key: "muteMigrationTraces",
        value: function muteMigrationTraces() {
          jQuery.migrateMute = !0, jQuery.migrateTrace = !1;
        }
      }, {
        key: "initModules",
        value: function initModules() {
          var _this13 = this;
          var e = {
            shapes: f.default
          };
          elementorFrontend.trigger("elementor/modules/init:before"), elementorFrontend.trigger("elementor/modules/init/before"), Object.entries(e).forEach(function (_ref4) {
            var _ref5 = _slicedToArray(_ref4, 2),
              e = _ref5[0],
              t = _ref5[1];
            _this13.modulesHandlers[e] = new t();
          });
        }
      }, {
        key: "populateActiveBreakpointsConfig",
        value: function populateActiveBreakpointsConfig() {
          var _this14 = this;
          this.config.responsive.activeBreakpoints = {}, Object.entries(this.config.responsive.breakpoints).forEach(function (_ref6) {
            var _ref7 = _slicedToArray(_ref6, 2),
              e = _ref7[0],
              t = _ref7[1];
            t.is_enabled && (_this14.config.responsive.activeBreakpoints[e] = t);
          });
        }
      }, {
        key: "init",
        value: function init() {
          this.hooks = new b(), this.breakpoints = new g.default(this.config.responsive), this.storage = new o.default(), this.elementsHandler = new y(jQuery), this.modulesHandlers = {}, this.addUserAgentClasses(), this.setDeviceModeData(), this.initDialogsManager(), this.isEditMode() && this.muteMigrationTraces(), p.default.dispatch(this.elements.$window, "elementor/frontend/init"), this.initModules(), this.initOnReadyElements(), this.initOnReadyComponents();
        }
      }, {
        key: "onDocumentLoaded",
        value: function onDocumentLoaded() {
          this.documentsManager = new s.default(), this.trigger("components:init"), new h.default();
        }
      }]);
      return Frontend;
    }(elementorModules.ViewModule);
    window.elementorFrontend = new Frontend(), elementorFrontend.isEditMode() || jQuery(function () {
      return elementorFrontend.init();
    });
  },
  4058: function _(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var BackgroundSlideshow = /*#__PURE__*/function (_elementorModules$fro) {
      _inherits(BackgroundSlideshow, _elementorModules$fro);
      var _super7 = _createSuper(BackgroundSlideshow);
      function BackgroundSlideshow() {
        _classCallCheck(this, BackgroundSlideshow);
        return _super7.apply(this, arguments);
      }
      _createClass(BackgroundSlideshow, [{
        key: "getDefaultSettings",
        value: function getDefaultSettings() {
          return {
            classes: {
              swiperContainer: "elementor-background-slideshow swiper-container",
              swiperWrapper: "swiper-wrapper",
              swiperSlide: "elementor-background-slideshow__slide swiper-slide",
              slideBackground: "elementor-background-slideshow__slide__image",
              kenBurns: "elementor-ken-burns",
              kenBurnsActive: "elementor-ken-burns--active",
              kenBurnsIn: "elementor-ken-burns--in",
              kenBurnsOut: "elementor-ken-burns--out"
            }
          };
        }
      }, {
        key: "getSwiperOptions",
        value: function getSwiperOptions() {
          var _this15 = this;
          var e = this.getElementSettings(),
            t = {
              grabCursor: !1,
              slidesPerView: 1,
              slidesPerGroup: 1,
              loop: "yes" === e.background_slideshow_loop,
              speed: e.background_slideshow_transition_duration,
              autoplay: {
                delay: e.background_slideshow_slide_duration,
                stopOnLastSlide: !e.background_slideshow_loop
              },
              handleElementorBreakpoints: !0,
              on: {
                slideChange: function slideChange() {
                  e.background_slideshow_ken_burns && _this15.handleKenBurns();
                }
              }
            };
          switch ("yes" === e.background_slideshow_loop && (t.loopedSlides = this.getSlidesCount()), e.background_slideshow_slide_transition) {
            case "fade":
              t.effect = "fade", t.fadeEffect = {
                crossFade: !0
              };
              break;
            case "slide_down":
              t.autoplay.reverseDirection = !0;
            case "slide_up":
              t.direction = "vertical";
          }
          return t;
        }
      }, {
        key: "buildSwiperElements",
        value: function buildSwiperElements() {
          var _this16 = this;
          var e = this.getSettings("classes"),
            t = this.getElementSettings(),
            n = "slide_left" === t.background_slideshow_slide_transition ? "ltr" : "rtl",
            i = jQuery("<div>", {
              class: e.swiperContainer,
              dir: n
            }),
            s = jQuery("<div>", {
              class: e.swiperWrapper
            }),
            o = t.background_slideshow_ken_burns;
          var r = e.slideBackground;
          if (o) {
            r += " " + e.kenBurns;
            var _n7 = "in" === t.background_slideshow_ken_burns_zoom_direction ? "kenBurnsIn" : "kenBurnsOut";
            r += " " + e[_n7];
          }
          this.elements.$slides = jQuery(), t.background_slideshow_gallery.forEach(function (t) {
            var n = jQuery("<div>", {
                class: e.swiperSlide
              }),
              i = jQuery("<div>", {
                class: r,
                style: 'background-image: url("' + t.url + '");'
              });
            n.append(i), s.append(n), _this16.elements.$slides = _this16.elements.$slides.add(n);
          }), i.append(s), this.$element.prepend(i), this.elements.$backgroundSlideShowContainer = i;
        }
      }, {
        key: "initSlider",
        value: function () {
          var _initSlider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
            var e, t;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  if (!(1 >= this.getSlidesCount())) {
                    _context.next = 2;
                    break;
                  }
                  return _context.abrupt("return");
                case 2:
                  e = this.getElementSettings(), t = elementorFrontend.utils.swiper;
                  _context.next = 5;
                  return new t(this.elements.$backgroundSlideShowContainer, this.getSwiperOptions());
                case 5:
                  this.swiper = _context.sent;
                  this.elements.$backgroundSlideShowContainer.data("swiper", this.swiper);
                  e.background_slideshow_ken_burns && this.handleKenBurns();
                case 8:
                case "end":
                  return _context.stop();
              }
            }, _callee, this);
          }));
          function initSlider() {
            return _initSlider.apply(this, arguments);
          }
          return initSlider;
        }()
      }, {
        key: "activate",
        value: function activate() {
          this.buildSwiperElements(), this.initSlider();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.swiper && (this.swiper.destroy(), this.elements.$backgroundSlideShowContainer.remove());
        }
      }, {
        key: "run",
        value: function run() {
          "slideshow" === this.getElementSettings("background_background") ? this.activate() : this.deactivate();
        }
      }, {
        key: "onInit",
        value: function onInit() {
          _get(_getPrototypeOf(BackgroundSlideshow.prototype), "onInit", this).call(this), this.getElementSettings("background_slideshow_gallery") && this.run();
        }
      }, {
        key: "onDestroy",
        value: function onDestroy() {
          _get(_getPrototypeOf(BackgroundSlideshow.prototype), "onDestroy", this).call(this), this.deactivate();
        }
      }, {
        key: "onElementChange",
        value: function onElementChange(e) {
          "background_background" === e && this.run();
        }
      }]);
      return BackgroundSlideshow;
    }(elementorModules.frontend.handlers.SwiperBase);
    t.default = BackgroundSlideshow;
  },
  7537: function _(e, t, n) {
    var i = n(7914);
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var s = [i(n(4058)).default];
    t.default = s;
  },
  6397: function _(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var GlobalHandler = /*#__PURE__*/function (_elementorModules$fro2) {
      _inherits(GlobalHandler, _elementorModules$fro2);
      var _super8 = _createSuper(GlobalHandler);
      function GlobalHandler() {
        _classCallCheck(this, GlobalHandler);
        return _super8.apply(this, arguments);
      }
      _createClass(GlobalHandler, [{
        key: "getWidgetType",
        value: function getWidgetType() {
          return "global";
        }
      }, {
        key: "animate",
        value: function animate() {
          var e = this.$element,
            t = this.getAnimation();
          if ("none" === t) return void e.removeClass("elementor-invisible");
          var n = this.getElementSettings(),
            i = n._animation_delay || n.animation_delay || 0;
          e.removeClass(t), this.currentAnimation && e.removeClass(this.currentAnimation), this.currentAnimation = t, setTimeout(function () {
            e.removeClass("elementor-invisible").addClass("animated " + t);
          }, i);
        }
      }, {
        key: "getAnimation",
        value: function getAnimation() {
          return this.getCurrentDeviceSetting("animation") || this.getCurrentDeviceSetting("_animation");
        }
      }, {
        key: "onInit",
        value: function onInit() {
          var _get2,
            _this17 = this;
          for (var _len3 = arguments.length, e = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            e[_key3] = arguments[_key3];
          }
          if ((_get2 = _get(_getPrototypeOf(GlobalHandler.prototype), "onInit", this)).call.apply(_get2, [this].concat(e)), this.getAnimation()) {
            var _e8 = elementorModules.utils.Scroll.scrollObserver({
              callback: function callback(t) {
                t.isInViewport && (_this17.animate(), _e8.unobserve(_this17.$element[0]));
              }
            });
            _e8.observe(this.$element[0]);
          }
        }
      }, {
        key: "onElementChange",
        value: function onElementChange(e) {
          /^_?animation/.test(e) && this.animate();
        }
      }]);
      return GlobalHandler;
    }(elementorModules.frontend.handlers.Base);
    t.default = function (e) {
      elementorFrontend.elementsHandler.addHandler(GlobalHandler, {
        $element: e
      });
    };
  },
  2987: function _(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var BackgroundVideo = /*#__PURE__*/function (_elementorModules$fro3) {
      _inherits(BackgroundVideo, _elementorModules$fro3);
      var _super9 = _createSuper(BackgroundVideo);
      function BackgroundVideo() {
        _classCallCheck(this, BackgroundVideo);
        return _super9.apply(this, arguments);
      }
      _createClass(BackgroundVideo, [{
        key: "getDefaultSettings",
        value: function getDefaultSettings() {
          return {
            selectors: {
              backgroundVideoContainer: ".elementor-background-video-container",
              backgroundVideoEmbed: ".elementor-background-video-embed",
              backgroundVideoHosted: ".elementor-background-video-hosted"
            }
          };
        }
      }, {
        key: "getDefaultElements",
        value: function getDefaultElements() {
          var e = this.getSettings("selectors"),
            t = {
              $backgroundVideoContainer: this.$element.find(e.backgroundVideoContainer)
            };
          return t.$backgroundVideoEmbed = t.$backgroundVideoContainer.children(e.backgroundVideoEmbed), t.$backgroundVideoHosted = t.$backgroundVideoContainer.children(e.backgroundVideoHosted), t;
        }
      }, {
        key: "calcVideosSize",
        value: function calcVideosSize(e) {
          var t = "16:9";
          "vimeo" === this.videoType && (t = e[0].width + ":" + e[0].height);
          var n = this.elements.$backgroundVideoContainer.outerWidth(),
            i = this.elements.$backgroundVideoContainer.outerHeight(),
            s = t.split(":"),
            o = s[0] / s[1],
            r = n / i > o;
          return {
            width: r ? n : i * o,
            height: r ? n / o : i
          };
        }
      }, {
        key: "changeVideoSize",
        value: function changeVideoSize() {
          if ("hosted" !== this.videoType && !this.player) return;
          var e;
          if ("youtube" === this.videoType ? e = jQuery(this.player.getIframe()) : "vimeo" === this.videoType ? e = jQuery(this.player.element) : "hosted" === this.videoType && (e = this.elements.$backgroundVideoHosted), !e) return;
          var t = this.calcVideosSize(e);
          e.width(t.width).height(t.height);
        }
      }, {
        key: "startVideoLoop",
        value: function startVideoLoop(e) {
          var _this18 = this;
          if (!this.player.getIframe().contentWindow) return;
          var t = this.getElementSettings(),
            n = t.background_video_start || 0,
            i = t.background_video_end;
          if (!t.background_play_once || e) {
            if (this.player.seekTo(n), i) {
              setTimeout(function () {
                _this18.startVideoLoop(!1);
              }, 1e3 * (i - n + 1));
            }
          } else this.player.stopVideo();
        }
      }, {
        key: "prepareVimeoVideo",
        value: function prepareVimeoVideo(e, t) {
          var _this19 = this;
          var n = this.getElementSettings(),
            i = {
              url: t,
              width: this.elements.$backgroundVideoContainer.outerWidth().width,
              autoplay: !0,
              loop: !n.background_play_once,
              transparent: !1,
              background: !0,
              muted: !0
            };
          this.player = new e.Player(this.elements.$backgroundVideoContainer, i), this.handleVimeoStartEndTimes(n), this.player.ready().then(function () {
            jQuery(_this19.player.element).addClass("elementor-background-video-embed"), _this19.changeVideoSize();
          });
        }
      }, {
        key: "handleVimeoStartEndTimes",
        value: function handleVimeoStartEndTimes(e) {
          var _this20 = this;
          e.background_video_start && this.player.on("play", function (t) {
            0 === t.seconds && _this20.player.setCurrentTime(e.background_video_start);
          }), this.player.on("timeupdate", function (t) {
            e.background_video_end && e.background_video_end < t.seconds && (e.background_play_once ? _this20.player.pause() : _this20.player.setCurrentTime(e.background_video_start)), _this20.player.getDuration().then(function (n) {
              e.background_video_start && !e.background_video_end && t.seconds > n - .5 && _this20.player.setCurrentTime(e.background_video_start);
            });
          });
        }
      }, {
        key: "prepareYTVideo",
        value: function prepareYTVideo(e, t) {
          var _this21 = this;
          var n = this.elements.$backgroundVideoContainer,
            i = this.getElementSettings();
          var s = e.PlayerState.PLAYING;
          window.chrome && (s = e.PlayerState.UNSTARTED);
          var o = {
            videoId: t,
            events: {
              onReady: function onReady() {
                _this21.player.mute(), _this21.changeVideoSize(), _this21.startVideoLoop(!0), _this21.player.playVideo();
              },
              onStateChange: function onStateChange(t) {
                switch (t.data) {
                  case s:
                    n.removeClass("elementor-invisible elementor-loading");
                    break;
                  case e.PlayerState.ENDED:
                    _this21.player.seekTo(i.background_video_start || 0), i.background_play_once && _this21.player.destroy();
                }
              }
            },
            playerVars: {
              controls: 0,
              rel: 0,
              playsinline: 1
            }
          };
          i.background_privacy_mode && (o.host = "https://www.youtube-nocookie.com", o.origin = window.location.hostname), n.addClass("elementor-loading elementor-invisible"), this.player = new e.Player(this.elements.$backgroundVideoEmbed[0], o);
        }
      }, {
        key: "activate",
        value: function activate() {
          var _this22 = this;
          var e,
            t = this.getElementSettings("background_video_link");
          var n = this.getElementSettings("background_play_once");
          if (-1 !== t.indexOf("vimeo.com") ? (this.videoType = "vimeo", this.apiProvider = elementorFrontend.utils.vimeo) : t.match(/^(?:https?:\/\/)?(?:www\.)?(?:m\.)?(?:youtu\.be\/|youtube\.com)/) && (this.videoType = "youtube", this.apiProvider = elementorFrontend.utils.youtube), this.apiProvider) e = this.apiProvider.getVideoIDFromURL(t), this.apiProvider.onApiReady(function (n) {
            "youtube" === _this22.videoType && _this22.prepareYTVideo(n, e), "vimeo" === _this22.videoType && _this22.prepareVimeoVideo(n, t);
          });else {
            this.videoType = "hosted";
            var _e9 = this.getElementSettings("background_video_start"),
              i = this.getElementSettings("background_video_end");
            (_e9 || i) && (t += "#t=" + (_e9 || 0) + (i ? "," + i : "")), this.elements.$backgroundVideoHosted.attr("src", t).one("canplay", this.changeVideoSize.bind(this)), n && this.elements.$backgroundVideoHosted.on("ended", function () {
              _this22.elements.$backgroundVideoHosted.hide();
            });
          }
          elementorFrontend.elements.$window.on("resize", this.changeVideoSize);
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          "youtube" === this.videoType && this.player.getIframe() || "vimeo" === this.videoType ? this.player.destroy() : this.elements.$backgroundVideoHosted.removeAttr("src").off("ended"), elementorFrontend.elements.$window.off("resize", this.changeVideoSize);
        }
      }, {
        key: "run",
        value: function run() {
          var e = this.getElementSettings();
          (e.background_play_on_mobile || "mobile" !== elementorFrontend.getCurrentDeviceMode()) && ("video" === e.background_background && e.background_video_link ? this.activate() : this.deactivate());
        }
      }, {
        key: "onInit",
        value: function onInit() {
          var _get3;
          for (var _len4 = arguments.length, e = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            e[_key4] = arguments[_key4];
          }
          (_get3 = _get(_getPrototypeOf(BackgroundVideo.prototype), "onInit", this)).call.apply(_get3, [this].concat(e)), this.changeVideoSize = this.changeVideoSize.bind(this), this.run();
        }
      }, {
        key: "onElementChange",
        value: function onElementChange(e) {
          "background_background" === e && this.run();
        }
      }]);
      return BackgroundVideo;
    }(elementorModules.frontend.handlers.Base);
    t.default = BackgroundVideo;
  },
  355: function _(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var HandlesPosition = /*#__PURE__*/function (_elementorModules$fro4) {
      _inherits(HandlesPosition, _elementorModules$fro4);
      var _super10 = _createSuper(HandlesPosition);
      function HandlesPosition() {
        _classCallCheck(this, HandlesPosition);
        return _super10.apply(this, arguments);
      }
      _createClass(HandlesPosition, [{
        key: "isActive",
        value: function isActive() {
          return elementorFrontend.isEditMode();
        }
      }, {
        key: "isFirstSection",
        value: function isFirstSection() {
          return this.$element[0] === document.querySelector(".elementor-edit-mode .elementor-top-section");
        }
      }, {
        key: "isOverflowHidden",
        value: function isOverflowHidden() {
          return "hidden" === this.$element.css("overflow");
        }
      }, {
        key: "getOffset",
        value: function getOffset() {
          if ("body" === elementor.config.document.container) return this.$element.offset().top;
          var e = jQuery(elementor.config.document.container);
          return this.$element.offset().top - e.offset().top;
        }
      }, {
        key: "setHandlesPosition",
        value: function setHandlesPosition() {
          var e = elementor.documents.getCurrent();
          if (!e || !e.container.isEditable()) return;
          var t = "elementor-section--handles-inside",
            n = this.$element.find("> .elementor-element-overlay > .elementor-editor-section-settings");
          if (elementor.settings.page.model.attributes.scroll_snap) return void this.$element.addClass(t);
          var i = this.isOverflowHidden();
          if (!i && !this.isFirstSection()) return;
          var s = i ? 0 : this.getOffset();
          s < 25 ? (this.$element.addClass(t), s < -5 ? n.css("top", -s) : n.css("top", "")) : this.$element.removeClass(t);
        }
      }, {
        key: "onInit",
        value: function onInit() {
          this.isActive() && (this.setHandlesPosition(), this.$element.on("mouseenter", this.setHandlesPosition.bind(this)));
        }
      }]);
      return HandlesPosition;
    }(elementorModules.frontend.handlers.Base);
    t.default = HandlesPosition;
  },
  9320: function _(e, t, n) {
    var i = n(7914);
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var s = i(n(4058)),
      o = i(n(2987)),
      r = i(n(355)),
      a = i(n(2804)),
      l = i(n(3384)),
      d = [a.default, s.default, o.default, r.default, l.default];
    t.default = d;
  },
  3384: function _(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var Shapes = /*#__PURE__*/function (_elementorModules$fro5) {
      _inherits(Shapes, _elementorModules$fro5);
      var _super11 = _createSuper(Shapes);
      function Shapes() {
        _classCallCheck(this, Shapes);
        return _super11.apply(this, arguments);
      }
      _createClass(Shapes, [{
        key: "getDefaultSettings",
        value: function getDefaultSettings() {
          return {
            selectors: {
              container: "> .elementor-shape-%s"
            },
            svgURL: elementorFrontend.config.urls.assets + "shapes/"
          };
        }
      }, {
        key: "getDefaultElements",
        value: function getDefaultElements() {
          var e = {},
            t = this.getSettings("selectors");
          return e.$topContainer = this.$element.find(t.container.replace("%s", "top")), e.$bottomContainer = this.$element.find(t.container.replace("%s", "bottom")), e;
        }
      }, {
        key: "isActive",
        value: function isActive() {
          return elementorFrontend.isEditMode();
        }
      }, {
        key: "getSvgURL",
        value: function getSvgURL(e, t) {
          var n = this.getSettings("svgURL") + t + ".svg";
          return elementor.config.additional_shapes && e in elementor.config.additional_shapes && (n = elementor.config.additional_shapes[e], -1 < t.indexOf("-negative") && (n = n.replace(".svg", "-negative.svg"))), n;
        }
      }, {
        key: "buildSVG",
        value: function buildSVG(e) {
          var t = "shape_divider_" + e,
            n = this.getElementSettings(t),
            i = this.elements["$" + e + "Container"];
          if (i.attr("data-shape", n), !n) return void i.empty();
          var s = n;
          this.getElementSettings(t + "_negative") && (s += "-negative");
          var o = this.getSvgURL(n, s);
          jQuery.get(o, function (e) {
            i.empty().append(e.childNodes[0]);
          }), this.setNegative(e);
        }
      }, {
        key: "setNegative",
        value: function setNegative(e) {
          this.elements["$" + e + "Container"].attr("data-negative", !!this.getElementSettings("shape_divider_" + e + "_negative"));
        }
      }, {
        key: "onInit",
        value: function onInit() {
          var _get4,
            _this23 = this;
          for (var _len5 = arguments.length, e = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            e[_key5] = arguments[_key5];
          }
          this.isActive(this.getSettings()) && ((_get4 = _get(_getPrototypeOf(Shapes.prototype), "onInit", this)).call.apply(_get4, [this].concat(e)), ["top", "bottom"].forEach(function (e) {
            _this23.getElementSettings("shape_divider_" + e) && _this23.buildSVG(e);
          }));
        }
      }, {
        key: "onElementChange",
        value: function onElementChange(e) {
          var t = e.match(/^shape_divider_(top|bottom)$/);
          if (t) return void this.buildSVG(t[1]);
          var n = e.match(/^shape_divider_(top|bottom)_negative$/);
          n && (this.buildSVG(n[1]), this.setNegative(n[1]));
        }
      }]);
      return Shapes;
    }(elementorModules.frontend.handlers.Base);
    t.default = Shapes;
  },
  2804: function _(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var StretchedSection = /*#__PURE__*/function (_elementorModules$fro6) {
      _inherits(StretchedSection, _elementorModules$fro6);
      var _super12 = _createSuper(StretchedSection);
      function StretchedSection() {
        _classCallCheck(this, StretchedSection);
        return _super12.apply(this, arguments);
      }
      _createClass(StretchedSection, [{
        key: "bindEvents",
        value: function bindEvents() {
          var e = this.getUniqueHandlerID();
          elementorFrontend.addListenerOnce(e, "resize", this.stretch), elementorFrontend.addListenerOnce(e, "sticky:stick", this.stretch, this.$element), elementorFrontend.addListenerOnce(e, "sticky:unstick", this.stretch, this.$element), elementorFrontend.isEditMode() && (this.onKitChangeStretchContainerChange = this.onKitChangeStretchContainerChange.bind(this), elementor.channels.editor.on("kit:change:stretchContainer", this.onKitChangeStretchContainerChange));
        }
      }, {
        key: "unbindEvents",
        value: function unbindEvents() {
          elementorFrontend.removeListeners(this.getUniqueHandlerID(), "resize", this.stretch), elementorFrontend.isEditMode() && elementor.channels.editor.off("kit:change:stretchContainer", this.onKitChangeStretchContainerChange);
        }
      }, {
        key: "isActive",
        value: function isActive(e) {
          return elementorFrontend.isEditMode() || e.$element.hasClass("elementor-section-stretched");
        }
      }, {
        key: "initStretch",
        value: function initStretch() {
          this.stretch = this.stretch.bind(this), this.stretchElement = new elementorModules.frontend.tools.StretchElement({
            element: this.$element,
            selectors: {
              container: this.getStretchContainer()
            }
          });
        }
      }, {
        key: "getStretchContainer",
        value: function getStretchContainer() {
          return elementorFrontend.getKitSettings("stretched_section_container") || window;
        }
      }, {
        key: "stretch",
        value: function stretch() {
          this.getElementSettings("stretch_section") && this.stretchElement.stretch();
        }
      }, {
        key: "onInit",
        value: function onInit() {
          var _get5;
          for (var _len6 = arguments.length, e = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
            e[_key6] = arguments[_key6];
          }
          this.isActive(this.getSettings()) && (this.initStretch(), (_get5 = _get(_getPrototypeOf(StretchedSection.prototype), "onInit", this)).call.apply(_get5, [this].concat(e)), this.stretch());
        }
      }, {
        key: "onElementChange",
        value: function onElementChange(e) {
          "stretch_section" === e && (this.getElementSettings("stretch_section") ? this.stretch() : this.stretchElement.reset());
        }
      }, {
        key: "onKitChangeStretchContainerChange",
        value: function onKitChangeStretchContainerChange() {
          this.stretchElement.setSettings("selectors.container", this.getStretchContainer()), this.stretch();
        }
      }]);
      return StretchedSection;
    }(elementorModules.frontend.handlers.Base);
    t.default = StretchedSection;
  },
  3346: function _(e, t, n) {
    var i = n(6028);
    e.exports = elementorModules.ViewModule.extend({
      getDefaultSettings: function getDefaultSettings() {
        return {
          scrollDuration: 500,
          selectors: {
            links: 'a[href*="#"]',
            targets: ".elementor-element, .elementor-menu-anchor",
            scrollable: (0, i.isScrollSnapActive)() ? "body" : "html, body"
          }
        };
      },
      getDefaultElements: function getDefaultElements() {
        return {
          $scrollable: jQuery(this.getSettings("selectors").scrollable)
        };
      },
      bindEvents: function bindEvents() {
        elementorFrontend.elements.$document.on("click", this.getSettings("selectors.links"), this.handleAnchorLinks);
      },
      handleAnchorLinks: function handleAnchorLinks(e) {
        var t,
          n = e.currentTarget,
          s = location.pathname === n.pathname;
        if (location.hostname === n.hostname && s && !(n.hash.length < 2)) {
          try {
            t = jQuery(n.hash).filter(this.getSettings("selectors.targets"));
          } catch (e) {
            return;
          }
          if (t.length) {
            var o = t.offset().top,
              r = elementorFrontend.elements.$wpAdminBar,
              a = jQuery(".elementor-section.elementor-sticky--active:visible");
            r.length > 0 && (o -= r.height()), a.length > 0 && (o -= Math.max.apply(null, a.map(function () {
              return jQuery(this).outerHeight();
            }).get())), e.preventDefault(), o = elementorFrontend.hooks.applyFilters("frontend/handlers/menu_anchor/scroll_top_distance", o), (0, i.isScrollSnapActive)() && elementorFrontend.elements.$body.css("scroll-snap-type", "none"), this.elements.$scrollable.animate({
              scrollTop: o
            }, this.getSettings("scrollDuration"), "linear", function () {
              (0, i.isScrollSnapActive)() && elementorFrontend.elements.$body.css("scroll-snap-type", "");
            });
          }
        }
      },
      onInit: function onInit() {
        elementorModules.ViewModule.prototype.onInit.apply(this, arguments);
      }
    });
  },
  6866: function _(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var AssetsLoader = /*#__PURE__*/function () {
      function AssetsLoader() {
        _classCallCheck(this, AssetsLoader);
      }
      _createClass(AssetsLoader, [{
        key: "getScriptElement",
        value: function getScriptElement(e) {
          var t = document.createElement("script");
          return t.src = e, t;
        }
      }, {
        key: "getStyleElement",
        value: function getStyleElement(e) {
          var t = document.createElement("link");
          return t.rel = "stylesheet", t.href = e, t;
        }
      }, {
        key: "load",
        value: function load(e, t) {
          var _this24 = this;
          var n = AssetsLoader.assets[e][t];
          return n.loader || (n.loader = new Promise(function (t) {
            var i = "style" === e ? _this24.getStyleElement(n.src) : _this24.getScriptElement(n.src);
            i.onload = function () {
              return t(!0);
            };
            var s = "head" === n.parent ? n.parent : "body";
            document[s].appendChild(i);
          })), n.loader;
        }
      }]);
      return AssetsLoader;
    }();
    t.default = AssetsLoader;
    var n = elementorFrontendConfig.environmentMode.isScriptDebug ? "" : ".min";
    AssetsLoader.assets = {
      script: {
        dialog: {
          src: "".concat(elementorFrontendConfig.urls.assets, "lib/dialog/dialog").concat(n, ".js?ver=4.9.0")
        },
        "share-link": {
          src: "".concat(elementorFrontendConfig.urls.assets, "lib/share-link/share-link").concat(n, ".js?ver=").concat(elementorFrontendConfig.version)
        },
        swiper: {
          src: "".concat(elementorFrontendConfig.urls.assets, "lib/swiper/swiper").concat(n, ".js?ver=5.3.6")
        }
      },
      style: {}
    };
  },
  8646: function _(e, t, n) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var LightboxManager = /*#__PURE__*/function (_elementorModules$Vie4) {
      _inherits(LightboxManager, _elementorModules$Vie4);
      var _super13 = _createSuper(LightboxManager);
      function LightboxManager() {
        _classCallCheck(this, LightboxManager);
        return _super13.apply(this, arguments);
      }
      _createClass(LightboxManager, [{
        key: "getDefaultSettings",
        value: function getDefaultSettings() {
          return {
            selectors: {
              links: "a, [data-elementor-lightbox]"
            }
          };
        }
      }, {
        key: "getDefaultElements",
        value: function getDefaultElements() {
          return {
            $links: jQuery(this.getSettings("selectors.links"))
          };
        }
      }, {
        key: "isLightboxLink",
        value: function isLightboxLink(e) {
          if ("a" === e.tagName.toLowerCase() && (e.hasAttribute("download") || !/^[^?]+\.(png|jpe?g|gif|svg|webp)(\?.*)?$/i.test(e.href)) && !e.dataset.elementorLightboxVideo) return !1;
          var t = elementorFrontend.getKitSettings("global_image_lightbox"),
            n = e.dataset.elementorOpenLightbox;
          return "yes" === n || t && "no" !== n;
        }
      }, {
        key: "onLinkClick",
        value: function () {
          var _onLinkClick = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(e) {
            var t, n, i, s, o;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  t = e.currentTarget, n = jQuery(e.target), i = elementorFrontend.isEditMode(), s = i && elementor.$previewContents.find("body").hasClass("elementor-editor__ui-state__color-picker"), o = !!n.closest(".elementor-edit-area").length;
                  if (this.isLightboxLink(t)) {
                    _context2.next = 3;
                    break;
                  }
                  return _context2.abrupt("return", void (i && o && e.preventDefault()));
                case 3:
                  if (!(e.preventDefault(), i && !elementor.getPreferences("lightbox_in_editor"))) {
                    _context2.next = 5;
                    break;
                  }
                  return _context2.abrupt("return");
                case 5:
                  if (!s) {
                    _context2.next = 7;
                    break;
                  }
                  return _context2.abrupt("return");
                case 7:
                  if (!this.isOptimizedAssetsLoading()) {
                    _context2.next = 13;
                    break;
                  }
                  _context2.next = 10;
                  return LightboxManager.getLightbox();
                case 10:
                  _context2.t0 = _context2.sent;
                  _context2.next = 14;
                  break;
                case 13:
                  _context2.t0 = elementorFrontend.utils.lightbox;
                case 14:
                  _context2.t0.createLightbox(t);
                case 15:
                case "end":
                  return _context2.stop();
              }
            }, _callee2, this);
          }));
          function onLinkClick(_x2) {
            return _onLinkClick.apply(this, arguments);
          }
          return onLinkClick;
        }()
      }, {
        key: "isOptimizedAssetsLoading",
        value: function isOptimizedAssetsLoading() {
          return elementorFrontend.config.experimentalFeatures.e_optimized_assets_loading;
        }
      }, {
        key: "bindEvents",
        value: function bindEvents() {
          var _this25 = this;
          elementorFrontend.elements.$document.on("click", this.getSettings("selectors.links"), function (e) {
            return _this25.onLinkClick(e);
          });
        }
      }, {
        key: "onInit",
        value: function onInit() {
          var _get6,
            _this26 = this;
          for (var _len7 = arguments.length, e = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
            e[_key7] = arguments[_key7];
          }
          (_get6 = _get(_getPrototypeOf(LightboxManager.prototype), "onInit", this)).call.apply(_get6, [this].concat(e)), this.isOptimizedAssetsLoading() && !elementorFrontend.isEditMode() && this.elements.$links.each(function (e, t) {
            if (_this26.isLightboxLink(t)) return LightboxManager.getLightbox(), !1;
          });
        }
      }], [{
        key: "getLightbox",
        value: function getLightbox() {
          var e = new Promise(function (e) {
              n.e(723).then(n.t.bind(n, 3896, 23)).then(function (_ref8) {
                var t = _ref8.default;
                return e(new t());
              });
            }),
            t = elementorFrontend.utils.assetsLoader.load("script", "dialog"),
            i = elementorFrontend.utils.assetsLoader.load("script", "share-link");
          return Promise.all([e, t, i]).then(function () {
            return e;
          });
        }
      }]);
      return LightboxManager;
    }(elementorModules.ViewModule);
    t.default = LightboxManager;
  },
  8628: function _(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    t.default = /*#__PURE__*/function () {
      function Swiper(e, t) {
        var _this27 = this;
        _classCallCheck(this, Swiper);
        return this.config = t, this.config.breakpoints && (this.config = this.adjustConfig(t)), jQuery(e).closest(".elementor-widget-wrap").addClass("e-swiper-container"), new Promise(function (t) {
          if (!elementorFrontend.config.experimentalFeatures.e_optimized_assets_loading) return t(_this27.createSwiperInstance(e, _this27.config));
          elementorFrontend.utils.assetsLoader.load("script", "swiper").then(function () {
            return t(_this27.createSwiperInstance(e, _this27.config));
          });
        });
      }
      _createClass(Swiper, [{
        key: "createSwiperInstance",
        value: function createSwiperInstance(e, t) {
          var n = window.Swiper;
          return n.prototype.adjustConfig = this.adjustConfig, new n(e, t);
        }
      }, {
        key: "adjustConfig",
        value: function adjustConfig(e) {
          if (!e.handleElementorBreakpoints) return e;
          var t = elementorFrontend.config.responsive.activeBreakpoints,
            n = elementorFrontend.breakpoints.getBreakpointValues();
          return Object.keys(e.breakpoints).forEach(function (i) {
            var s = parseInt(i);
            var o;
            if (s === t.mobile.value || s + 1 === t.mobile.value) o = 0;else if (!t.widescreen || s !== t.widescreen.value && s + 1 !== t.widescreen.value) {
              var _e10 = n.findIndex(function (e) {
                return s === e || s + 1 === e;
              });
              o = n[_e10 - 1];
            } else o = s;
            e.breakpoints[o] = e.breakpoints[i], e.breakpoints[i] = {
              slidesPerView: e.slidesPerView,
              slidesPerGroup: e.slidesPerGroup ? e.slidesPerGroup : 1
            };
          }), e;
        }
      }]);
      return Swiper;
    }();
  },
  2064: function _(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var _default = /*#__PURE__*/function (_elementorModules$Vie5) {
      _inherits(_default, _elementorModules$Vie5);
      var _super14 = _createSuper(_default);
      function _default() {
        _classCallCheck(this, _default);
        return _super14.apply(this, arguments);
      }
      _createClass(_default, [{
        key: "getDefaultSettings",
        value: function getDefaultSettings() {
          return {
            selectors: {
              links: 'a[href^="%23elementor-action"], a[href^="#elementor-action"]'
            }
          };
        }
      }, {
        key: "bindEvents",
        value: function bindEvents() {
          elementorFrontend.elements.$document.on("click", this.getSettings("selectors.links"), this.runLinkAction.bind(this));
        }
      }, {
        key: "initActions",
        value: function initActions() {
          this.actions = {
            lightbox: function () {
              var _lightbox = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(e) {
                var t;
                return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                  while (1) switch (_context3.prev = _context3.next) {
                    case 0:
                      _context3.next = 2;
                      return elementorFrontend.utils.lightbox;
                    case 2:
                      t = _context3.sent;
                      e.slideshow ? t.openSlideshow(e.slideshow, e.url) : (e.id && (e.type = "image"), t.showModal(e));
                    case 4:
                    case "end":
                      return _context3.stop();
                  }
                }, _callee3);
              }));
              function lightbox(_x3) {
                return _lightbox.apply(this, arguments);
              }
              return lightbox;
            }()
          };
        }
      }, {
        key: "addAction",
        value: function addAction(e, t) {
          this.actions[e] = t;
        }
      }, {
        key: "runAction",
        value: function runAction(e) {
          var n = (e = decodeURIComponent(e)).match(/action=(.+?)&/),
            i = e.match(/settings=(.+)/);
          if (!n) return;
          var s = this.actions[n[1]];
          if (!s) return;
          var o = {};
          for (var _len8 = arguments.length, t = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
            t[_key8 - 1] = arguments[_key8];
          }
          i && (o = JSON.parse(atob(i[1]))), s.apply(void 0, [o].concat(t));
        }
      }, {
        key: "runLinkAction",
        value: function runLinkAction(e) {
          e.preventDefault(), this.runAction(jQuery(e.currentTarget).attr("href"), e);
        }
      }, {
        key: "runHashAction",
        value: function runHashAction() {
          if (!location.hash) return;
          var e = document.querySelector("[e-action-hash=\"".concat(location.hash, "\"], a[href*=\"").concat(location.hash, "\"]"));
          e && this.runAction(e.getAttribute("e-action-hash"));
        }
      }, {
        key: "createActionHash",
        value: function createActionHash(e, t) {
          return encodeURIComponent("#elementor-action:action=".concat(e, "&settings=").concat(btoa(JSON.stringify(t))));
        }
      }, {
        key: "onInit",
        value: function onInit() {
          _get(_getPrototypeOf(_default.prototype), "onInit", this).call(this), this.initActions(), elementorFrontend.on("components:init", this.runHashAction.bind(this));
        }
      }]);
      return _default;
    }(elementorModules.ViewModule);
    t.default = _default;
  },
  6028: function _(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.isScrollSnapActive = t.escapeHTML = void 0;
    t.escapeHTML = function (e) {
      var t = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        "'": "&#39;",
        '"': "&quot;"
      };
      return e.replace(/[&<>'"]/g, function (e) {
        return t[e] || e;
      });
    };
    t.isScrollSnapActive = function () {
      var e, t;
      return "yes" === (elementorFrontend.isEditMode() ? null === (e = elementor.settings.page.model.attributes) || void 0 === e ? void 0 : e.scroll_snap : null === (t = elementorFrontend.config.settings.page) || void 0 === t ? void 0 : t.scroll_snap);
    };
  },
  4773: function _(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var BaseLoader = /*#__PURE__*/function (_elementorModules$Vie6) {
      _inherits(BaseLoader, _elementorModules$Vie6);
      var _super15 = _createSuper(BaseLoader);
      function BaseLoader() {
        _classCallCheck(this, BaseLoader);
        return _super15.apply(this, arguments);
      }
      _createClass(BaseLoader, [{
        key: "getDefaultSettings",
        value: function getDefaultSettings() {
          return {
            isInserted: !1,
            selectors: {
              firstScript: "script:first"
            }
          };
        }
      }, {
        key: "getDefaultElements",
        value: function getDefaultElements() {
          return {
            $firstScript: jQuery(this.getSettings("selectors.firstScript"))
          };
        }
      }, {
        key: "insertAPI",
        value: function insertAPI() {
          this.elements.$firstScript.before(jQuery("<script>", {
            src: this.getApiURL()
          })), this.setSettings("isInserted", !0);
        }
      }, {
        key: "getVideoIDFromURL",
        value: function getVideoIDFromURL(e) {
          var t = e.match(this.getURLRegex());
          return t && t[1];
        }
      }, {
        key: "onApiReady",
        value: function onApiReady(e) {
          var _this28 = this;
          this.getSettings("isInserted") || this.insertAPI(), this.isApiLoaded() ? e(this.getApiObject()) : setTimeout(function () {
            _this28.onApiReady(e);
          }, 350);
        }
      }, {
        key: "getAutoplayURL",
        value: function getAutoplayURL(e) {
          return e.replace("&autoplay=0", "") + "&autoplay=1";
        }
      }]);
      return BaseLoader;
    }(elementorModules.ViewModule);
    t.default = BaseLoader;
  },
  1911: function _(e, t, n) {
    var i = n(7914);
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var s = i(n(4773));
    var VimeoLoader = /*#__PURE__*/function (_s$default) {
      _inherits(VimeoLoader, _s$default);
      var _super16 = _createSuper(VimeoLoader);
      function VimeoLoader() {
        _classCallCheck(this, VimeoLoader);
        return _super16.apply(this, arguments);
      }
      _createClass(VimeoLoader, [{
        key: "getApiURL",
        value: function getApiURL() {
          return "https://player.vimeo.com/api/player.js";
        }
      }, {
        key: "getURLRegex",
        value: function getURLRegex() {
          return /^(?:https?:\/\/)?(?:www|player\.)?(?:vimeo\.com\/)?(?:video\/|external\/)?(\d+)([^.?&#"'>]?)/;
        }
      }, {
        key: "isApiLoaded",
        value: function isApiLoaded() {
          return window.Vimeo;
        }
      }, {
        key: "getApiObject",
        value: function getApiObject() {
          return Vimeo;
        }
      }, {
        key: "getAutoplayURL",
        value: function getAutoplayURL(e) {
          var t = (e = _get(_getPrototypeOf(VimeoLoader.prototype), "getAutoplayURL", this).call(this, e)).match(/#t=[^&]*/);
          return e.replace(t[0], "") + t;
        }
      }]);
      return VimeoLoader;
    }(s.default);
    t.default = VimeoLoader;
  },
  1604: function _(e, t, n) {
    var i = n(7914);
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var s = i(n(4773));
    var YoutubeLoader = /*#__PURE__*/function (_s$default2) {
      _inherits(YoutubeLoader, _s$default2);
      var _super17 = _createSuper(YoutubeLoader);
      function YoutubeLoader() {
        _classCallCheck(this, YoutubeLoader);
        return _super17.apply(this, arguments);
      }
      _createClass(YoutubeLoader, [{
        key: "getApiURL",
        value: function getApiURL() {
          return "https://www.youtube.com/iframe_api";
        }
      }, {
        key: "getURLRegex",
        value: function getURLRegex() {
          return /^(?:https?:\/\/)?(?:www\.)?(?:m\.)?(?:youtu\.be\/|youtube\.com\/(?:(?:watch)?\?(?:.*&)?vi?=|(?:embed|v|vi|user)\/))([^?&"'>]+)/;
        }
      }, {
        key: "isApiLoaded",
        value: function isApiLoaded() {
          return window.YT && YT.loaded;
        }
      }, {
        key: "getApiObject",
        value: function getApiObject() {
          return YT;
        }
      }]);
      return YoutubeLoader;
    }(s.default);
    t.default = YoutubeLoader;
  },
  59: function _(e, t, n) {
    n.p = elementorFrontendConfig.urls.assets + "js/";
  },
  4375: function _(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var Breakpoints = /*#__PURE__*/function (_elementorModules$Mod) {
      _inherits(Breakpoints, _elementorModules$Mod);
      var _super18 = _createSuper(Breakpoints);
      function Breakpoints(e) {
        var _this29;
        _classCallCheck(this, Breakpoints);
        _this29 = _super18.call(this), _this29.responsiveConfig = e;
        return _this29;
      }
      _createClass(Breakpoints, [{
        key: "getActiveBreakpointsList",
        value: function getActiveBreakpointsList() {
          var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          e = _objectSpread({
            largeToSmall: !1,
            withDesktop: !1
          }, e);
          var t = Object.keys(this.responsiveConfig.activeBreakpoints);
          if (e.withDesktop) {
            var _e11 = -1 === t.indexOf("widescreen") ? t.length : t.length - 1;
            t.splice(_e11, 0, "desktop");
          }
          return e.largeToSmall && t.reverse(), t;
        }
      }, {
        key: "getBreakpointValues",
        value: function getBreakpointValues() {
          var e = this.responsiveConfig.activeBreakpoints,
            t = [];
          return Object.values(e).forEach(function (e) {
            t.push(e.value);
          }), t;
        }
      }, {
        key: "getDesktopPreviousDeviceKey",
        value: function getDesktopPreviousDeviceKey() {
          var e = "";
          var t = this.responsiveConfig.activeBreakpoints,
            n = Object.keys(t),
            i = n.length;
          return e = "min" === t[n[i - 1]].direction ? n[i - 2] : n[i - 1], e;
        }
      }, {
        key: "getDesktopMinPoint",
        value: function getDesktopMinPoint() {
          var e = this.responsiveConfig.activeBreakpoints;
          return e[this.getDesktopPreviousDeviceKey()].value + 1;
        }
      }, {
        key: "getDeviceMinBreakpoint",
        value: function getDeviceMinBreakpoint(e) {
          if ("desktop" === e) return this.getDesktopMinPoint();
          var t = this.responsiveConfig.activeBreakpoints,
            n = Object.keys(t);
          var i;
          if (n[0] === e) i = 320;else if ("widescreen" === e) i = t[e] ? t[e].value : this.responsiveConfig.breakpoints.widescreen;else {
            var s = n.indexOf(e);
            i = t[n[s - 1]].value + 1;
          }
          return i;
        }
      }, {
        key: "getActiveMatchRegex",
        value: function getActiveMatchRegex() {
          return new RegExp(this.getActiveBreakpointsList().map(function (e) {
            return "_" + e;
          }).join("|") + "$");
        }
      }]);
      return Breakpoints;
    }(elementorModules.Module);
    t.default = Breakpoints;
  },
  6404: function _(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = t.Events = void 0;
    var Events = /*#__PURE__*/function () {
      function Events() {
        _classCallCheck(this, Events);
      }
      _createClass(Events, null, [{
        key: "dispatch",
        value: function dispatch(e, t) {
          var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          e = e instanceof jQuery ? e[0] : e, i && e.dispatchEvent(new CustomEvent(i, {
            detail: n
          })), e.dispatchEvent(new CustomEvent(t, {
            detail: n
          }));
        }
      }]);
      return Events;
    }();
    t.Events = Events;
    var n = Events;
    t.default = n;
  },
  9469: function _(e) {
    e.exports = function () {
      var e,
        t = Array.prototype.slice,
        n = {
          actions: {},
          filters: {}
        };
      function _removeHook(e, t, i, s) {
        var o, r, a;
        if (n[e][t]) if (i) {
          if (o = n[e][t], s) for (a = o.length; a--;) (r = o[a]).callback === i && r.context === s && o.splice(a, 1);else for (a = o.length; a--;) o[a].callback === i && o.splice(a, 1);
        } else n[e][t] = [];
      }
      function _addHook(e, t, i, s, o) {
        var r = {
            callback: i,
            priority: s,
            context: o
          },
          a = n[e][t];
        if (a) {
          var l = !1;
          if (jQuery.each(a, function () {
            if (this.callback === i) return l = !0, !1;
          }), l) return;
          a.push(r), a = function _hookInsertSort(e) {
            for (var t, n, i, s = 1, o = e.length; s < o; s++) {
              for (t = e[s], n = s; (i = e[n - 1]) && i.priority > t.priority;) e[n] = e[n - 1], --n;
              e[n] = t;
            }
            return e;
          }(a);
        } else a = [r];
        n[e][t] = a;
      }
      function _runHook(e, t, i) {
        var s,
          o,
          r = n[e][t];
        if (!r) return "filters" === e && i[0];
        if (o = r.length, "filters" === e) for (s = 0; s < o; s++) i[0] = r[s].callback.apply(r[s].context, i);else for (s = 0; s < o; s++) r[s].callback.apply(r[s].context, i);
        return "filters" !== e || i[0];
      }
      return e = {
        removeFilter: function removeFilter(t, n) {
          return "string" == typeof t && _removeHook("filters", t, n), e;
        },
        applyFilters: function applyFilters() {
          var n = t.call(arguments),
            i = n.shift();
          return "string" == typeof i ? _runHook("filters", i, n) : e;
        },
        addFilter: function addFilter(t, n, i, s) {
          return "string" == typeof t && "function" == typeof n && _addHook("filters", t, n, i = parseInt(i || 10, 10), s), e;
        },
        removeAction: function removeAction(t, n) {
          return "string" == typeof t && _removeHook("actions", t, n), e;
        },
        doAction: function doAction() {
          var n = t.call(arguments),
            i = n.shift();
          return "string" == typeof i && _runHook("actions", i, n), e;
        },
        addAction: function addAction(t, n, i, s) {
          return "string" == typeof t && "function" == typeof n && _addHook("actions", t, n, i = parseInt(i || 10, 10), s), e;
        }
      }, e;
    };
  },
  3308: function _(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var matchUserAgent = function matchUserAgent(e) {
        return n.indexOf(e) >= 0;
      },
      n = navigator.userAgent,
      i = !!window.opr && !!opr.addons || !!window.opera || matchUserAgent(" OPR/"),
      s = matchUserAgent("Firefox"),
      o = /^((?!chrome|android).)*safari/i.test(n) || /constructor/i.test(window.HTMLElement) || "[object SafariRemoteNotification]" === (!window.safari || "undefined" != typeof safari && safari.pushNotification).toString(),
      r = /Trident|MSIE/.test(n) && !!document.documentMode,
      a = !r && !!window.StyleMedia || matchUserAgent("Edg"),
      l = !!window.chrome && matchUserAgent("Chrome") && !(a || i),
      d = matchUserAgent("Chrome") && !!window.CSS;
    var c = {
      appleWebkit: matchUserAgent("AppleWebKit") && !d,
      blink: d,
      chrome: l,
      edge: a,
      firefox: s,
      ie: r,
      mac: matchUserAgent("Macintosh"),
      opera: i,
      safari: o,
      webkit: matchUserAgent("AppleWebKit")
    };
    t.default = c;
  },
  5107: function _(e, t) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var _default = /*#__PURE__*/function (_elementorModules$Mod2) {
      _inherits(_default, _elementorModules$Mod2);
      var _super19 = _createSuper(_default);
      function _default() {
        _classCallCheck(this, _default);
        return _super19.apply(this, arguments);
      }
      _createClass(_default, [{
        key: "get",
        value: function get(e, t) {
          var n;
          t = t || {};
          try {
            n = t.session ? sessionStorage : localStorage;
          } catch (t) {
            return e ? void 0 : {};
          }
          var i = n.getItem("elementor");
          i = i ? JSON.parse(i) : {}, i.__expiration || (i.__expiration = {});
          var s = i.__expiration;
          var o = [];
          e ? s[e] && (o = [e]) : o = Object.keys(s);
          var r = !1;
          return o.forEach(function (e) {
            new Date(s[e]) < new Date() && (delete i[e], delete s[e], r = !0);
          }), r && this.save(i, t.session), e ? i[e] : i;
        }
      }, {
        key: "set",
        value: function set(e, t, n) {
          n = n || {};
          var i = this.get(null, n);
          if (i[e] = t, n.lifetimeInSeconds) {
            var _t9 = new Date();
            _t9.setTime(_t9.getTime() + 1e3 * n.lifetimeInSeconds), i.__expiration[e] = _t9.getTime();
          }
          this.save(i, n.session);
        }
      }, {
        key: "save",
        value: function save(e, t) {
          var n;
          try {
            n = t ? sessionStorage : localStorage;
          } catch (e) {
            return;
          }
          n.setItem("elementor", JSON.stringify(e));
        }
      }]);
      return _default;
    }(elementorModules.Module);
    t.default = _default;
  },
  6046: function _(e, t, n) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.default = void 0;
    var _default = /*#__PURE__*/function (_elementorModules$Mod3) {
      _inherits(_default, _elementorModules$Mod3);
      var _super20 = _createSuper(_default);
      function _default() {
        var _this30;
        _classCallCheck(this, _default);
        _this30 = _super20.call(this), elementorFrontend.elementsHandler.attachHandler("text-path", function () {
          return n.e(48).then(n.bind(n, 6468));
        });
        return _this30;
      }
      return _createClass(_default);
    }(elementorModules.Module);
    t.default = _default;
  }
}, function (e) {
  e.O(0, [354], function () {
    return t = 5654, e(e.s = t);
    var t;
  });
  e.O();
}]);
},{"jquery":"node_modules/jquery/dist/jquery.js","popper.js":"node_modules/popper.js/dist/esm/popper.js"}],"../../../Users/Oluwanifemi/AppData/Roaming/npm/node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}
module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "58977" + '/');
  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);
    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);
          if (didAccept) {
            handled = true;
          }
        }
      });

      // Enable HMR for CSS by default.
      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });
      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }
    if (data.type === 'reload') {
      ws.close();
      ws.onclose = function () {
        location.reload();
      };
    }
    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }
    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}
function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);
  if (overlay) {
    overlay.remove();
  }
}
function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID;

  // html encode message and stack trace
  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}
function getParents(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return [];
  }
  var parents = [];
  var k, d, dep;
  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];
      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }
  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }
  return parents;
}
function hmrApply(bundle, asset) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}
function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }
  if (checkedAssets[id]) {
    return;
  }
  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }
  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}
function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};
  if (cached) {
    cached.hot.data = bundle.hotData;
  }
  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }
  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });
    return true;
  }
}
},{}]},{},["../../../Users/Oluwanifemi/AppData/Roaming/npm/node_modules/parcel-bundler/src/builtins/hmr-runtime.js","wp-content/cache/autoptimize/js/autoptimize_3d4b16c409af790573084eb2e2b80897.js"], null)
//# sourceMappingURL=/autoptimize_3d4b16c409af790573084eb2e2b80897.f4e53b20.js.map